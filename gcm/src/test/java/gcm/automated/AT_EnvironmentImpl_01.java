package gcm.automated;

import static gcm.automated.support.EnvironmentSupport.addStandardComponentsAndTypes;
import static gcm.automated.support.EnvironmentSupport.addStandardPeople;
import static gcm.automated.support.EnvironmentSupport.addStandardPropertyDefinitions;
import static gcm.automated.support.EnvironmentSupport.addStandardTrackingAndScenarioId;
import static gcm.automated.support.EnvironmentSupport.addTaskPlanContainer;
import static gcm.automated.support.EnvironmentSupport.assertAllPlansExecuted;
import static gcm.automated.support.EnvironmentSupport.generatePropertyValue;
import static gcm.automated.support.EnvironmentSupport.getRandomGenerator;
import static gcm.automated.support.EnvironmentSupport.getReplication;
import static gcm.automated.support.ExceptionAssertion.assertModelException;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.math3.random.RandomGenerator;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import gcm.automated.support.EmptyTaskPlan;
import gcm.automated.support.EnvironmentSupport;
import gcm.automated.support.EnvironmentSupport.PropertyAssignmentPolicy;
import gcm.automated.support.SeedProvider;
import gcm.automated.support.TaskPlanContainer;
import gcm.automated.support.TestCompartmentId;
import gcm.automated.support.TestGlobalComponentId;
import gcm.automated.support.TestGroupTypeId;
import gcm.automated.support.TestMaterialId;
import gcm.automated.support.TestMaterialsProducerId;
import gcm.automated.support.TestPersonPropertyId;
import gcm.automated.support.TestRegionId;
import gcm.automated.support.TestResourceId;
import gcm.replication.Replication;
import gcm.scenario.BatchId;
import gcm.scenario.CompartmentId;
import gcm.scenario.GroupId;
import gcm.scenario.GroupPropertyId;
import gcm.scenario.GroupTypeId;
import gcm.scenario.PersonId;
import gcm.scenario.PersonPropertyId;
import gcm.scenario.PropertyDefinition;
import gcm.scenario.RegionId;
import gcm.scenario.ResourceId;
import gcm.scenario.Scenario;
import gcm.scenario.ScenarioBuilder;
import gcm.scenario.UnstructuredScenarioBuilder;
import gcm.simulation.Context;
import gcm.simulation.EnvironmentImpl;
import gcm.simulation.GroupConstructionInfo;
import gcm.simulation.GroupConstructionInfo.Builder;
import gcm.simulation.PersonConstructionInfo;
import gcm.simulation.Plan;
import gcm.simulation.Simulation;
import gcm.simulation.SimulationErrorType;
import gcm.util.annotations.UnitTest;
import gcm.util.annotations.UnitTestConstructor;
import gcm.util.annotations.UnitTestMethod;

@UnitTest(target = EnvironmentImpl.class)

public class AT_EnvironmentImpl_01 {

	private static SeedProvider SEED_PROVIDER;

	@BeforeAll
	public static void beforeClass() {
		SEED_PROVIDER = new SeedProvider(EnvironmentSupport.getMetaSeed(1));
	}

	/**
	 * Internal test(not part of public tests) to show that there are no large gaps
	 * in the seed cases generated by the SeedProvider.
	 */
	@AfterAll
	public static void afterClass() {
//		 System.out.println(AT_EnvironmentImpl_01.class.getSimpleName() + " "
//		 + SEED_PROVIDER.generateUnusedSeedReport());
	}

	/**
	 * Tests {@link EnvironmentImpl#addGroup(GroupTypeId)}
	 */
	@Test
	@UnitTestMethod(name = "addGroup", args = { GroupTypeId.class })
	public void testAddGroup_GroupTypeId() {
		/*
		 * Assert that the groups can be added
		 */

		final long seed = SEED_PROVIDER.getSeedValue(0);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 0;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				final GroupId groupId = environment.addGroup(testGroupTypeId);
				assertTrue(environment.groupExists(groupId));
			}
		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the group type id is null
			GroupTypeId nullGroupTypeId = null;
			assertModelException(() -> environment.addGroup(nullGroupTypeId), SimulationErrorType.NULL_GROUP_TYPE_ID);
			// if the group type id is unknown
			assertModelException(() -> environment.addGroup(TestGroupTypeId.getUnknownGroupTypeId()),
					SimulationErrorType.UNKNOWN_GROUP_TYPE_ID);
		});

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			// if the component is not a global,region or compartment
			// component
			assertModelException(() -> environment.addGroup(TestGroupTypeId.GROUP_TYPE_1),
					SimulationErrorType.COMPONENT_LACKS_PERMISSION);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

	}

	/**
	 * Tests {@link EnvironmentImpl#addGroup(GroupConstructionInfo)}
	 */
	@Test
	@UnitTestMethod(name = "addGroup", args = { GroupConstructionInfo.class })
	public void testAddGroup_GroupConstructionInfo() {
		/*
		 * Assert that the groups can be added
		 */

		final long seed = SEED_PROVIDER.getSeedValue(4);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 0;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {

				Builder builder = GroupConstructionInfo.builder();
				builder.setGroupTypeId(testGroupTypeId);
				Map<GroupPropertyId, Object> expectedPropertyValues = new LinkedHashMap<>();
				for (GroupPropertyId groupPropertyId : testGroupTypeId.getGroupPropertyIds()) {
					PropertyDefinition propertyDefinition = environment.getGroupPropertyDefinition(testGroupTypeId,
							groupPropertyId);
					Object propertyValue = generatePropertyValue(propertyDefinition, randomGenerator);
					expectedPropertyValues.put(groupPropertyId, propertyValue);
					builder.setGroupPropertyValue(groupPropertyId, propertyValue);
				}
				GroupConstructionInfo groupConstructionInfo = builder.build();
				final GroupId groupId = environment.addGroup(groupConstructionInfo);
				assertTrue(environment.groupExists(groupId));
				for (GroupPropertyId groupPropertyId : testGroupTypeId.getGroupPropertyIds()) {
					Object actualPropertyValue = environment.getGroupPropertyValue(groupId, groupPropertyId);
					Object expectedPropertyValue = expectedPropertyValues.get(groupPropertyId);
					assertEquals(expectedPropertyValue, actualPropertyValue);
				}
			}
		});

		// precondition tests
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the group type id is null
			GroupConstructionInfo nullGroupConstructionInfo = null;
			assertModelException(() -> environment.addGroup(nullGroupConstructionInfo),
					SimulationErrorType.NULL_GROUP_CONSTRUCTION_INFO); // if the group type id is unknown
			GroupConstructionInfo groupConstructionInfo = GroupConstructionInfo.builder()
					.setGroupTypeId(TestGroupTypeId.getUnknownGroupTypeId()).build();
			assertModelException(() -> environment.addGroup(groupConstructionInfo),
					SimulationErrorType.UNKNOWN_GROUP_TYPE_ID);
		});

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			// if the component is not a global,region or compartment
			// component
			GroupConstructionInfo groupConstructionInfo = GroupConstructionInfo.builder()
					.setGroupTypeId(TestGroupTypeId.GROUP_TYPE_1).build();
			assertModelException(() -> environment.addGroup(groupConstructionInfo),
					SimulationErrorType.COMPONENT_LACKS_PERMISSION);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

	}

	/**
	 * Tests {@link EnvironmentImpl#addPerson(RegionId, CompartmentId)}
	 */
	@Test
	@UnitTestMethod(name = "addPerson", args = { RegionId.class, CompartmentId.class })
	public void testAddPerson_RegionId_CompartmentId() {
		final long seed = SEED_PROVIDER.getSeedValue(1);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		/*
		 * This first test plan just checks that people are added sequentially and are
		 * located where we expect them to be
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			/*
			 * Determine the person id we expect will be returned by the environment upon
			 * the next addPerson() invocation.
			 */
			Integer expectedPersonIdValue = environment.getPopulationCount();

			for (final TestRegionId testRegionId : TestRegionId.values()) {
				for (final TestCompartmentId testCompartmentId : TestCompartmentId.values()) {
					final PersonId personId = environment.addPerson(testRegionId, testCompartmentId);
					/*
					 * Assert that the environment is assigning the person id as we expect
					 */
					PersonId expectedPersonId = new PersonId(expectedPersonIdValue++);
					assertEquals(expectedPersonId, personId);

					/*
					 * Assert that the new person is located where we expect them
					 */
					assertEquals(testRegionId, environment.getPersonRegion(personId));
					assertEquals(testCompartmentId, environment.getPersonCompartment(personId));

				}
			}

		});

		/*
		 * Now we test preconditions
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_2, testTime++, (environment) -> {

			assertModelException(() -> environment.addPerson(null, TestCompartmentId.COMPARTMENT_1),
					SimulationErrorType.NULL_REGION_ID);
			assertModelException(
					() -> environment.addPerson(TestRegionId.getUnknownRegionId(), TestCompartmentId.COMPARTMENT_1),
					SimulationErrorType.UNKNOWN_REGION_ID);
			assertModelException(() -> environment.addPerson(TestRegionId.REGION_1, null),
					SimulationErrorType.NULL_COMPARTMENT_ID);
			assertModelException(
					() -> environment.addPerson(TestRegionId.REGION_1, TestCompartmentId.getUnknownCompartmentId()),
					SimulationErrorType.UNKNOWN_COMPARTMENT_ID);

		});

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			assertModelException(() -> environment.addPerson(TestRegionId.REGION_1, TestCompartmentId.COMPARTMENT_1),
					SimulationErrorType.COMPONENT_LACKS_PERMISSION);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#addPersonToGroup(PersonId, GroupId)}
	 */
	@Test
	@UnitTestMethod(name = "addPersonToGroup", args = { PersonId.class, GroupId.class })
	public void testAddPersonToGroup() {
		/*
		 * Assert that people can be added to groups
		 */
		final long seed = SEED_PROVIDER.getSeedValue(2);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 0;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			int groupCount = 0;
			// create some groups

			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				for (int i = 0; i < 5; i++) {
					final GroupId groupId = environment.addGroup(testGroupTypeId);
					assertEquals(groupCount, groupId.getValue());
					groupCount++;
				}
			}

			final List<PersonId> people = environment.getPeople();
			// show that there are enough people to make a valid test
			assertTrue(people.size() > 100);

			for (final PersonId personId : people) {
				// pick a random group
				final GroupId groupId = new GroupId(environment.getRandomGenerator().nextInt(groupCount));
				// put the person in the group
				environment.addPersonToGroup(personId, groupId);
				// show that the person is now in the group
				assertTrue(environment.isGroupMember(personId, groupId));
			}

		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// if the group id is null
			assertModelException(() -> environment.addPersonToGroup(new PersonId(0), null),
					SimulationErrorType.NULL_GROUP_ID);
			// if the group id is unknown
			assertModelException(() -> environment.addPersonToGroup(new PersonId(0), new GroupId(-1)),
					SimulationErrorType.UNKNOWN_GROUP_ID);
			// if the person id is null
			assertModelException(() -> environment.addPersonToGroup(null, new GroupId(0)),
					SimulationErrorType.NULL_PERSON_ID);
			// if the person id is unknown
			assertModelException(() -> environment.addPersonToGroup(new PersonId(-1), new GroupId(0)),
					SimulationErrorType.UNKNOWN_PERSON_ID);
			GroupId groupId = environment.addGroup(TestGroupTypeId.GROUP_TYPE_1);
			environment.addPersonToGroup(new PersonId(0), groupId);
			assertModelException(() -> environment.addPersonToGroup(new PersonId(0), groupId),
					SimulationErrorType.DUPLICATE_GROUP_MEMBERSHIP);
		});

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			// find a person who is not in a group and add them to that
			// group
			boolean candidateFound = false;
			List<PersonId> people = environment.getPeople();
			List<GroupId> groupIds = environment.getGroupIds();
			groupLoop: for (GroupId groupId : groupIds) {
				for (PersonId personId : people) {
					if (!environment.isGroupMember(personId, groupId)) {
						assertModelException(() -> environment.addPersonToGroup(personId, groupId),
								SimulationErrorType.COMPONENT_LACKS_PERMISSION);
						candidateFound = true;
						break groupLoop;
					}
				}
			}
			// show that the model exception assertion was performed
			assertTrue(candidateFound);
		});
		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests {@link EnvironmentImpl#addPlan(Plan, double)
	 *
	 */
	@Test
	@UnitTestMethod(name = "addPlan", args = { Plan.class, double.class })
	public void testAddPlan_WithoutKey() {
		final long seed = SEED_PROVIDER.getSeedValue(5);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		/*
		 * We demonstrate that a plan is added successfully by showing that the plan
		 * gets executed at the appropriate time. Note that the plan will NOT have a
		 * key.
		 */
		taskPlanContainer.addKeylessTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// check that the time of execution is correct
			assertEquals(1.0, environment.getTime(), 0);
		});

		/*
		 * We now test preconditions
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// if the plan is null
			assertModelException(() -> environment.addPlan(null, 1000), SimulationErrorType.NULL_PLAN);

			// if the plan time is in the past
			assertModelException(() -> environment.addPlan(new EmptyTaskPlan(400, "key2"), 0),
					SimulationErrorType.PAST_PLANNING_TIME);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#addPlan(Plan, double, Object)
	 *
	 */
	@Test
	@UnitTestMethod(name = "addPlan", args = { Plan.class, double.class, Object.class })
	public void testAddPlan_WithKey() {
		final long seed = SEED_PROVIDER.getSeedValue(3);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		/*
		 * We demonstrate that a plan is added successfully by showing that the plan
		 * gets executed at the appropriate time.
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// check that the time of execution is correct
			assertEquals(1.0, environment.getTime(), 0);
		});

		/*
		 * We now test preconditions
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// if the plan is null
			assertModelException(() -> environment.addPlan(null, 1000, "key1"), SimulationErrorType.NULL_PLAN);

			// if the plan time is in the past
			assertModelException(() -> environment.addPlan(new EmptyTaskPlan(400, "key2"), 0, "key2"),
					SimulationErrorType.PAST_PLANNING_TIME);

			// if the key is null
			assertModelException(() -> environment.addPlan(new EmptyTaskPlan(500, ""), 10, (Object[]) null),
					SimulationErrorType.NULL_PLAN_KEY);

			// if the key corresponds to an active plan
			environment.addPlan(new EmptyTaskPlan(600, "key3"), 25, "key3");
			assertModelException(() -> environment.addPlan(new EmptyTaskPlan(700, "key3"), 10, "key3"),
					SimulationErrorType.DUPLICATE_PLAN_KEY);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#addResourceToRegion(ResourceId, RegionId, long)}
	 */
	@Test
	@UnitTestMethod(name = "addResourceToRegion", args = { ResourceId.class, RegionId.class, long.class })
	public void testAddResourceToRegion() {
		final long seed = SEED_PROVIDER.getSeedValue(6);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			for (final TestRegionId testRegionId : TestRegionId.values()) {
				for (final TestResourceId testResourceId : TestResourceId.values()) {
					/*
					 * determine the current level
					 */
					final long currentResourceLevel = environment.getRegionResourceLevel(testRegionId, testResourceId);

					/*
					 * generate a positive amount to add
					 */
					final long amount = environment.getRandomGenerator().nextInt(99) + 1;

					/*
					 * add amount to region
					 */
					final long expectedResourceLevel = currentResourceLevel + amount;
					environment.addResourceToRegion(testResourceId, testRegionId, amount);

					/*
					 * make sure that we still agree
					 */
					final long actualResourceLevel = environment.getRegionResourceLevel(testRegionId, testResourceId);
					assertEquals(expectedResourceLevel, actualResourceLevel);
				}
			}

		});

		/*
		 * We now test all preconditions
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// if the region id is null
			assertModelException(() -> environment.addResourceToRegion(TestResourceId.RESOURCE1, null, 1),
					SimulationErrorType.NULL_REGION_ID);
			// if the region id is unknown
			assertModelException(() -> environment.addResourceToRegion(TestResourceId.RESOURCE1,
					TestRegionId.getUnknownRegionId(), 1), SimulationErrorType.UNKNOWN_REGION_ID);
			// if the resource id is null
			assertModelException(() -> environment.addResourceToRegion(null, TestRegionId.REGION_1, 1),
					SimulationErrorType.NULL_RESOURCE_ID);
			// if the resource id is unknown
			assertModelException(() -> environment.addResourceToRegion(TestResourceId.getUnknownResourceId(),
					TestRegionId.REGION_1, 1), SimulationErrorType.UNKNOWN_RESOURCE_ID);
			// if the amount is negative
			assertModelException(
					() -> environment.addResourceToRegion(TestResourceId.RESOURCE1, TestRegionId.REGION_1, -1),
					SimulationErrorType.NEGATIVE_RESOURCE_AMOUNT);

			// if the amount results in an overflow of the corresponding
			// region's inventory level
			// max out region1's inventory of resource2
			long regionResourceLevel = environment.getRegionResourceLevel(TestRegionId.REGION_1,
					TestResourceId.RESOURCE2);
			environment.addResourceToRegion(TestResourceId.RESOURCE2, TestRegionId.REGION_1,
					Long.MAX_VALUE - regionResourceLevel);
			// now add a bit more
			assertModelException(
					() -> environment.addResourceToRegion(TestResourceId.RESOURCE2, TestRegionId.REGION_1, 10),
					SimulationErrorType.RESOURCE_ARITHMETIC_EXCEPTION);

		});

		/*
		 * Precondition : Show that a non-global component cannot add resources to
		 * region
		 */
		taskPlanContainer.addTaskPlan(TestCompartmentId.COMPARTMENT_1, testTime++, (environment) -> {
			// if the invoker is not a global component or the region
			assertModelException(
					() -> environment.addResourceToRegion(TestResourceId.RESOURCE1, TestRegionId.REGION_1, 1),
					SimulationErrorType.COMPONENT_LACKS_PERMISSION);
		});

		/*
		 * Precondition : Show that a region cannot add resource to another region
		 */
		taskPlanContainer.addTaskPlan(TestRegionId.REGION_2, testTime++, (environment) -> {
			// if the invoker is not a global component or the region
			assertModelException(
					() -> environment.addResourceToRegion(TestResourceId.RESOURCE1, TestRegionId.REGION_1, 1),
					SimulationErrorType.COMPONENT_LACKS_PERMISSION);
		});

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			// if the invoker is not a global component or the region
			assertModelException(
					() -> environment.addResourceToRegion(TestResourceId.RESOURCE1, TestRegionId.REGION_1, 1),
					SimulationErrorType.COMPONENT_LACKS_PERMISSION);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests {@link EnvironmentImpl#batchExists(BatchId)}
	 */
	@Test
	@UnitTestMethod(name = "batchExists", args = { BatchId.class })
	public void testBatchExists() {
		/*
		 * Show that batches exist as expected before construction, after construction
		 * and after destruction
		 */

		final long seed = SEED_PROVIDER.getSeedValue(7);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {

			final BatchId batchId1 = environment.createBatch(TestMaterialId.MATERIAL_1, 1);
			final BatchId batchId2 = environment.createBatch(TestMaterialId.MATERIAL_2, 2);
			assertTrue(environment.batchExists(batchId1));
			assertTrue(environment.batchExists(batchId2));
			environment.destroyBatch(batchId1);
			assertFalse(environment.batchExists(batchId1));
			assertTrue(environment.batchExists(batchId2));
			environment.destroyBatch(batchId2);
			assertFalse(environment.batchExists(batchId1));
			assertFalse(environment.batchExists(batchId2));

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Test {@link EnvironmentImpl#init(Context)}
	 */
	@Test
	@UnitTestMethod(name = "init", args = { Context.class })
	public void testInit() {
		// implicitly tested by every EnvironmentImpl test
	}

	/**
	 * Test {@link EnvironmentImpl#EnvironmentImpl()}
	 */
	@Test
	@UnitTestConstructor(args = {})
	public void testConstructor() {
		// implicitly tested by every EnvironmentImpl test
	}

	/**
	 * Tests {@link EnvironmentImpl#addPerson(PersonConstructionInfo)
	 */
	@Test
	@UnitTestMethod(name = "addPerson", args = { PersonConstructionInfo.class })
	public void testAddPerson_PersonConstructionInfo() {

		
		final long seed = SEED_PROVIDER.getSeedValue(8);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		/*
		 * This first test plan just checks that people are added sequentially and are
		 * located where we expect them to be
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			/*
			 * Determine the person id we expect will be returned by the environment upon
			 * the next addPerson() invocation.
			 */
			Integer expectedPersonIdValue = environment.getPopulationCount();
			PersonConstructionInfo.Builder builder = PersonConstructionInfo.builder();//
			for (final TestRegionId testRegionId : TestRegionId.values()) {
				for (final TestCompartmentId testCompartmentId : TestCompartmentId.values()) {
					builder.setPersonCompartmentId(testCompartmentId).setPersonRegionId(testRegionId);

					Map<PersonPropertyId, Object> expectedPropertyValues = new LinkedHashMap<>();
					for (TestPersonPropertyId testPersonPropertyId : TestPersonPropertyId.values()) {
						PropertyDefinition propertyDefinition = environment
								.getPersonPropertyDefinition(testPersonPropertyId);
						Object propertyValue = EnvironmentSupport.generatePropertyValue(propertyDefinition,
								randomGenerator);
						builder.setPersonPropertyValue(testPersonPropertyId, propertyValue);
						expectedPropertyValues.put(testPersonPropertyId, propertyValue);
					}

					Map<ResourceId, Long> expectedResourceValues = new LinkedHashMap<>();
					for (TestResourceId testResourceId : TestResourceId.values()) {
						long resourceValue = randomGenerator.nextInt(50) + 1;
						builder.setPersonResourceValue(testResourceId, resourceValue);
						expectedResourceValues.put(testResourceId, resourceValue);
					}

					final PersonId personId = environment.addPerson(builder.build());
					/*
					 * Assert that the environment is assigning the person id as we expect
					 */
					PersonId expectedPersonId = new PersonId(expectedPersonIdValue++);
					assertEquals(expectedPersonId, personId);

					/*
					 * Assert that the new person is located where we expect them
					 */
					assertEquals(testRegionId, environment.getPersonRegion(personId));
					assertEquals(testCompartmentId, environment.getPersonCompartment(personId));

					/*
					 * Assert that the new person has the expected property values
					 */
					for (TestPersonPropertyId testPersonPropertyId : TestPersonPropertyId.values()) {
						Object expectedPropertyValue = expectedPropertyValues.get(testPersonPropertyId);
						Object actualPropertyValue = environment.getPersonPropertyValue(personId, testPersonPropertyId);
						assertEquals(expectedPropertyValue, actualPropertyValue);
					}
					
					/*
					 * Assert that the new person has the expected resource levels
					 */
					for (TestResourceId testResourceId : TestResourceId.values()) {
						Long expectedResourceValue = expectedResourceValues.get(testResourceId);
						long actualResourceValue = environment.getPersonResourceLevel(personId, testResourceId);
						assertEquals(expectedResourceValue,actualResourceValue);
					}

				}
			}

		});

		/*
		 * Now we test preconditions
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_2, testTime++, (environment) -> {

			PersonConstructionInfo.Builder builder = PersonConstructionInfo.builder();//

			// if the region id is unknown
			builder.setPersonRegionId(TestRegionId.getUnknownRegionId())//
					.setPersonCompartmentId(TestCompartmentId.COMPARTMENT_1);//
			assertModelException(() -> environment.addPerson(builder.build()), SimulationErrorType.UNKNOWN_REGION_ID);

			// if the compartment id is unknown
			builder.setPersonRegionId(TestRegionId.REGION_1)//
					.setPersonCompartmentId(TestCompartmentId.getUnknownCompartmentId());//
			assertModelException(() -> environment.addPerson(builder.build()),
					SimulationErrorType.UNKNOWN_COMPARTMENT_ID);

			// if the property id is unknown
			builder.setPersonRegionId(TestRegionId.REGION_1)//
					.setPersonCompartmentId(TestCompartmentId.COMPARTMENT_1)
					.setPersonPropertyValue(TestPersonPropertyId.getUnknownPersonPropertyId(), 0);
			assertModelException(() -> environment.addPerson(builder.build()),
					SimulationErrorType.UNKNOWN_PERSON_PROPERTY_ID);

			// if the value is incompatible with the defined type for the property
			PropertyDefinition propertyDefinition = environment
					.getPersonPropertyDefinition(TestPersonPropertyId.PERSON_PROPERTY_1);
			Object incompatiblePropertyValue = EnvironmentSupport.generateIncompatiblePropertyValue(propertyDefinition,
					randomGenerator);
			builder.setPersonRegionId(TestRegionId.REGION_1)//
					.setPersonCompartmentId(TestCompartmentId.COMPARTMENT_1)
					.setPersonPropertyValue(TestPersonPropertyId.PERSON_PROPERTY_1, incompatiblePropertyValue);
			assertModelException(() -> environment.addPerson(builder.build()), SimulationErrorType.INCOMPATIBLE_VALUE);

			// if the resource id is unknown
			builder.setPersonRegionId(TestRegionId.REGION_1)//
					.setPersonCompartmentId(TestCompartmentId.COMPARTMENT_1)
					.setPersonResourceValue(TestResourceId.getUnknownResourceId(), 10L);
			assertModelException(() -> environment.addPerson(builder.build()), SimulationErrorType.UNKNOWN_RESOURCE_ID);

		});

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			PersonConstructionInfo personConstructionInfo = PersonConstructionInfo.builder()
					.setPersonRegionId(TestRegionId.REGION_1).setPersonCompartmentId(TestCompartmentId.COMPARTMENT_1)
					.build();
			assertModelException(() -> environment.addPerson(personConstructionInfo),
					SimulationErrorType.COMPONENT_LACKS_PERMISSION);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

}
