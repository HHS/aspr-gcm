package gcm.automated;

import static gcm.automated.support.EnvironmentSupport.addStandardComponentsAndTypes;
import static gcm.automated.support.EnvironmentSupport.addStandardPeople;
import static gcm.automated.support.EnvironmentSupport.addStandardPropertyDefinitions;
import static gcm.automated.support.EnvironmentSupport.addStandardTrackingAndScenarioId;
import static gcm.automated.support.EnvironmentSupport.addTaskPlanContainer;
import static gcm.automated.support.EnvironmentSupport.assertAllPlansExecuted;
import static gcm.automated.support.EnvironmentSupport.generatePropertyValue;
import static gcm.automated.support.EnvironmentSupport.getRandomGenerator;
import static gcm.automated.support.EnvironmentSupport.getReplication;
import static gcm.automated.support.ExceptionAssertion.assertModelException;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.util.Collections;
import java.util.EnumSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Random;
import java.util.Set;

import org.apache.commons.math3.random.RandomGenerator;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import gcm.automated.support.EnvironmentSupport;
import gcm.automated.support.EnvironmentSupport.PropertyAssignmentPolicy;
import gcm.automated.support.SeedProvider;
import gcm.automated.support.TaskPlanContainer;
import gcm.automated.support.TestCompartmentId;
import gcm.automated.support.TestGlobalComponentId;
import gcm.automated.support.TestGroupTypeId;
import gcm.automated.support.TestMaterialId;
import gcm.automated.support.TestMaterialsProducerId;
import gcm.automated.support.TestRegionId;
import gcm.replication.Replication;
import gcm.scenario.BatchId;
import gcm.scenario.BatchPropertyId;
import gcm.scenario.CompartmentId;
import gcm.scenario.CompartmentPropertyId;
import gcm.scenario.GroupId;
import gcm.scenario.MaterialId;
import gcm.scenario.PersonId;
import gcm.scenario.PropertyDefinition;
import gcm.scenario.Scenario;
import gcm.scenario.ScenarioBuilder;
import gcm.scenario.StageId;
import gcm.scenario.UnstructuredScenarioBuilder;
import gcm.simulation.EnvironmentImpl;
import gcm.simulation.Simulation;
import gcm.simulation.SimulationErrorType;
import gcm.util.annotations.UnitTest;

@UnitTest(target = EnvironmentImpl.class)

public class AT_EnvironmentImpl_03 {

	private static SeedProvider SEED_PROVIDER;

	@BeforeClass
	public static void beforeClass() {
		SEED_PROVIDER = new SeedProvider(EnvironmentSupport.getMetaSeed(3));
	}

	/**
	 * Internal test(not part of public tests) to show that there are no large
	 * gaps in the seed cases generated by the SeedProvider.
	 */
	@AfterClass
	public static void afterClass() {
		//System.out.println(SEED_PROVIDER.generateUnusedSeedReport());
	}

	/*
	 * Utility class for getting random people from population indices
	 */
	private static class Counter {
		int count;
	}

	/**
	 * Tests {@link EnvironmentImpl#getBatchPropertyTime(BatchId, BatchPropertyId)}
	 */
	@Test
	public void testGetBatchPropertyTime() {
		/*
		 * For each batch property first show that the property time is zero.
		 * Next change each property so that the new property times will be the
		 * current time and test that this is so. Finally, move forward in time
		 * and show that the property value times still reflect the time when we
		 * set them and not the current time.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(0);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {

			for (final MaterialId materialId : environment.getMaterialIds()) {
				final BatchId batchId = environment.createBatch(materialId, 30);
				for (final BatchPropertyId batchPropertyId : environment.getBatchPropertyIds(materialId)) {
					final double expectedPropertyTime = 1;
					final double actualPropertyTime = environment.getBatchPropertyTime(batchId, batchPropertyId);
					assertEquals(expectedPropertyTime, actualPropertyTime, 0);
				}
			}

		});

		/*
		 * Change each property value and show that the time values are the
		 * current time
		 */
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {

			final List<BatchId> batches = environment.getInventoryBatches(TestMaterialsProducerId.MATERIALS_PRODUCER_1);
			for (final BatchId batchId : batches) {
				final MaterialId materialId = environment.getBatchMaterial(batchId);
				for (final BatchPropertyId batchPropertyId : environment.getBatchPropertyIds(materialId)) {
					final PropertyDefinition propertyDefinition = environment.getBatchPropertyDefinition(materialId, batchPropertyId);
					final Object actualPropertyValue = environment.getBatchPropertyValue(batchId, batchPropertyId);
					Object updatedPropertyValue = null;
					while ((updatedPropertyValue == null) || updatedPropertyValue.equals(actualPropertyValue)) {
						updatedPropertyValue = generatePropertyValue(propertyDefinition, environment.getRandomGenerator());
					}
					environment.setBatchPropertyValue(batchId, batchPropertyId, updatedPropertyValue);
					final double expectedPropertyTime = 2.0;
					final double actualPropertyTime = environment.getBatchPropertyTime(batchId, batchPropertyId);
					assertEquals(expectedPropertyTime, actualPropertyTime, 0);
				}
			}

		});

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			/*
			 * Time has moved forward and we show that the property value times
			 * still reflect when they were set
			 */

			final List<BatchId> batches = environment.getInventoryBatches(TestMaterialsProducerId.MATERIALS_PRODUCER_1);
			for (final BatchId batchId : batches) {
				final MaterialId materialId = environment.getBatchMaterial(batchId);
				for (final BatchPropertyId batchPropertyId : environment.getBatchPropertyIds(materialId)) {
					final double expectedPropertyTime = 2.0;
					final double actualPropertyTime = environment.getBatchPropertyTime(batchId, batchPropertyId);
					assertEquals(expectedPropertyTime, actualPropertyTime, 0);
				}
			}

		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {

			final BatchId batchId = environment.createBatch(TestMaterialId.MATERIAL_1, 23.6);
			final BatchPropertyId batchPropertyId = TestMaterialId.MATERIAL_1.getBatchPropertyIds()[0];

			// if the batch id is null
			assertModelException(() -> environment.getBatchPropertyTime(null, batchPropertyId), SimulationErrorType.NULL_BATCH_ID);
			// if the batch is unknown
			assertModelException(() -> environment.getBatchPropertyTime(new BatchId(-1), batchPropertyId), SimulationErrorType.UNKNOWN_BATCH_ID);
			// if the property id is null
			assertModelException(() -> environment.getBatchPropertyTime(batchId, null), SimulationErrorType.NULL_BATCH_PROPERTY_ID);
			// if the property is unknown
			assertModelException(() -> environment.getBatchPropertyTime(batchId, TestMaterialId.getUnknownBatchPropertyId()), SimulationErrorType.UNKNOWN_BATCH_PROPERTY_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests {@link EnvironmentImpl#getBatchPropertyValue(BatchId, BatchPropertyId)}
	 */
	@Test
	public void testGetBatchPropertyValue() {
		/*
		 * For each material and material property definition, show that the
		 * current value is the default value we expect from the property
		 * definition. Then show that after we change the value that we can
		 * retrieve the new value just so we know that we are not observing an
		 * artifact of the original default value.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(1);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {

			for (final MaterialId materialId : environment.getMaterialIds()) {
				final BatchId batchId = environment.createBatch(materialId, 30);
				for (final BatchPropertyId batchPropertyId : environment.getBatchPropertyIds(materialId)) {
					/*
					 * We first assert that the current value of the property is
					 * the default for the definition.
					 */

					final PropertyDefinition propertyDefinition = environment.getBatchPropertyDefinition(materialId, batchPropertyId);
					assertTrue(propertyDefinition.getDefaultValue().isPresent());
					final Object expectedPropertyValue = propertyDefinition.getDefaultValue().get();
					final Object actualPropertyValue = environment.getBatchPropertyValue(batchId, batchPropertyId);
					assertEquals(expectedPropertyValue, actualPropertyValue);

					/*
					 * To be more thorough, we also assert that we can retrieve
					 * any arbitrary value since we know that default values are
					 * potentially handled as a special case.
					 */
					Object updatedPropertyValue = null;
					while ((updatedPropertyValue == null) || updatedPropertyValue.equals(actualPropertyValue)) {
						updatedPropertyValue = generatePropertyValue(propertyDefinition, environment.getRandomGenerator());
					}
					environment.setBatchPropertyValue(batchId, batchPropertyId, updatedPropertyValue);
					final Object retrievedPropertyValue = environment.getBatchPropertyValue(batchId, batchPropertyId);
					assertEquals(updatedPropertyValue, retrievedPropertyValue);
				}
			}

		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {

			final BatchId batchId = environment.createBatch(TestMaterialId.MATERIAL_1, 45);
			final BatchPropertyId batchPropertyId = TestMaterialId.MATERIAL_1.getBatchPropertyIds()[0];

			// if the batch id is null
			assertModelException(() -> environment.getBatchPropertyValue(null, batchPropertyId), SimulationErrorType.NULL_BATCH_ID);
			// if the batch is unknown
			assertModelException(() -> environment.getBatchPropertyValue(new BatchId(-1), batchPropertyId), SimulationErrorType.UNKNOWN_BATCH_ID);
			// if the property id is null
			assertModelException(() -> environment.getBatchPropertyValue(batchId, null), SimulationErrorType.NULL_BATCH_PROPERTY_ID);
			// if the property is unknown
			assertModelException(() -> environment.getBatchPropertyValue(batchId, TestMaterialId.getUnknownBatchPropertyId()), SimulationErrorType.UNKNOWN_BATCH_PROPERTY_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests {@link EnvironmentImpl#getBatchStageId(BatchId)}
	 */
	@Test
	public void testGetBatchStageId() {
		/*
		 * Show that batches have the stages that they have been assigned.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(2);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			final BatchId batchId = environment.createBatch(TestMaterialId.MATERIAL_1, 20);
			assertFalse(environment.getBatchStageId(batchId).isPresent());
			final StageId stageId = environment.createStage();
			environment.moveBatchToStage(batchId, stageId);
			assertTrue(environment.getBatchStageId(batchId).isPresent());
			assertEquals(stageId, environment.getBatchStageId(batchId).get());
			environment.moveBatchToInventory(batchId);
			assertFalse(environment.getBatchStageId(batchId).isPresent());
		});

		// precondition tests
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			// if the batchId id is null
			assertModelException(() -> environment.getBatchStageId(null), SimulationErrorType.NULL_BATCH_ID);
			// if the batchId id is unknown
			assertModelException(() -> environment.getBatchStageId(new BatchId(-1)), SimulationErrorType.UNKNOWN_BATCH_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getBatchTime(BatchId)}
	 */
	@Test
	public void testGetBatchTime() {
		/*
		 * Show that batches have time values equal to their creation time, over
		 * time.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(3);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			environment.createBatch(TestMaterialId.MATERIAL_1, 1);
		});

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_2, testTime++, (environment) -> {
			environment.createBatch(TestMaterialId.MATERIAL_2, 1);
		});

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_3, testTime++, (environment) -> {
			environment.createBatch(TestMaterialId.MATERIAL_3, 1);
		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			for (int i = 0; i < 3; i++) {
				BatchId batchId = new BatchId(i);
				assertEquals(i + 1, environment.getBatchTime(batchId), 0);
			}
		});

		// precondition tests
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			// if the batchId id is null
			assertModelException(() -> environment.getBatchTime(null), SimulationErrorType.NULL_BATCH_ID);
			// if the batchId id is unknown
			assertModelException(() -> environment.getBatchTime(new BatchId(-1)), SimulationErrorType.UNKNOWN_BATCH_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests
	 * {@link EnvironmentImpl#getBiWeightedGroupContact(GroupId, PersonId, boolean, gcm.simulation.BiWeightingFunction)}
	 */
	@Test
	public void testGetBiWeightedGroupContact() {

		/*
		 * Assert that group contacts via BiWeightingFunctions work properly
		 */

		final long seed = SEED_PROVIDER.getSeedValue(4);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			/*
			 * Add a group
			 */
			final GroupId groupId = environment.addGroup(TestGroupTypeId.GROUP_TYPE_1);

			final int groupSize = 20;

			/*
			 * Add the first 20 people to the group
			 */
			for (int personIndex = 0; personIndex < groupSize; personIndex++) {
				environment.addPersonToGroup(new PersonId(personIndex), groupId);
			}

			/*
			 * Force the random selection of a person from the group to person 3
			 */
			Optional<PersonId> opt = environment.getBiWeightedGroupContact(groupId, new PersonId(0), false, EnvironmentSupport::getPerson3BiWeight);
			assertTrue(opt.isPresent());
			assertEquals(3, opt.get().getValue());

			// use a uniform distribution with 10000 repetitions
			final Map<Integer, Counter> hits = new LinkedHashMap<>();
			for (int personId = 0; personId < groupSize; personId++) {
				hits.put(personId, new Counter());
			}

			/*
			 * using exclusion, select 10000 times from the group and show that
			 * person 0 is never selected and that all other people get selected
			 * a reasonable number of times
			 */
			for (int i = 0; i < 10000; i++) {
				opt = environment.getBiWeightedGroupContact(groupId, new PersonId(0), true, EnvironmentSupport::getConstantBiWeight);
				assertTrue(opt.isPresent());
				hits.get(opt.get().getValue()).count++;
			}
			// show that each person was selected about 500 times
			for (final Integer personId : hits.keySet()) {
				final Counter counter = hits.get(personId);
				if (personId.equals(0)) {
					assertEquals(counter.count, 0);
				} else {
					assertTrue(counter.count > 400);
					assertTrue(counter.count < 600);
				}
			}
			/*
			 * using inclusion, select 10000 times from the group and show that
			 * all people get selected a reasonable number of times
			 */
			for (final Counter counter : hits.values()) {
				counter.count = 0;
			}
			for (int i = 0; i < 10000; i++) {
				opt = environment.getBiWeightedGroupContact(groupId, new PersonId(0), false, EnvironmentSupport::getConstantBiWeight);
				assertTrue(opt.isPresent());
				hits.get(opt.get().getValue()).count++;
			}
			// show that each person was selected about 500 times
			for (final Integer personId : hits.keySet()) {
				final Counter counter = hits.get(personId);
				assertTrue(counter.count > 400);
				assertTrue(counter.count < 600);
			}
		});

		// show that a weighting function that returns all zeros will result in
		// an optional where no value is present
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			final GroupId groupId = environment.addGroup(TestGroupTypeId.GROUP_TYPE_1);

			final int groupSize = 20;

			/*
			 * Add the first 20 people to the group
			 */
			for (int personIndex = 0; personIndex < groupSize; personIndex++) {
				environment.addPersonToGroup(new PersonId(personIndex), groupId);
			}
			Optional<PersonId> opt = environment.getBiWeightedGroupContact(groupId, new PersonId(0), false, EnvironmentSupport::getZeroBiWeight);
			assertTrue(!opt.isPresent());
		});

		// test preconditions
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// if the group id is null
			assertModelException(() -> environment.getBiWeightedGroupContact(null, new PersonId(0), true, EnvironmentSupport::getConstantBiWeight), SimulationErrorType.NULL_GROUP_ID);
			// if the group id is unknown(group does not exist) *
			assertModelException(() -> environment.getBiWeightedGroupContact(new GroupId(-1), new PersonId(0), true, EnvironmentSupport::getConstantBiWeight), SimulationErrorType.UNKNOWN_GROUP_ID);
			// if the source person id is null
			assertModelException(() -> environment.getBiWeightedGroupContact(new GroupId(0), null, true, EnvironmentSupport::getConstantBiWeight), SimulationErrorType.NULL_PERSON_ID);
			// if the source person id is unknown
			assertModelException(() -> environment.getBiWeightedGroupContact(new GroupId(0), new PersonId(-1), true, EnvironmentSupport::getConstantBiWeight), SimulationErrorType.UNKNOWN_PERSON_ID);
			// if the biWeightingFunction is null
			assertModelException(() -> environment.getBiWeightedGroupContact(new GroupId(0), new PersonId(0), true, null), SimulationErrorType.NULL_WEIGHTING_FUNCTION);
			// if the biWeightingFunction is malformed. (some evaluate to
			// negative numbers, etc.)
			assertModelException(() -> environment.getBiWeightedGroupContact(new GroupId(0), new PersonId(0), true, EnvironmentSupport::getNegativeBiWeight),
					SimulationErrorType.MALFORMED_WEIGHTING_FUNCTION);
		});
		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getNonWeightedGroupContact(GroupId)}
	 */
	@Test
	public void testGetNonWeightedGroupContact() {

		/*
		 * Show that we can retrieve people randomly from a group.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(5);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			/*
			 * put some people in a group
			 */
			int groupSize = environment.getPopulationCount() / 2;

			/*
			 * show that there will enough people in the group. This will also
			 * demonstrate that there are people who will not be in the group
			 */
			assertTrue(groupSize > 10);

			/*
			 * Create the group and fill it with random people
			 */
			GroupId groupId = environment.addGroup(TestGroupTypeId.GROUP_TYPE_1);
			List<PersonId> people = environment.getPeople();
			Collections.shuffle(people, new Random(environment.getRandomGenerator().nextLong()));
			for (int i = 0; i < groupSize; i++) {
				PersonId personId = people.get(i);
				environment.addPersonToGroup(personId, groupId);
			}

			/*
			 * Sample random people from the group and count how often each
			 * person is selected. Show that the returned people are members of
			 * the group.
			 */
			final Map<PersonId, Counter> counterMap = new LinkedHashMap<>();
			int sampleCount = groupSize * 100;
			for (int i = 0; i < sampleCount; i++) {
				Optional<PersonId> nonWeightedGroupContact = environment.getNonWeightedGroupContact(groupId);
				assertTrue(nonWeightedGroupContact.isPresent());
				PersonId selectedPersonId = nonWeightedGroupContact.get();
				assertTrue(environment.isGroupMember(selectedPersonId, groupId));
				Counter counter = counterMap.get(selectedPersonId);
				if (counter == null) {
					counter = new Counter();
					counterMap.put(selectedPersonId, counter);
				}
				counter.count++;
			}

			// Show that each person is selected a reasonable number of
			// times.

			List<PersonId> peopleInGroup = environment.getPeopleForGroup(groupId);
			assertEquals(groupSize, peopleInGroup.size());
			for (final PersonId personId : peopleInGroup) {
				final Counter counter = counterMap.get(personId);
				assertNotNull(counter);
				assertTrue(counter.count > 50);
				assertTrue(counter.count < 150);
			}

		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			/*
			 * Create a group with no people
			 */
			GroupId groupId = environment.addGroup(TestGroupTypeId.GROUP_TYPE_1);

			// Show that an empty group returns no people
			int sampleCount = 10;
			for (int i = 0; i < sampleCount; i++) {
				Optional<PersonId> nonWeightedGroupContact = environment.getNonWeightedGroupContact(groupId);
				assertFalse(nonWeightedGroupContact.isPresent());

			}

		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// if the group id is null
			assertModelException(() -> environment.getNonWeightedGroupContact(null), SimulationErrorType.NULL_GROUP_ID);
			// if the group id is unknown
			assertModelException(() -> environment.getNonWeightedGroupContact(new GroupId(-5)), SimulationErrorType.UNKNOWN_GROUP_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests
	 * {@link EnvironmentImpl#getNonWeightedGroupContactWithExclusion(GroupId, PersonId)}
	 */
	@Test
	public void testGetNonWeightedGroupContactWithExclusion() {

		/*
		 * Show that we can retrieve people randomly from a group.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(6);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			/*
			 * put some people in a group
			 */
			int groupSize = environment.getPopulationCount() / 2;

			/*
			 * show that there will enough people in the group. This will also
			 * demonstrate that there are people who will not be in the group
			 */
			assertTrue(groupSize > 10);

			/*
			 * Create the group and fill it with random people
			 */
			GroupId groupId = environment.addGroup(TestGroupTypeId.GROUP_TYPE_1);
			List<PersonId> people = environment.getPeople();
			Collections.shuffle(people, new Random(environment.getRandomGenerator().nextLong()));
			for (int i = 0; i < groupSize; i++) {
				PersonId personId = people.get(i);
				environment.addPersonToGroup(personId, groupId);
			}

			/*
			 * Sample random people from the group and count how often each
			 * person is selected. Show that the returned people are members of
			 * the group.
			 */
			final Map<PersonId, Counter> counterMap = new LinkedHashMap<>();
			int sampleCount = groupSize * 100;
			// pick a random person from the group to exclude
			Optional<PersonId> nonWeightedGroupContact = environment.getNonWeightedGroupContact(groupId);
			assertTrue(nonWeightedGroupContact.isPresent());
			PersonId excludedPersonId = nonWeightedGroupContact.get();

			for (int i = 0; i < sampleCount; i++) {
				nonWeightedGroupContact = environment.getNonWeightedGroupContactWithExclusion(groupId, excludedPersonId);
				assertTrue(nonWeightedGroupContact.isPresent());
				PersonId selectedPersonId = nonWeightedGroupContact.get();
				assertTrue(environment.isGroupMember(selectedPersonId, groupId));
				Counter counter = counterMap.get(selectedPersonId);
				if (counter == null) {
					counter = new Counter();
					counterMap.put(selectedPersonId, counter);
				}
				counter.count++;
			}
			// Show that each person is selected a reasonable number of
			// times other than the excluded person, who should never be
			// selected.
			List<PersonId> peopleInGroup = environment.getPeopleForGroup(groupId);
			assertEquals(groupSize, peopleInGroup.size());
			for (final PersonId personId : peopleInGroup) {
				if (!personId.equals(excludedPersonId)) {
					final Counter counter = counterMap.get(personId);
					assertNotNull(counter);
					assertTrue(counter.count > 50);
					assertTrue(counter.count < 150);
				}
			}
			assertFalse(counterMap.containsKey(excludedPersonId));

			// pick a random person from outside group to exclude
			counterMap.clear();
			excludedPersonId = null;
			for (PersonId personId : environment.getPeople()) {
				if (!environment.isGroupMember(personId, groupId)) {
					excludedPersonId = personId;
				}
			}
			assertNotNull(excludedPersonId);

			for (int i = 0; i < sampleCount; i++) {
				nonWeightedGroupContact = environment.getNonWeightedGroupContactWithExclusion(groupId, excludedPersonId);
				assertTrue(nonWeightedGroupContact.isPresent());
				PersonId selectedPersonId = nonWeightedGroupContact.get();
				assertTrue(environment.isGroupMember(selectedPersonId, groupId));
				Counter counter = counterMap.get(selectedPersonId);
				if (counter == null) {
					counter = new Counter();
					counterMap.put(selectedPersonId, counter);
				}
				counter.count++;
			}
			// Show that each person is selected a reasonable number of
			// times.

			for (final PersonId personId : peopleInGroup) {
				final Counter counter = counterMap.get(personId);
				assertNotNull(counter);
				assertTrue(counter.count > 50);
				assertTrue(counter.count < 150);
			}
			assertFalse(counterMap.containsKey(excludedPersonId));

		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			PersonId excludedPersonId = new PersonId(0);
			/*
			 * Create a group with no people
			 */
			GroupId groupId = environment.addGroup(TestGroupTypeId.GROUP_TYPE_1);

			// Show that an empty group returns no people
			int sampleCount = 10;
			for (int i = 0; i < sampleCount; i++) {
				Optional<PersonId> nonWeightedGroupContact = environment.getNonWeightedGroupContactWithExclusion(groupId,excludedPersonId);
				assertFalse(nonWeightedGroupContact.isPresent());

			}

		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			PersonId excludedPersonId = environment.getPeople().get(0);
			GroupId groupId = environment.getGroupIds().get(0);

			// if the group id is null
			assertModelException(() -> environment.getNonWeightedGroupContactWithExclusion(null, excludedPersonId), SimulationErrorType.NULL_GROUP_ID);
			// if the group id is unknown
			assertModelException(() -> environment.getNonWeightedGroupContactWithExclusion(new GroupId(-5), excludedPersonId), SimulationErrorType.UNKNOWN_GROUP_ID);
			// if the person id is null
			assertModelException(() -> environment.getNonWeightedGroupContactWithExclusion(groupId, null), SimulationErrorType.NULL_PERSON_ID);
			// if the person id is unknown
			assertModelException(() -> environment.getNonWeightedGroupContactWithExclusion(groupId, new PersonId(-1)), SimulationErrorType.UNKNOWN_PERSON_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests {@link EnvironmentImpl#getCompartmentIds()}
	 */
	@Test
	public void testGetCompartmentIds() {
		/*
		 * Assert that the compartment identifiers from the environment are the
		 * same as the elements of the local CompartmentId enumeration.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(7);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			final Set<TestCompartmentId> expectedCompartmentIds = EnumSet.allOf(TestCompartmentId.class);
			assertEquals(expectedCompartmentIds, environment.getCompartmentIds());
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getCompartmentPopulationCount(CompartmentId)}
	 */
	@Test
	public void testGetCompartmentPopulationCount() {
		/*
		 * Assert that each compartment has the number of people in it expected
		 * from the initialization of the simulation. Then assert the count of
		 * the compartment population as we add a few people just to make sure
		 * that the original agreement was not an artifact of initialization.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(8);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			for (final TestCompartmentId testCompartmentId : TestCompartmentId.values()) {
				int expectedCompartmentPopulationCount = 0;
				for (final PersonId personId : scenario.getPeopleIds()) {
					if (scenario.getPersonCompartment(personId).equals(testCompartmentId)) {
						expectedCompartmentPopulationCount++;
					}
				}
				assertEquals(expectedCompartmentPopulationCount, environment.getCompartmentPopulationCount(testCompartmentId));

				for (final TestRegionId testRegionId : TestRegionId.values()) {
					environment.addPerson(testRegionId, testCompartmentId);
					expectedCompartmentPopulationCount++;
					assertEquals(expectedCompartmentPopulationCount, environment.getCompartmentPopulationCount(testCompartmentId));
				}
			}
		});

		/*
		 * Preconditions test
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the compartment id is null
			assertModelException(() -> environment.getCompartmentPopulationCount(null), SimulationErrorType.NULL_COMPARTMENT_ID);
			// if the compartment is unknown
			assertModelException(() -> environment.getCompartmentPopulationCount(TestCompartmentId.getUnknownCompartmentId()), SimulationErrorType.UNKNOWN_COMPARTMENT_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();
	}

	/**
	 * Tests
	 * {@link EnvironmentImpl#getCompartmentPopulationCountTime(CompartmentId)}
	 */
	@Test
	public void testGetCompartmentPopulationCountTime() {
		/*
		 * Create three test plans such that we show that the initial people
		 * were added at time zero and that if we add new people at time 2, we
		 * can verify that the new population time is 2 at both time 2 and
		 * later.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(9);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			for (final TestCompartmentId testCompartmentId : TestCompartmentId.values()) {
				assertEquals(0, environment.getCompartmentPopulationCountTime(testCompartmentId), 0);
			}
		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			for (final TestCompartmentId testCompartmentId : TestCompartmentId.values()) {
				environment.addPerson(TestRegionId.REGION_1, testCompartmentId);
				assertEquals(2.0, environment.getCompartmentPopulationCountTime(testCompartmentId), 0);
			}
		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			for (final TestCompartmentId testCompartmentId : TestCompartmentId.values()) {
				assertEquals(2.0, environment.getCompartmentPopulationCountTime(testCompartmentId), 0);
			}
		});

		/*
		 * Preconditions test
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// if the compartment id is null
			assertModelException(() -> environment.getCompartmentPopulationCountTime(null), SimulationErrorType.NULL_COMPARTMENT_ID);
			// if the compartment is unknown
			assertModelException(() -> environment.getCompartmentPopulationCountTime(TestCompartmentId.getUnknownCompartmentId()), SimulationErrorType.UNKNOWN_COMPARTMENT_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests
	 * {@link EnvironmentImpl#getCompartmentPropertyDefinition(gcm.scenario.CompartmentPropertyId)}
	 */
	@Test
	public void testGetCompartmentPropertyDefinition() {
		/*
		 * Retrieve each compartment property definition and assert that it
		 * equals the one held in the test plan executor.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(10);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		for (final TestCompartmentId testCompartmentId : TestCompartmentId.values()) {
			for (CompartmentPropertyId compartmentPropertyId : testCompartmentId.getCompartmentPropertyIds()) {
				taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
					final PropertyDefinition expectedPropertyDefinition = scenario.getCompartmentPropertyDefinition(testCompartmentId, compartmentPropertyId);
					final PropertyDefinition actualPropertyDefinition = environment.getCompartmentPropertyDefinition(testCompartmentId, compartmentPropertyId);
					assertEquals(expectedPropertyDefinition, actualPropertyDefinition);
				});
			}
		}
		/*
		 * Precondition Tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			CompartmentId compartmentId = TestCompartmentId.COMPARTMENT_1;
			CompartmentPropertyId compartmentPropertyId = TestCompartmentId.COMPARTMENT_1.getCompartmentPropertyIds()[0];

			// if the compartment id is null
			assertModelException(() -> environment.getCompartmentPropertyDefinition(null, compartmentPropertyId), SimulationErrorType.NULL_COMPARTMENT_ID);

			// if the compartment id is unknown
			assertModelException(() -> environment.getCompartmentPropertyDefinition(TestCompartmentId.getUnknownCompartmentId(), compartmentPropertyId), SimulationErrorType.UNKNOWN_COMPARTMENT_ID);

			// if the property id is null
			assertModelException(() -> environment.getCompartmentPropertyDefinition(compartmentId, null), SimulationErrorType.NULL_COMPARTMENT_PROPERTY_ID);

			// if the property id does not correspond to a known compartment
			// property identifier
			assertModelException(() -> environment.getCompartmentPropertyDefinition(compartmentId, TestCompartmentId.getUnknownCompartmentPropertyId()),
					SimulationErrorType.UNKNOWN_COMPARTMENT_PROPERTY_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getCompartmentPropertyIds()}
	 */
	@Test
	public void testGetCompartmentPropertyIds() {
		/*
		 * Assert that the compartment property identifiers from the environment
		 * are the same as the elements of the local CompartmentPropertyId
		 * enumeration.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(11);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			Set<CompartmentId> compartmentIds = environment.getCompartmentIds();
			assertTrue(compartmentIds.size() > 0);
			for (TestCompartmentId testCompartmentId : TestCompartmentId.values()) {
				final Set<CompartmentPropertyId> expectedCompartmentPropertyIds = new LinkedHashSet<>();
				for (CompartmentPropertyId compartmentPropertyId : testCompartmentId.getCompartmentPropertyIds()) {
					expectedCompartmentPropertyIds.add(compartmentPropertyId);
				}
				assertEquals(expectedCompartmentPropertyIds, environment.getCompartmentPropertyIds(testCompartmentId));
			}
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

}
