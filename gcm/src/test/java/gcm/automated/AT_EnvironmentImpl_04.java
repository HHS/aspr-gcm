package gcm.test.automated;

import static gcm.test.support.EnvironmentSupport.addObservationContainer;
import static gcm.test.support.EnvironmentSupport.addStandardComponentsAndTypes;
import static gcm.test.support.EnvironmentSupport.addStandardPeople;
import static gcm.test.support.EnvironmentSupport.addStandardPropertyDefinitions;
import static gcm.test.support.EnvironmentSupport.addStandardTrackingAndScenarioId;
import static gcm.test.support.EnvironmentSupport.addTaskPlanContainer;
import static gcm.test.support.EnvironmentSupport.assertAllPlansExecuted;
import static gcm.test.support.EnvironmentSupport.generatePropertyValue;
import static gcm.test.support.EnvironmentSupport.getRandomGenerator;
import static gcm.test.support.EnvironmentSupport.getReplication;
import static gcm.test.support.ExceptionAssertion.assertModelException;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.util.Collections;
import java.util.EnumSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;

import org.apache.commons.math3.random.RandomGenerator;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import gcm.components.Component;
import gcm.experiment.progress.ExperimentProgressLog;
import gcm.output.OutputItem;
import gcm.output.OutputItemHandler;
import gcm.output.reports.ReportHeader;
import gcm.output.reports.ReportItem;
import gcm.output.reports.ReportHeader.ReportHeaderBuilder;
import gcm.output.reports.ReportItem.ReportItemBuilder;
import gcm.output.reports.commonreports.CompartmentPopulationReport;
import gcm.replication.Replication;
import gcm.scenario.CompartmentId;
import gcm.scenario.CompartmentPropertyId;
import gcm.scenario.GlobalPropertyId;
import gcm.scenario.GroupId;
import gcm.scenario.GroupTypeId;
import gcm.scenario.PersonId;
import gcm.scenario.PropertyDefinition;
import gcm.scenario.RegionId;
import gcm.scenario.ReplicationId;
import gcm.scenario.Scenario;
import gcm.scenario.ScenarioBuilder;
import gcm.scenario.ScenarioId;
import gcm.scenario.UnstructuredScenarioBuilder;
import gcm.simulation.Environment;
import gcm.simulation.EnvironmentImpl;
import gcm.simulation.Simulation;
import gcm.simulation.SimulationErrorType;
import gcm.test.support.EnvironmentSupport;
import gcm.test.support.SeedProvider;
import gcm.test.support.TaskComponent;
import gcm.test.support.TaskPlanContainer;
import gcm.test.support.TestCompartmentId;
import gcm.test.support.TestGlobalComponentId;
import gcm.test.support.TestGlobalPropertyId;
import gcm.test.support.TestGroupTypeId;
import gcm.test.support.TestMaterialsProducerId;
import gcm.test.support.TestRegionId;
import gcm.test.support.EnvironmentSupport.PropertyAssignmentPolicy;
import gcm.util.annotations.UnitTest;

@UnitTest(target = EnvironmentImpl.class)

public class AT_EnvironmentImpl_04 {

	private static SeedProvider SEED_PROVIDER;

	@BeforeClass
	public static void beforeClass() {
		SEED_PROVIDER = new SeedProvider(EnvironmentSupport.getMetaSeed(4));
	}

	/**
	 * Internal test(not part of public tests) to show that there are no large
	 * gaps in the seed cases generated by the SeedProvider.
	 */
	@AfterClass
	public static void afterClass() {
		//System.out.println(SEED_PROVIDER.generateUnusedSeedReport());
	}

	/**
	 * Tests
	 * {@link Environment#getCompartmentPropertyTime(CompartmentId, gcm.scenario.CompartmentPropertyId)}
	 */
	@Test
	public void testGetCompartmentPropertyTime() {

		/*
		 * For each global property first show that the property time is zero.
		 * Next change each property so that the new property times will be the
		 * current time and test that this is so. Finally, move forward in time
		 * and show that the property value times still reflect the time when we
		 * set them and not the current time.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(0);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.TRUE, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			for (final TestCompartmentId testCompartmentId : TestCompartmentId.values()) {
				for (final CompartmentPropertyId propertyID : testCompartmentId.getCompartmentPropertyIds()) {
					final double expectedPropertyTime = 0;
					final double actualPropertyTime = environment.getCompartmentPropertyTime(testCompartmentId, propertyID);
					assertEquals(expectedPropertyTime, actualPropertyTime, 0);
				}
			}

		});

		/*
		 * Change each property value and show that the time values are the
		 * current time
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			for (final TestCompartmentId testCompartmentId : TestCompartmentId.values()) {
				for (final CompartmentPropertyId propertyID : testCompartmentId.getCompartmentPropertyIds()) {
					final PropertyDefinition propertyDefinition = environment.getCompartmentPropertyDefinition(testCompartmentId, propertyID);
					final Object actualPropertyValue = environment.getCompartmentPropertyValue(testCompartmentId, propertyID);
					Object updatedPropertyValue = null;
					while ((updatedPropertyValue == null) || updatedPropertyValue.equals(actualPropertyValue)) {
						updatedPropertyValue = generatePropertyValue(propertyDefinition, environment.getRandomGenerator());
					}
					environment.setCompartmentPropertyValue(testCompartmentId, propertyID, updatedPropertyValue);
					final double expectedPropertyTime = 2.0;
					final double actualPropertyTime = environment.getCompartmentPropertyTime(testCompartmentId, propertyID);
					assertEquals(expectedPropertyTime, actualPropertyTime, 0);
				}
			}

		});

		/*
		 * Time has moved forward and we show that the property value times
		 * still reflect when they were set
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			for (final TestCompartmentId testCompartmentId : TestCompartmentId.values()) {
				for (final CompartmentPropertyId propertyID : testCompartmentId.getCompartmentPropertyIds()) {
					final double expectedPropertyTime = 2.0;
					final double actualPropertyTime = environment.getCompartmentPropertyTime(testCompartmentId, propertyID);
					assertEquals(expectedPropertyTime, actualPropertyTime, 0);
				}
			}

		});

		/*
		 * Preconditions test
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			CompartmentId compartmentId = TestCompartmentId.COMPARTMENT_1;
			CompartmentPropertyId compartmentPropertyId = TestCompartmentId.COMPARTMENT_1.getCompartmentPropertyId(0);

			// if the compartment id is null
			assertModelException(() -> environment.getCompartmentPropertyTime(null, compartmentPropertyId), SimulationErrorType.NULL_COMPARTMENT_ID);
			// if the compartment is unknown
			assertModelException(() -> environment.getCompartmentPropertyTime(TestCompartmentId.getUnknownCompartmentId(), compartmentPropertyId), SimulationErrorType.UNKNOWN_COMPARTMENT_ID);
			// if the property id is null
			assertModelException(() -> environment.getCompartmentPropertyTime(compartmentId, null), SimulationErrorType.NULL_COMPARTMENT_PROPERTY_ID);
			// if the property is unknown
			assertModelException(() -> environment.getCompartmentPropertyTime(compartmentId, TestCompartmentId.getUnknownCompartmentPropertyId()), SimulationErrorType.UNKNOWN_COMPARTMENT_PROPERTY_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests
	 * {@link Environment#getCompartmentPropertyValue(CompartmentId, gcm.scenario.CompartmentPropertyId)}
	 */
	@Test
	public void testGetCompartmentPropertyValue() {
		/*
		 * For each compartment and compartment property definition, show that
		 * the current value is the default value we expect from the property
		 * definition. Then show that after we change the value that we can
		 * retrieve the new value just so we know that we are not observing an
		 * artifact of the original default value.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(1);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.TRUE, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			for (final TestCompartmentId testCompartmentId : TestCompartmentId.values()) {
				for (final CompartmentPropertyId propertyID : testCompartmentId.getCompartmentPropertyIds()) {
					/*
					 * We first assert that the current value of the property is
					 * the default for the definition.
					 */

					final PropertyDefinition propertyDefinition = environment.getCompartmentPropertyDefinition(testCompartmentId, propertyID);
					assertTrue(propertyDefinition.getDefaultValue().isPresent());
					final Object expectedPropertyValue = propertyDefinition.getDefaultValue().get();
					final Object actualPropertyValue = environment.getCompartmentPropertyValue(testCompartmentId, propertyID);
					assertEquals(expectedPropertyValue, actualPropertyValue);

					/*
					 * To be more thorough, we also assert that we can retrieve
					 * any arbitrary value since we know that default values are
					 * potentially handled as a special case.
					 */
					Object updatedPropertyValue = null;
					while ((updatedPropertyValue == null) || updatedPropertyValue.equals(actualPropertyValue)) {
						updatedPropertyValue = generatePropertyValue(propertyDefinition, environment.getRandomGenerator());
					}
					environment.setCompartmentPropertyValue(testCompartmentId, propertyID, updatedPropertyValue);
					final Object retrievedPropertyValue = environment.getCompartmentPropertyValue(testCompartmentId, propertyID);
					assertEquals(updatedPropertyValue, retrievedPropertyValue);
				}
			}

		});

		/*
		 * Preconditions test
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			CompartmentId compartmentId = TestCompartmentId.COMPARTMENT_1;
			CompartmentPropertyId compartmentPropertyId = TestCompartmentId.COMPARTMENT_1.getCompartmentPropertyIds()[0];
			// if the compartment id is null
			assertModelException(() -> environment.getCompartmentPropertyValue(null, compartmentPropertyId), SimulationErrorType.NULL_COMPARTMENT_ID);
			// if the compartment is unknown
			assertModelException(() -> environment.getCompartmentPropertyValue(TestCompartmentId.getUnknownCompartmentId(), compartmentPropertyId), SimulationErrorType.UNKNOWN_COMPARTMENT_ID);
			// if the property id is null
			assertModelException(() -> environment.getCompartmentPropertyValue(compartmentId, null), SimulationErrorType.NULL_COMPARTMENT_PROPERTY_ID);
			// if the property is unknown
			assertModelException(() -> environment.getCompartmentPropertyValue(compartmentId, TestCompartmentId.getUnknownCompartmentPropertyId()),
					SimulationErrorType.UNKNOWN_COMPARTMENT_PROPERTY_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link Environment#getGlobalComponentIds()}
	 */
	@Test
	public void testGetGlobalComponentIds() {
		/*
		 * Assert that the global component identifiers from the environment are
		 * the same as the elements of the local TestGlobalComponentId
		 * enumeration.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(2);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			final Set<TestGlobalComponentId> expectedGlobalComponentIds = EnumSet.allOf(TestGlobalComponentId.class);
			assertEquals(expectedGlobalComponentIds, environment.getGlobalComponentIds());
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests
	 * {@link Environment#getGlobalPropertyDefinition(gcm.scenario.GlobalPropertyId)}
	 */
	@Test
	public void testGetGlobalPropertyDefinition() {
		/*
		 * Retrieve each global property definition and assert that it equals
		 * the one held in the test plan executor.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(3);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		for (final TestGlobalPropertyId testGlobalPropertyId : TestGlobalPropertyId.values()) {
			taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
				final PropertyDefinition expectedPropertyDefinition = scenario.getGlobalPropertyDefinition(testGlobalPropertyId);
				final PropertyDefinition actualPropertyDefinition = environment.getGlobalPropertyDefinition(testGlobalPropertyId);
				assertEquals(expectedPropertyDefinition, actualPropertyDefinition);
			});
		}

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// if the property id is null
			assertModelException(() -> environment.getGlobalPropertyDefinition(null), SimulationErrorType.NULL_GLOBAL_PROPERTY_ID);
			// if the property id does not correspond to a known global
			// property identifier
			assertModelException(() -> environment.getGlobalPropertyDefinition(TestGlobalPropertyId.getUnknownGlobalPropertyId()), SimulationErrorType.UNKNOWN_GLOBAL_PROPERTY_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests {@link Environment#getGlobalPropertyIds()}
	 */
	@Test
	public void testGetGlobalPropertyIds() {
		/*
		 * Assert that the global component classes from the environment are the
		 * ones expected
		 */

		final long seed = SEED_PROVIDER.getSeedValue(4);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);
		addObservationContainer(scenarioBuilder);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<GlobalPropertyId> expectedGlobalPropertyIds = new LinkedHashSet<>();
			for (TestGlobalPropertyId testGlobalPropertyId : TestGlobalPropertyId.values()) {
				expectedGlobalPropertyIds.add(testGlobalPropertyId);
			}
			expectedGlobalPropertyIds.add(TestGlobalPropertyId.TASK_PLAN_CONTAINER_PROPERTY_ID);
			expectedGlobalPropertyIds.add(TestGlobalPropertyId.OBSERVATION_CONTAINER_PROPERTY_ID);
			Set<GlobalPropertyId> actualGlobalPropertyIds = environment.getGlobalPropertyIds();
			assertEquals(expectedGlobalPropertyIds, actualGlobalPropertyIds);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link Environment#getCompartmentComponentClass(CompartmentId)}
	 */
	@Test
	public void testGetCompartmentComponentClass() {
		/*
		 * Assert that the compartment component classes from the environment
		 * are the ones expected
		 */
		final long seed = SEED_PROVIDER.getSeedValue(5);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			for (TestCompartmentId testCompartmentId : TestCompartmentId.values()) {
				Class<? extends Component> expectedCompartmentComponentClass = TaskComponent.class;
				Class<? extends Component> actualCompartmentComponentClass = environment.getCompartmentComponentClass(testCompartmentId);
				assertEquals(expectedCompartmentComponentClass, actualCompartmentComponentClass);
			}
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link Environment#getRegionComponentClass(RegionId)}
	 */
	@Test
	public void testGetRegionComponentClass() {
		/*
		 * Assert that the compartment component classes from the environment
		 * are the ones expected
		 */

		final long seed = SEED_PROVIDER.getSeedValue(6);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			for (TestRegionId testRegionId : TestRegionId.values()) {
				Class<? extends Component> expectedRegionComponentClass = TaskComponent.class;
				Class<? extends Component> actualRegionComponentClass = environment.getRegionComponentClass(testRegionId);
				assertEquals(expectedRegionComponentClass, actualRegionComponentClass);
			}
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests
	 * {@link Environment#getMaterialsProducerComponentClass(gcm.scenario.MaterialsProducerId)}
	 */
	@Test
	public void testGetMaterialsProducerComponentClass() {
		/*
		 * Assert that the compartment component classes from the environment
		 * are the ones expected
		 */

		final long seed = SEED_PROVIDER.getSeedValue(7);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			for (TestMaterialsProducerId testMaterialsProducerId : TestMaterialsProducerId.values()) {
				Class<? extends Component> expectedMaterialsProducerComponentClass = TaskComponent.class;
				Class<? extends Component> actualMaterialsProducerComponentClass = environment.getMaterialsProducerComponentClass(testMaterialsProducerId);
				assertEquals(expectedMaterialsProducerComponentClass, actualMaterialsProducerComponentClass);
			}
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link Environment#releaseOutputItem(OutputItem)
	 */
	@Test
	public void testReleaseOutputItem() {
		/*
		 * Assert that report items are released to the ReportItemHandler
		 */

		class LocalOutputItemHandler implements OutputItemHandler {
			public Set<OutputItem> outputItems = new LinkedHashSet<>();

			@Override
			public void handle(OutputItem reportItem) {
				outputItems.add(reportItem);
			}

			@Override
			public Set<Class<? extends OutputItem>> getHandledClasses() {
				Set<Class<? extends OutputItem>> result = new LinkedHashSet<>();
				result.add(OutputItem.class);
				return result;
			}

			@Override
			public void openSimulation(ScenarioId scenarioId, ReplicationId replicationId) {

			}

			@Override
			public void openExperiment(ExperimentProgressLog experimentProgressLog) {

			}

			@Override
			public void closeSimulation(ScenarioId scenarioId, ReplicationId replicationId) {

			}

			@Override
			public void closeExperiment() {

			}

		}

		LocalOutputItemHandler localOutputItemHandler = new LocalOutputItemHandler();

		ReportHeaderBuilder reportHeaderBuilder = new ReportHeaderBuilder();
		reportHeaderBuilder.add("Alpha");
		reportHeaderBuilder.add("Beta");
		ReportHeader reportHeader = reportHeaderBuilder.build();

		final long seed = SEED_PROVIDER.getSeedValue(8);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		ReportItemBuilder reportItemBuilder = new ReportItemBuilder();
		reportItemBuilder.setScenarioId(scenario.getScenarioId());
		reportItemBuilder.setReplicationId(replication.getId());
		reportItemBuilder.setReportType(CompartmentPopulationReport.class);
		reportItemBuilder.setReportHeader(reportHeader);
		reportItemBuilder.addValue(56);
		reportItemBuilder.addValue("value");
		ReportItem reportItem = reportItemBuilder.build();

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the report item is null
			assertModelException(() -> environment.releaseOutputItem(null), SimulationErrorType.NULL_OUTPUT_ITEM);
		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the report item has an incorrect scenarioId
			int scenarioValue = environment.getScenarioId().getValue();
			ScenarioId badScenarioId = new ScenarioId(scenarioValue + 1);

			ReportItemBuilder builder = new ReportItemBuilder();
			builder.setScenarioId(badScenarioId);
			builder.setReplicationId(environment.getReplicationId());
			builder.setReportType(CompartmentPopulationReport.class);
			builder.setReportHeader(reportHeader);
			builder.addValue(56);
			builder.addValue("value");
			ReportItem item = builder.build();
			assertModelException(() -> environment.releaseOutputItem(item), SimulationErrorType.INCORRECT_SCENARIO_ID_FOR_OUTPUT_ITEM);
		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the report item has an incorrect replicationId

			int replicationValue = environment.getReplicationId().getValue();
			ReplicationId badReplicationId = new ReplicationId(replicationValue + 1);

			ReportItemBuilder builder = new ReportItemBuilder();
			builder.setScenarioId(environment.getScenarioId());
			builder.setReplicationId(badReplicationId);
			builder.setReportType(CompartmentPopulationReport.class);
			builder.setReportHeader(reportHeader);
			builder.addValue(56);
			builder.addValue("value");
			ReportItem item = builder.build();

			assertModelException(() -> environment.releaseOutputItem(item), SimulationErrorType.INCORRECT_REPLICATION_ID_FOR_OUTPUT_ITEM);

		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			environment.releaseOutputItem(reportItem);
		});

		Simulation simulation = new Simulation();
		simulation.addOutputItemHandler(localOutputItemHandler);
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

		assertTrue(localOutputItemHandler.outputItems.contains(reportItem));

	}

	/**
	 * Tests
	 * {@link Environment#getGlobalComponentClass(gcm.scenario.GlobalComponentId)}
	 */
	@Test
	public void testGetGlobalComponentClass() {
		/*
		 * Assert that the global property identifiers from the environment are
		 * the same as the elements of the local GlobalPropertyId enumeration.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(9);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			for (TestGlobalComponentId testGlobalComponentId : TestGlobalComponentId.values()) {
				Class<? extends Component> expectedGlobalComponentClass = TaskComponent.class;
				Class<? extends Component> actualGlobalComponentClass = environment.getGlobalComponentClass(testGlobalComponentId);
				assertEquals(expectedGlobalComponentClass, actualGlobalComponentClass);
			}
		});
		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests {@link Environment#getCurrentComponentId()}
	 */
	@Test
	public void testGetCurrentComponentId() {
		/*
		 * Assert that the global property identifiers from the environment are
		 * the same as the elements of the local GlobalPropertyId enumeration.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(10);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			assertEquals(TestGlobalComponentId.GLOBAL_COMPONENT_1, environment.getCurrentComponentId());
		});

		taskPlanContainer.addTaskPlan(TestCompartmentId.COMPARTMENT_3, testTime++, (environment) -> {
			assertEquals(TestCompartmentId.COMPARTMENT_3, environment.getCurrentComponentId());
		});

		taskPlanContainer.addTaskPlan(TestRegionId.REGION_5, testTime++, (environment) -> {
			assertEquals(TestRegionId.REGION_5, environment.getCurrentComponentId());
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests
	 * {@link Environment#getGlobalPropertyTime(gcm.scenario.GlobalPropertyId)}
	 */
	@Test
	public void testGetGlobalPropertyTime() {
		/*
		 * For each compartment property first show that the property time is
		 * zero. Next change each property so that the new property times will
		 * be the current time and test that this is so. Finally, move forward
		 * in time and show that the property value times still reflect the time
		 * when we set them and not the current time.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(11);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.TRUE, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;
		// first show that all the property values were set at time = 0

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			for (final TestGlobalPropertyId propertyID : TestGlobalPropertyId.values()) {
				/*
				 * We first assert that the current value time for each property
				 * value is zero.
				 */
				final double expectedPropertyTime = 0;
				final double actualPropertyTime = environment.getGlobalPropertyTime(propertyID);
				assertEquals(expectedPropertyTime, actualPropertyTime, 0);
			}

		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			for (final TestGlobalPropertyId propertyID : TestGlobalPropertyId.values()) {
				/*
				 * Change the value of the property.
				 */

				final PropertyDefinition propertyDefinition = environment.getGlobalPropertyDefinition(propertyID);
				final Object actualPropertyValue = environment.getGlobalPropertyValue(propertyID);
				Object updatedPropertyValue = null;
				while ((updatedPropertyValue == null) || updatedPropertyValue.equals(actualPropertyValue)) {
					updatedPropertyValue = generatePropertyValue(propertyDefinition, environment.getRandomGenerator());
				}
				environment.setGlobalPropertyValue(propertyID, updatedPropertyValue);
				final double expectedPropertyTime = 2.0;
				final double actualPropertyTime = environment.getGlobalPropertyTime(propertyID);
				assertEquals(expectedPropertyTime, actualPropertyTime, 0);
			}

		});

		// next, check that all the property time values are 2.0 and not the
		// current time of 3.0
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			for (final TestGlobalPropertyId propertyID : TestGlobalPropertyId.values()) {
				final double expectedPropertyTime = 2.0;
				final double actualPropertyTime = environment.getGlobalPropertyTime(propertyID);
				assertEquals(expectedPropertyTime, actualPropertyTime, 0);
			}

		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// if the property id is null
			assertModelException(() -> environment.getGlobalPropertyTime(null), SimulationErrorType.NULL_GLOBAL_PROPERTY_ID);
			// if the property id does not correspond to a known global
			// property identifier
			assertModelException(() -> environment.getGlobalPropertyTime(TestGlobalPropertyId.getUnknownGlobalPropertyId()), SimulationErrorType.UNKNOWN_GLOBAL_PROPERTY_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests
	 * {@link Environment#getGlobalPropertyValue(gcm.scenario.GlobalPropertyId)}
	 */
	@Test
	public void testGetGlobalPropertyValue() {
		/*
		 * For each global property definition, show that the current value is
		 * the default value we expect from the property definition. Then show
		 * that after we change the value that we can retrieve the new value
		 * just so we know that we are not observing an artifact of the original
		 * default value.
		 */

		long seed = SEED_PROVIDER.getSeedValue(12);

		RandomGenerator randomGenerator = getRandomGenerator(seed);
		Replication replication = getReplication(randomGenerator);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.TRUE, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		int taskTime = 0;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, taskTime++, (environment) -> {

			for (final TestGlobalPropertyId propertyID : TestGlobalPropertyId.values()) {
				/*
				 * We first assert that the current value of the property is the
				 * default for the definition.
				 */

				final PropertyDefinition propertyDefinition = environment.getGlobalPropertyDefinition(propertyID);
				assertTrue(propertyDefinition.getDefaultValue().isPresent());
				final Object expectedPropertyValue = propertyDefinition.getDefaultValue().get();
				final Object actualPropertyValue = environment.getGlobalPropertyValue(propertyID);
				assertEquals(expectedPropertyValue, actualPropertyValue);

				/*
				 * To be more thorough, we also assert that we can retrieve any
				 * arbitrary value since we know that default values are
				 * potentially handled as a special case.
				 */
				Object updatedPropertyValue = null;
				while ((updatedPropertyValue == null) || updatedPropertyValue.equals(actualPropertyValue)) {
					updatedPropertyValue = generatePropertyValue(propertyDefinition, environment.getRandomGenerator());
				}
				environment.setGlobalPropertyValue(propertyID, updatedPropertyValue);
				final Object retrievedPropertyValue = environment.getGlobalPropertyValue(propertyID);
				assertEquals(updatedPropertyValue, retrievedPropertyValue);
			}
		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, taskTime++, (environment) -> {
			// if the property id is null
			assertModelException(() -> environment.getGlobalPropertyValue(null), SimulationErrorType.NULL_GLOBAL_PROPERTY_ID);
			// if the property id does not correspond to a known global
			// property identifier
			assertModelException(() -> environment.getGlobalPropertyValue(TestGlobalPropertyId.getUnknownGlobalPropertyId()), SimulationErrorType.UNKNOWN_GLOBAL_PROPERTY_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests {@link Environment#getGroupCountForGroupType(GroupTypeId)}
	 */
	@Test
	public void testGetGroupCountForGroupType() {
		/*
		 * Assert that the number of groups ids associated with each group type
		 * can be retrieved
		 */

		final long seed = SEED_PROVIDER.getSeedValue(13);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// add the groups to the simulation, using a different number of
			// groups per group type so that we are sure that the values we
			// retrieve are indeed the correct ones and not just
			// superficially equal.

			int groupCount = 3;
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				for (int i = 0; i < groupCount; i++) {
					environment.addGroup(testGroupTypeId);
				}
				groupCount++;
			}

			// show that the group counts retrieved for each group type
			// match
			// our expectations
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				final int excectedGroupCount = environment.getGroupsForGroupType(testGroupTypeId).size();
				final int actualGroupCount = environment.getGroupCountForGroupType(testGroupTypeId);
				assertEquals(excectedGroupCount, actualGroupCount);
			}

		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the group type is null
			assertModelException(() -> environment.getGroupCountForGroupType(null), SimulationErrorType.NULL_GROUP_TYPE_ID);
			// if the group type is unknown
			assertModelException(() -> environment.getGroupCountForGroupType(TestGroupTypeId.getUnknownGroupTypeId()), SimulationErrorType.UNKNOWN_GROUP_TYPE_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests
	 * {@link Environment#getGroupCountForGroupTypeAndPerson(GroupTypeId, PersonId)}
	 */
	@Test
	public void testGetGroupCountForGroupTypeAndPerson() {
		/*
		 * Assert that the groups ids associated with each group type can be
		 * retrieved
		 */
		final long seed = SEED_PROVIDER.getSeedValue(14);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// get the people from the simulation
			final List<PersonId> people = environment.getPeople();

			// show that there are sufficient people to run a valid test
			assertTrue(people.size() > 100);

			// add the groups to the simulation
			int groupCount = 0;
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				for (int i = 0; i < 10; i++) {
					final GroupId groupId = environment.addGroup(testGroupTypeId);
					assertEquals(groupCount, groupId.getValue());
					groupCount++;
				}
			}

			// associate the people with groups and fill our expected
			// membership
			final RandomGenerator rng = environment.getRandomGenerator();
			final Random random = new Random(rng.nextLong());

			for (int groupIndex = 0; groupIndex < groupCount; groupIndex++) {
				GroupId groupId = new GroupId(groupIndex);
				final int personCount = rng.nextInt(20) + 10;
				Collections.shuffle(people, random);
				for (int i = 0; i < personCount; i++) {
					final PersonId personId = people.get(i);
					environment.addPersonToGroup(personId, groupId);
				}
			}

			// show that the groups returned for each (person,group type id)
			// pair match our expectations
			for (final PersonId personId : people) {
				for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {

					final int expectedCount = environment.getGroupsForGroupTypeAndPerson(testGroupTypeId, personId).size();
					final int actualCount = environment.getGroupCountForGroupTypeAndPerson(testGroupTypeId, personId);

					assertEquals(expectedCount, actualCount);
				}
			}
		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// if the group type is null
			assertModelException(() -> environment.getGroupCountForGroupTypeAndPerson(null, new PersonId(0)), SimulationErrorType.NULL_GROUP_TYPE_ID);
			// if the group type is unknown
			assertModelException(() -> environment.getGroupCountForGroupTypeAndPerson(TestGroupTypeId.getUnknownGroupTypeId(), new PersonId(0)), SimulationErrorType.UNKNOWN_GROUP_TYPE_ID);
			// if the person id is null
			assertModelException(() -> environment.getGroupCountForGroupTypeAndPerson(TestGroupTypeId.GROUP_TYPE_1, null), SimulationErrorType.NULL_PERSON_ID);
			// if the person id is unknown
			assertModelException(() -> environment.getGroupCountForGroupTypeAndPerson(TestGroupTypeId.GROUP_TYPE_1, new PersonId(-1)), SimulationErrorType.UNKNOWN_PERSON_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

	
}
