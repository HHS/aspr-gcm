package gcm.automated;

import static gcm.automated.support.EnvironmentSupport.addStandardComponentsAndTypes;
import static gcm.automated.support.EnvironmentSupport.addStandardPeople;
import static gcm.automated.support.EnvironmentSupport.addStandardPropertyDefinitions;
import static gcm.automated.support.EnvironmentSupport.addStandardTrackingAndScenarioId;
import static gcm.automated.support.EnvironmentSupport.addTaskPlanContainer;
import static gcm.automated.support.EnvironmentSupport.assertAllPlansExecuted;
import static gcm.automated.support.EnvironmentSupport.generatePropertyValue;
import static gcm.automated.support.EnvironmentSupport.getRandomGenerator;
import static gcm.automated.support.EnvironmentSupport.getReplication;
import static gcm.automated.support.ExceptionAssertion.assertModelException;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.util.EnumSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.math3.random.RandomGenerator;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import gcm.automated.support.EnvironmentSupport;
import gcm.automated.support.EnvironmentSupport.PropertyAssignmentPolicy;
import gcm.automated.support.SeedProvider;
import gcm.automated.support.TaskPlanContainer;
import gcm.automated.support.TestGlobalComponentId;
import gcm.automated.support.TestGroupTypeId;
import gcm.replication.Replication;
import gcm.scenario.GroupId;
import gcm.scenario.GroupPropertyId;
import gcm.scenario.GroupTypeId;
import gcm.scenario.PersonId;
import gcm.scenario.PropertyDefinition;
import gcm.scenario.Scenario;
import gcm.scenario.ScenarioBuilder;
import gcm.scenario.UnstructuredScenarioBuilder;
import gcm.simulation.EnvironmentImpl;
import gcm.simulation.Simulation;
import gcm.simulation.SimulationErrorType;
import gcm.util.annotations.UnitTest;

@UnitTest(target = EnvironmentImpl.class)

public class AT_EnvironmentImpl_05 {

	private static SeedProvider SEED_PROVIDER;

	@BeforeClass
	public static void beforeClass() {
		SEED_PROVIDER = new SeedProvider(EnvironmentSupport.getMetaSeed(5));
	}

	/**
	 * Internal test(not part of public tests) to show that there are no large
	 * gaps in the seed cases generated by the SeedProvider.
	 */
	@AfterClass
	public static void afterClass() {
//		System.out.println(SEED_PROVIDER.generateUnusedSeedReport());
	}


	/**
	 * Tests {@link EnvironmentImpl#getGroupCountForPerson(PersonId)}
	 */
	@Test
	public void testGetGroupCountForPerson() {
		/*
		 * Assert that the number of groups associated with each person can be
		 * retrieved
		 */

		final long seed = SEED_PROVIDER.getSeedValue(0);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			final RandomGenerator rng = environment.getRandomGenerator();
			// get the people from the simulation
			final List<PersonId> people = environment.getPeople();

			// show that there are sufficient people to run a valid test
			assertTrue(people.size() > 100);

			// add the groups to the simulation
			int groupCount = 10;

			for (int i = 0; i < groupCount; i++) {
				int index = rng.nextInt(TestGroupTypeId.values().length);
				TestGroupTypeId testGroupTypeId = TestGroupTypeId.values()[index];
				final GroupId groupId = environment.addGroup(testGroupTypeId);
				assertEquals(i, groupId.getValue());
			}

			// associate the people with groups
			for (int groupIndex = 0; groupIndex < groupCount; groupIndex++) {
				final Set<PersonId> selectedPeople = new LinkedHashSet<>();
				while (selectedPeople.size() < 30) {
					final int index = rng.nextInt(people.size());
					final PersonId person = people.get(index);
					selectedPeople.add(person);
				}
				for (final PersonId personId : selectedPeople) {
					environment.addPersonToGroup(personId, new GroupId(groupIndex));
				}
			}

			/*
			 * show that group types associated with each person match our
			 * expectations
			 */
			for (final PersonId personId : people) {
				final int expectedCount = environment.getGroupsForPerson(personId).size();
				final int actualCount = environment.getGroupCountForPerson(personId);
				assertEquals(expectedCount, actualCount);
			}
		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the person id is null
			assertModelException(() -> environment.getGroupCountForPerson(null), SimulationErrorType.NULL_PERSON_ID);
			// if the person id is unknown
			assertModelException(() -> environment.getGroupCountForPerson(new PersonId(-1)), SimulationErrorType.UNKNOWN_PERSON_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests
	 * {@link EnvironmentImpl#getGroupPropertyDefinition(GroupTypeId, GroupPropertyId)}
	 */
	@Test
	public void testGetGroupPropertyDefinition() {
		/*
		 * Retrieve each group property definition and assert that it equals the
		 * one held in the test plan executor.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(1);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				final Set<GroupPropertyId> propertyIds = scenario.getGroupPropertyIds(testGroupTypeId);
				// make sure there is at least one property defined so that
				// the test is valid
				assertTrue(propertyIds.size() > 0);
				for (final GroupPropertyId groupPropertyId : propertyIds) {
					final PropertyDefinition expectedPropertyDefinition = scenario.getGroupPropertyDefinition(testGroupTypeId, groupPropertyId);
					final PropertyDefinition actualPropertyDefinition = environment.getGroupPropertyDefinition(testGroupTypeId, groupPropertyId);
					assertEquals(expectedPropertyDefinition, actualPropertyDefinition);
				}
			}
		});

		// Show that there is at least one property id associated with
		// GROUP_TYPE_1 so that we know that the precondition tests are valid
		final Set<GroupPropertyId> propertyIds = scenario.getGroupPropertyIds(TestGroupTypeId.GROUP_TYPE_1);
		assertTrue(propertyIds.size() > 0);
		// get the first such property id for use in the precondition tests
		final GroupPropertyId groupPropertyId = propertyIds.iterator().next();

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the group type id is null
			assertModelException(() -> environment.getGroupPropertyDefinition(null, groupPropertyId), SimulationErrorType.NULL_GROUP_TYPE_ID);
			// if the group type id unknown
			assertModelException(() -> environment.getGroupPropertyDefinition(TestGroupTypeId.getUnknownGroupTypeId(), groupPropertyId), SimulationErrorType.UNKNOWN_GROUP_TYPE_ID);
			// if the groupPropertyId is null
			assertModelException(() -> environment.getGroupPropertyDefinition(TestGroupTypeId.GROUP_TYPE_1, null), SimulationErrorType.NULL_GROUP_PROPERTY_ID);
			// if the groupPropertyId unknown
			assertModelException(() -> environment.getGroupPropertyDefinition(TestGroupTypeId.GROUP_TYPE_1, TestGroupTypeId.getUnknownGroupPropertyId()),
					SimulationErrorType.UNKNOWN_GROUP_PROPERTY_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getGroupPropertyIds(GroupTypeId)}
	 */
	@Test
	public void testGetGroupPropertyIds() {
		/*
		 * Assert that the group property identifiers from the environment are
		 * the same as those stored in the local GroupTypeId enumeration.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(2);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {

				final Set<GroupPropertyId> expectedGroupPropertyIds = new LinkedHashSet<>();
				final GroupPropertyId[] groupPropertyIds = testGroupTypeId.getGroupPropertyIds();
				for (final GroupPropertyId groupPropertyId : groupPropertyIds) {
					expectedGroupPropertyIds.add(groupPropertyId);
				}
				assertEquals(expectedGroupPropertyIds, environment.getGroupPropertyIds(testGroupTypeId));
			}
		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the group type id is null
			assertModelException(() -> environment.getGroupPropertyIds(null), SimulationErrorType.NULL_GROUP_TYPE_ID);
			// if group type id is unknown
			assertModelException(() -> environment.getGroupPropertyIds(TestGroupTypeId.getUnknownGroupTypeId()), SimulationErrorType.UNKNOWN_GROUP_TYPE_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getGroupPropertyTime(GroupId, GroupPropertyId)}
	 */
	@Test
	public void testGetGroupPropertyTime() {
		/*
		 * For each group property first show that the property time is zero.
		 * Next change each property so that the new property times will be the
		 * current time and test that this is so. Finally, move forward in time
		 * and show that the property value times still reflect the time when we
		 * set them and not the current time.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(3);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.TRUE, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// make sure that there is at least on group type in the
			// simulation to show that the test is valid
			assertTrue(environment.getGroupTypeIds().size() > 0);

			for (final GroupTypeId groupTypeId : environment.getGroupTypeIds()) {
				final GroupId groupId = environment.addGroup(groupTypeId);
				// make sure that there is at least one property to show
				// that the test is valid
				final Set<GroupPropertyId> groupPropertyIds = environment.getGroupPropertyIds(groupTypeId);
				assertTrue(groupPropertyIds.size() > 0);
				for (final GroupPropertyId propertyID : groupPropertyIds) {
					final double expectedPropertyTime = 0;
					final double actualPropertyTime = environment.getGroupPropertyTime(groupId, propertyID);
					assertEquals(expectedPropertyTime, actualPropertyTime, 0);
				}
			}

		});

		/*
		 * Change each property value and show that the time values are the
		 * current time
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			final Set<GroupTypeId> groupTypeIds = environment.getGroupTypeIds();
			assertTrue(groupTypeIds.size() > 0);
			for (final GroupTypeId groupTypeId : groupTypeIds) {
				final List<GroupId> groupIds = environment.getGroupsForGroupType(groupTypeId);
				assertTrue(groupIds.size() > 0);
				for (final GroupId groupId : groupIds) {
					final Set<GroupPropertyId> groupPropertyIds = environment.getGroupPropertyIds(groupTypeId);
					assertTrue(groupPropertyIds.size() > 0);
					for (final GroupPropertyId propertyID : groupPropertyIds) {
						final PropertyDefinition propertyDefinition = environment.getGroupPropertyDefinition(groupTypeId, propertyID);
						final Object actualPropertyValue = environment.getGroupPropertyValue(groupId, propertyID);
						Object updatedPropertyValue = null;
						while ((updatedPropertyValue == null) || updatedPropertyValue.equals(actualPropertyValue)) {
							updatedPropertyValue = generatePropertyValue(propertyDefinition, environment.getRandomGenerator());
						}
						environment.setGroupPropertyValue(groupId, propertyID, updatedPropertyValue);
						final double expectedPropertyTime = 2.0;
						final double actualPropertyTime = environment.getGroupPropertyTime(groupId, propertyID);
						assertEquals(expectedPropertyTime, actualPropertyTime, 0);
					}
				}
			}

		});

		/*
		 * Time has moved forward and we show that the property value times
		 * still reflect when they were set
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			final Set<GroupTypeId> groupTypeIds = environment.getGroupTypeIds();
			assertTrue(groupTypeIds.size() > 0);
			for (final GroupTypeId groupTypeId : groupTypeIds) {
				final List<GroupId> groupIds = environment.getGroupsForGroupType(groupTypeId);
				assertTrue(groupIds.size() > 0);
				for (final GroupId groupId : groupIds) {
					final Set<GroupPropertyId> groupPropertyIds = environment.getGroupPropertyIds(groupTypeId);
					assertTrue(groupPropertyIds.size() > 0);
					for (final GroupPropertyId propertyID : groupPropertyIds) {
						final double expectedPropertyTime = 2.0;
						final double actualPropertyTime = environment.getGroupPropertyTime(groupId, propertyID);
						assertEquals(expectedPropertyTime, actualPropertyTime, 0);
					}
				}
			}

		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// make sure that we have an existing property and group to show
			// the precondition tests are valid
			assertTrue(environment.groupExists(new GroupId(0)));
			final GroupPropertyId groupPropertyId = environment.getGroupPropertyIds(TestGroupTypeId.GROUP_TYPE_1).iterator().next();
			assertNotNull(groupPropertyId);

			// if the group id is null
			assertModelException(() -> environment.getGroupPropertyTime(null, groupPropertyId), SimulationErrorType.NULL_GROUP_ID);
			// if the group id is unknown
			assertModelException(() -> environment.getGroupPropertyTime(new GroupId(-1), groupPropertyId), SimulationErrorType.UNKNOWN_GROUP_ID);
			// if the groupPropertyId is null
			assertModelException(() -> environment.getGroupPropertyTime(new GroupId(0), null), SimulationErrorType.NULL_GROUP_PROPERTY_ID);
			// if the groupPropertyId is unknown
			assertModelException(() -> environment.getGroupPropertyTime(new GroupId(0), TestGroupTypeId.getUnknownGroupPropertyId()), SimulationErrorType.UNKNOWN_GROUP_PROPERTY_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getGroupPropertyValue(GroupId, GroupPropertyId)}
	 */
	@Test
	public void testGetGroupPropertyValue() {
		/*
		 * For each group type id and group property definition, show that the
		 * current value is the default value we expect from the property
		 * definition. Then show that after we change the value that we can
		 * retrieve the new value just so we know that we are not observing an
		 * artifact of the original default value.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(4);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.TRUE, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// make sure that there is at least one group type in the
			// simulation to show that the test is valid
			assertTrue(environment.getGroupTypeIds().size() > 0);

			for (final GroupTypeId groupTypeId : environment.getGroupTypeIds()) {
				final GroupId groupId = environment.addGroup(groupTypeId);
				// make sure that there is at least one property to show
				// that the test is valid
				final Set<GroupPropertyId> groupPropertyIds = environment.getGroupPropertyIds(groupTypeId);
				assertTrue(groupPropertyIds.size() > 0);
				for (final GroupPropertyId propertyID : groupPropertyIds) {
					/*
					 * We first assert that the current value of the property is
					 * the default for the definition.
					 */

					final PropertyDefinition propertyDefinition = environment.getGroupPropertyDefinition(groupTypeId, propertyID);
					assertTrue(propertyDefinition.getDefaultValue().isPresent());
					final Object expectedPropertyValue = propertyDefinition.getDefaultValue().get();
					final Object actualPropertyValue = environment.getGroupPropertyValue(groupId, propertyID);
					assertEquals(expectedPropertyValue, actualPropertyValue);

					/*
					 * To be more thorough, we also assert that we can retrieve
					 * any arbitrary value since we know that default values are
					 * potentially handled as a special case.
					 */
					Object updatedPropertyValue = null;
					while ((updatedPropertyValue == null) || updatedPropertyValue.equals(actualPropertyValue)) {
						updatedPropertyValue = generatePropertyValue(propertyDefinition, environment.getRandomGenerator());
					}
					environment.setGroupPropertyValue(groupId, propertyID, updatedPropertyValue);
					final Object retrievedPropertyValue = environment.getGroupPropertyValue(groupId, propertyID);
					assertEquals(updatedPropertyValue, retrievedPropertyValue);
				}
			}

		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// make sure that we have an existing property and group to show
			// the precondition tests are valid
			assertTrue(environment.groupExists(new GroupId(0)));
			final GroupPropertyId groupPropertyId = environment.getGroupPropertyIds(TestGroupTypeId.GROUP_TYPE_1).iterator().next();
			assertNotNull(groupPropertyId);

			// if the group id is null
			assertModelException(() -> environment.getGroupPropertyValue(null, groupPropertyId), SimulationErrorType.NULL_GROUP_ID);
			// if the group id is unknown
			assertModelException(() -> environment.getGroupPropertyValue(new GroupId(-1), groupPropertyId), SimulationErrorType.UNKNOWN_GROUP_ID);
			// if the groupPropertyId is null
			assertModelException(() -> environment.getGroupPropertyValue(new GroupId(0), null), SimulationErrorType.NULL_GROUP_PROPERTY_ID);
			// if the groupPropertyId is unknown
			assertModelException(() -> environment.getGroupPropertyValue(new GroupId(0), TestGroupTypeId.getUnknownGroupPropertyId()), SimulationErrorType.UNKNOWN_GROUP_PROPERTY_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests {@link EnvironmentImpl#getGroupsForGroupType(GroupTypeId)}
	 */
	@Test
	public void testGetGroupsForGroupType() {
		/*
		 * Assert that the groups ids associated with each group type can be
		 * retrieved
		 */
		final long seed = SEED_PROVIDER.getSeedValue(5);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// add the groups to the simulation, using a different number of
			// groups per group type so that we are sure that the values we
			// retrieve are indeed the correct ones and not just
			// superficially equal.

			final Map<TestGroupTypeId, Set<GroupId>> expectedGroupIdsMap = new LinkedHashMap<>();
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				expectedGroupIdsMap.put(testGroupTypeId, new LinkedHashSet<>());
			}

			int groupCount = 3;
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				final Set<GroupId> expectedGroupIds = expectedGroupIdsMap.get(testGroupTypeId);
				for (int i = 0; i < groupCount; i++) {
					final GroupId groupId = environment.addGroup(testGroupTypeId);
					expectedGroupIds.add(groupId);
				}
				groupCount++;
			}

			// show that the group ids retrieved for each group type match
			// our expectations
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				final List<GroupId> groupIds = environment.getGroupsForGroupType(testGroupTypeId);
				final Set<GroupId> actualGroupIds = new LinkedHashSet<>(groupIds);
				// show that the list returned from the environment had
				// unique values
				assertEquals(groupIds.size(), actualGroupIds.size());
				// show that the expected group ids for this group type id
				// match the actual group ids
				final Set<GroupId> expectedGroupIds = expectedGroupIdsMap.get(testGroupTypeId);
				assertEquals(expectedGroupIds, actualGroupIds);
			}
		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the group type is null
			assertModelException(() -> environment.getGroupsForGroupType(null), SimulationErrorType.NULL_GROUP_TYPE_ID);
			// if the group type is unknown
			assertModelException(() -> environment.getGroupsForGroupType(TestGroupTypeId.getUnknownGroupTypeId()), SimulationErrorType.UNKNOWN_GROUP_TYPE_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests
	 * {@link EnvironmentImpl#getGroupsForGroupTypeAndPerson(GroupTypeId, PersonId)}
	 */
	@Test
	public void testGetGroupsForGroupTypeAndPerson() {
		/*
		 * Assert that the groups ids associated with each group type can be
		 * retrieved
		 */

		final long seed = SEED_PROVIDER.getSeedValue(6);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// get the people from the simualtion
			final List<PersonId> people = environment.getPeople();

			// show that there are sufficient people to run a valid test
			assertTrue(people.size() > 100);

			// prepare a data structure to hold our expectations
			final Map<PersonId, Map<TestGroupTypeId, Set<GroupId>>> expectedGroupMembershipMap = new LinkedHashMap<>();
			for (final PersonId personId : people) {
				final Map<TestGroupTypeId, Set<GroupId>> map = new LinkedHashMap<>();
				expectedGroupMembershipMap.put(personId, map);
				for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
					map.put(testGroupTypeId, new LinkedHashSet<>());
				}
			}
			int groupCount = 0;
			// add the groups to the simulation
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				for (int i = 0; i < 10; i++) {
					final GroupId groupId = environment.addGroup(testGroupTypeId);
					assertEquals(groupCount, groupId.getValue());
					groupCount++;
				}
			}

			// associate the people with groups and fill our expected
			// membership
			final RandomGenerator rng = environment.getRandomGenerator();
			for (int groupIndex = 0; groupIndex < groupCount; groupIndex++) {
				GroupId groupId = new GroupId(groupIndex);
				final Set<PersonId> selectedPeople = new LinkedHashSet<>();
				while (selectedPeople.size() < 50) {
					final int index = rng.nextInt(people.size());
					final PersonId person = people.get(index);
					selectedPeople.add(person);
					final GroupTypeId groupType = environment.getGroupType(groupId);
					expectedGroupMembershipMap.get(person).get(groupType).add(groupId);
				}
				for (final PersonId personId : selectedPeople) {
					environment.addPersonToGroup(personId, groupId);
				}
			}

			// show that the groups returned for each (person,group type id)
			// pair match our expectations
			for (final PersonId personId : people) {
				for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
					final List<GroupId> groupIds = environment.getGroupsForGroupTypeAndPerson(testGroupTypeId, personId);
					final Set<GroupId> actualGroupIds = new LinkedHashSet<>(groupIds);
					/*
					 * show that the list returned from the environment had
					 * unique values
					 */
					assertEquals(groupIds.size(), actualGroupIds.size());
					/*
					 * show that the expected group ids for this group type id
					 * and person match the actual group ids
					 */
					final Set<GroupId> expectedGroupIds = expectedGroupMembershipMap.get(personId).get(testGroupTypeId);
					assertEquals(expectedGroupIds, actualGroupIds);
				}
			}
		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the group type is null
			assertModelException(() -> environment.getGroupsForGroupTypeAndPerson(null, new PersonId(0)), SimulationErrorType.NULL_GROUP_TYPE_ID);
			// if the group type is unknown
			assertModelException(() -> environment.getGroupsForGroupTypeAndPerson(TestGroupTypeId.getUnknownGroupTypeId(), new PersonId(0)), SimulationErrorType.UNKNOWN_GROUP_TYPE_ID);
			// if the person id is null
			assertModelException(() -> environment.getGroupsForGroupTypeAndPerson(TestGroupTypeId.GROUP_TYPE_1, null), SimulationErrorType.NULL_PERSON_ID);
			// if the person id is unknown
			assertModelException(() -> environment.getGroupsForGroupTypeAndPerson(TestGroupTypeId.GROUP_TYPE_1, new PersonId(-1)), SimulationErrorType.UNKNOWN_PERSON_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getGroupsForPerson(PersonId)}
	 */
	@Test
	public void testGetGroupsForPerson() {
		/*
		 * Assert that the groups ids associated with each person can be
		 * retrieved
		 */

		final long seed = SEED_PROVIDER.getSeedValue(7);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// get the people from the simulation
			final List<PersonId> people = environment.getPeople();

			// show that there are sufficient people to run a valid test
			assertTrue(people.size() > 100);

			// prepare a data structure to hold our expectations
			final Map<PersonId, Set<GroupId>> expectedGroupMembershipMap = new LinkedHashMap<>();
			for (final PersonId personId : people) {
				final Set<GroupId> set = new LinkedHashSet<>();
				expectedGroupMembershipMap.put(personId, set);
			}

			// add the groups to the simulation
			int groupCount = 0;
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				for (int i = 0; i < 10; i++) {
					final GroupId groupId = environment.addGroup(testGroupTypeId);
					assertEquals(groupCount, groupId.getValue());
					groupCount++;
					final GroupTypeId actualGroupTypeId = environment.getGroupType(groupId);
					assertEquals(testGroupTypeId, actualGroupTypeId);
				}
			}

			// associate the people with groups and fill our expected
			// membership
			final RandomGenerator rng = environment.getRandomGenerator();

			for (int groupIndex = 0; groupIndex < groupCount; groupIndex++) {
				GroupId groupId = new GroupId(groupIndex);
				final Set<PersonId> selectedPeople = new LinkedHashSet<>();
				while (selectedPeople.size() < 3) {
					final int index = rng.nextInt(people.size());
					final PersonId person = people.get(index);
					selectedPeople.add(person);
					expectedGroupMembershipMap.get(person).add(groupId);

				}
				for (final PersonId personId : selectedPeople) {
					environment.addPersonToGroup(personId, groupId);
				}
			}

			/*
			 * show that there is some variety in the group types for each
			 * person
			 *
			 */
			final Set<Integer> groupTypeMembershipCount = new LinkedHashSet<>();
			for (final PersonId personId : people) {
				groupTypeMembershipCount.add(expectedGroupMembershipMap.get(personId).size());
			}
			assertTrue(groupTypeMembershipCount.size() > 1);

			/*
			 * show that group types associated with each person match our
			 * expectations
			 */
			for (final PersonId personId : people) {
				final Set<GroupId> expectedGroups = expectedGroupMembershipMap.get(personId);
				final List<GroupId> groups = environment.getGroupsForPerson(personId);
				final Set<GroupId> actualGroups = new LinkedHashSet<>(groups);
				assertEquals(groups.size(), actualGroups.size());
				assertEquals(expectedGroups, actualGroups);
			}
		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the person id is null
			assertModelException(() -> environment.getGroupsForPerson(null), SimulationErrorType.NULL_PERSON_ID);
			// if the person id is unknown
			assertModelException(() -> environment.getGroupsForPerson(new PersonId(-1)), SimulationErrorType.UNKNOWN_PERSON_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getGroupType(GroupId)
	 */
	@Test
	public void testGetGroupType() {
		/*
		 * Assert that the groups types associated with each group id match our
		 * expectations
		 */
		final long seed = SEED_PROVIDER.getSeedValue(8);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// add the groups to the simulation using randomized group types
			final int groupCount = 50;
			for (int i = 0; i < groupCount; i++) {
				final GroupTypeId testGroupTypeId = TestGroupTypeId.getRandomGroupTypeId(environment.getRandomGenerator());
				final GroupId groupId = environment.addGroup(testGroupTypeId);
				final GroupTypeId actualGroupType = environment.getGroupType(groupId);
				assertEquals(testGroupTypeId, actualGroupType);
			}
		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the group id is null
			assertModelException(() -> environment.getGroupType(null), SimulationErrorType.NULL_GROUP_ID);
			// if the group id is unknown
			assertModelException(() -> environment.getGroupType(new GroupId(-1)), SimulationErrorType.UNKNOWN_GROUP_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getGroupTypeCountForPerson(PersonId)}
	 */
	@Test
	public void testGetGroupTypeCountForPerson() {
		/*
		 * Assert that the groups ids associated with each person can be
		 * retrieved
		 */
		final long seed = SEED_PROVIDER.getSeedValue(9);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 0;
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// get the people from the simulation
			final List<PersonId> people = environment.getPeople();

			// show that there are sufficient people to run a valid test
			assertTrue(people.size() > 100);

			// add the groups to the simulation
			int groupCount = 0;
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				for (int i = 0; i < groupCount; i++) {
					final GroupId groupId = environment.addGroup(testGroupTypeId);
					assertEquals(groupCount, groupId.getValue());
					groupCount++;
				}
			}

			// associate the people with groups
			final RandomGenerator rng = environment.getRandomGenerator();
			for (int groupIndex = 0; groupIndex < groupCount; groupIndex++) {
				GroupId groupId = new GroupId(groupIndex);
				final Set<PersonId> selectedPeople = new LinkedHashSet<>();
				while (selectedPeople.size() < 30) {
					final int index = rng.nextInt(people.size());
					final PersonId person = people.get(index);
					selectedPeople.add(person);
				}
				for (final PersonId personId : selectedPeople) {
					environment.addPersonToGroup(personId, groupId);
				}
			}

			/*
			 * show that group types associated with each person match our
			 * expectations
			 */
			for (final PersonId personId : people) {
				final int expectedCount = environment.getGroupTypesForPerson(personId).size();
				final int actualCount = environment.getGroupTypeCountForPerson(personId);
				assertEquals(expectedCount, actualCount);
			}
		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the person id is null
			assertModelException(() -> environment.getGroupTypeCountForPerson(null), SimulationErrorType.NULL_PERSON_ID);
			// if the person id is unknown
			assertModelException(() -> environment.getGroupTypeCountForPerson(new PersonId(-1)), SimulationErrorType.UNKNOWN_PERSON_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getGroupTypeIds()}
	 */
	@Test
	public void testGetGroupTypeIds() {
		/*
		 * Assert that the region identifiers from the environment are the same
		 * as the elements of the local RegionId enumeration.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(10);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			final Set<TestGroupTypeId> expectedGroupTypeIds = EnumSet.allOf(TestGroupTypeId.class);
			assertEquals(expectedGroupTypeIds, environment.getGroupTypeIds());
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getGroupIds()}
	 */
	@Test
	public void testGetGroupIds() {
		/*
		 * Assert that the group identifiers reported by the simulation properly
		 * reflect additions and removals
		 */

		final long seed = SEED_PROVIDER.getSeedValue(11);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			RandomGenerator rng = environment.getRandomGenerator();
			Set<GroupId> groupIds = new LinkedHashSet<>();
			for (int i = 0; i < 10000; i++) {
				TestGroupTypeId testGroupTypeId = TestGroupTypeId.getRandomGroupTypeId(rng);
				GroupId groupId = environment.addGroup(testGroupTypeId);
				groupIds.add(groupId);
			}
			Set<GroupId> expecteGroupIds = new LinkedHashSet<>();
			for (GroupId groupId : groupIds) {
				if (rng.nextBoolean()) {
					expecteGroupIds.add(groupId);
				} else {
					environment.removeGroup(groupId);
				}
			}
			LinkedHashSet<GroupId> actualGroupIds = new LinkedHashSet<>(environment.getGroupIds());
			assertEquals(expecteGroupIds, actualGroupIds);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getGroupTypesForPerson(PersonId)}
	 */
	@Test
	public void testGetGroupTypesForPerson() {
		/*
		 * Assert that the groups ids associated with each person can be
		 * retrieved
		 */
		final long seed = SEED_PROVIDER.getSeedValue(12);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// get the people from the simulation
			final List<PersonId> people = environment.getPeople();

			// show that there are sufficient people to run a valid test
			assertTrue(people.size() > 100);

			// prepare a data structure to hold our expectations
			final Map<PersonId, Set<GroupTypeId>> expectedGroupMembershipMap = new LinkedHashMap<>();
			for (final PersonId personId : people) {
				final Set<GroupTypeId> set = new LinkedHashSet<>();
				expectedGroupMembershipMap.put(personId, set);
			}

			// add the groups to the simulation
			int groupCount = 0;
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				for (int i = 0; i < 10; i++) {
					final GroupId groupId = environment.addGroup(testGroupTypeId);
					assertEquals(groupCount, groupId.getValue());
					groupCount++;
					final GroupTypeId actualGroupTypeId = environment.getGroupType(groupId);
					assertEquals(testGroupTypeId, actualGroupTypeId);
				}
			}

			// associate the people with groups and fill our expected
			// membership
			final RandomGenerator rng = environment.getRandomGenerator();

			for (int groupIndex = 0; groupIndex < groupCount; groupIndex++) {
				GroupId groupId = new GroupId(groupIndex);
				final Set<PersonId> selectedPeople = new LinkedHashSet<>();
				while (selectedPeople.size() < 3) {
					final int index = rng.nextInt(people.size());
					final PersonId person = people.get(index);
					selectedPeople.add(person);
					final GroupTypeId groupTypeId = environment.getGroupType(groupId);
					expectedGroupMembershipMap.get(person).add(groupTypeId);
				}
				for (final PersonId personId : selectedPeople) {
					environment.addPersonToGroup(personId, groupId);
				}
			}

			/*
			 * show that there is some variety in the group types for each
			 * person
			 *
			 */
			final Set<Integer> groupTypeMembershipCount = new LinkedHashSet<>();
			for (final PersonId personId : people) {
				groupTypeMembershipCount.add(expectedGroupMembershipMap.get(personId).size());
			}
			assertTrue(groupTypeMembershipCount.size() > 1);

			/*
			 * show that group types associated with each person match our
			 * expectations
			 */
			for (final PersonId personId : people) {
				final Set<GroupTypeId> expectedGroupTypes = expectedGroupMembershipMap.get(personId);
				final List<GroupTypeId> groupTypes = environment.getGroupTypesForPerson(personId);
				final Set<GroupTypeId> actualGrouptypes = new LinkedHashSet<>(groupTypes);
				assertEquals(groupTypes.size(), actualGrouptypes.size());
				assertEquals(expectedGroupTypes, actualGrouptypes);
			}
		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the person id is null
			assertModelException(() -> environment.getGroupTypesForPerson(null), SimulationErrorType.NULL_PERSON_ID);
			// if the person id is unknown
			assertModelException(() -> environment.getGroupTypesForPerson(new PersonId(-1)), SimulationErrorType.UNKNOWN_PERSON_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	
}
