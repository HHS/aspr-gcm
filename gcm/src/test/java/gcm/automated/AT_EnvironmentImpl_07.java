package gcm.automated;

import static gcm.automated.support.EnvironmentSupport.addStandardComponentsAndTypes;
import static gcm.automated.support.EnvironmentSupport.addStandardPeople;
import static gcm.automated.support.EnvironmentSupport.addStandardPropertyDefinitions;
import static gcm.automated.support.EnvironmentSupport.addStandardTrackingAndScenarioId;
import static gcm.automated.support.EnvironmentSupport.addTaskPlanContainer;
import static gcm.automated.support.EnvironmentSupport.assertAllPlansExecuted;
import static gcm.automated.support.EnvironmentSupport.generateIncompatiblePropertyValue;
import static gcm.automated.support.EnvironmentSupport.getRandomGenerator;
import static gcm.automated.support.EnvironmentSupport.getReplication;
import static gcm.automated.support.ExceptionAssertion.assertModelException;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;

import org.apache.commons.math3.random.RandomGenerator;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import gcm.automated.support.EnvironmentSupport;
import gcm.automated.support.EnvironmentSupport.PropertyAssignmentPolicy;
import gcm.automated.support.SeedProvider;
import gcm.automated.support.TaskPlanContainer;
import gcm.automated.support.TestCompartmentId;
import gcm.automated.support.TestGlobalComponentId;
import gcm.automated.support.TestGroupTypeId;
import gcm.automated.support.TestMaterialsProducerId;
import gcm.automated.support.TestPersonPropertyId;
import gcm.automated.support.TestRegionId;
import gcm.automated.support.TestResourceId;
import gcm.replication.Replication;
import gcm.scenario.CompartmentId;
import gcm.scenario.GroupId;
import gcm.scenario.GroupTypeId;
import gcm.scenario.PersonId;
import gcm.scenario.PersonPropertyId;
import gcm.scenario.PropertyDefinition;
import gcm.scenario.RegionId;
import gcm.scenario.ResourceId;
import gcm.scenario.Scenario;
import gcm.scenario.ScenarioBuilder;
import gcm.scenario.StageId;
import gcm.scenario.UnstructuredScenarioBuilder;
import gcm.simulation.EnvironmentImpl;
import gcm.simulation.ObservableEnvironment;
import gcm.simulation.Simulation;
import gcm.simulation.SimulationErrorType;
import gcm.util.MultiKey;
import gcm.util.annotations.UnitTest;

@UnitTest(target = EnvironmentImpl.class)

public class AT_EnvironmentImpl_07 {

	private static SeedProvider SEED_PROVIDER;

	@BeforeClass
	public static void beforeClass() {
		SEED_PROVIDER = new SeedProvider(EnvironmentSupport.getMetaSeed(7));
	}

	/**
	 * Internal test(not part of public tests) to show that there are no large
	 * gaps in the seed cases generated by the SeedProvider.
	 */
	@AfterClass
	public static void afterClass() {
//		System.out.println(SEED_PROVIDER.generateUnusedSeedReport());
	}

	/**
	 * Tests {@link EnvironmentImpl#getObservableEnvironment()}
	 *
	 */
	@Test
	public void testGetObservableEnvironment() {

		/*
		 * We simply assert that a non-null ObservableEnvironment instance is
		 * returned.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(0);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			final ObservableEnvironment observableEnvironment = environment.getObservableEnvironment();
			assertNotNull(observableEnvironment);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests
	 * {@link EnvironmentImpl#getOfferedStages(gcm.scenario.MaterialsProducerId)}
	 */
	@Test
	public void testGetOfferedStages() {
		/*
		 * Show that the list of offered stages reflect
		 */

		final long seed = SEED_PROVIDER.getSeedValue(1);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			final Set<StageId> expectedOfferedStages = new LinkedHashSet<>();
			final StageId stageId1 = environment.createStage();
			final StageId stageId2 = environment.createStage();
			final StageId stageId3 = environment.createStage();
			assertEquals(expectedOfferedStages, new LinkedHashSet<>(environment.getOfferedStages(TestMaterialsProducerId.MATERIALS_PRODUCER_1)));

			environment.setStageOffer(stageId1, true);
			expectedOfferedStages.add(stageId1);
			assertEquals(expectedOfferedStages, new LinkedHashSet<>(environment.getOfferedStages(TestMaterialsProducerId.MATERIALS_PRODUCER_1)));

			environment.setStageOffer(stageId2, true);
			expectedOfferedStages.add(stageId2);
			assertEquals(expectedOfferedStages, new LinkedHashSet<>(environment.getOfferedStages(TestMaterialsProducerId.MATERIALS_PRODUCER_1)));

			environment.setStageOffer(stageId1, false);
			expectedOfferedStages.remove(stageId1);
			assertEquals(expectedOfferedStages, new LinkedHashSet<>(environment.getOfferedStages(TestMaterialsProducerId.MATERIALS_PRODUCER_1)));

			environment.setStageOffer(stageId3, true);
			expectedOfferedStages.add(stageId3);
			assertEquals(expectedOfferedStages, new LinkedHashSet<>(environment.getOfferedStages(TestMaterialsProducerId.MATERIALS_PRODUCER_1)));

		});

		// precondition tests
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			// if the materials producer id is null
			assertModelException(() -> environment.getOfferedStages(null), SimulationErrorType.NULL_MATERIALS_PRODUCER_ID);
			// if the materials producer id is unknown
			assertModelException(() -> environment.getOfferedStages(TestMaterialsProducerId.getUnknownMaterialsProducerId()), SimulationErrorType.UNKNOWN_MATERIALS_PRODUCER_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getPeople()}
	 */
	@Test
	public void testGetPeople() {
		/*
		 * Assert that the person identifiers from the environment are the
		 * expected values of the people initially added to the simulation by
		 * the TestPlanExecutor
		 */

		final long seed = SEED_PROVIDER.getSeedValue(2);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			final int expectedPeopleCount = scenario.getPeopleIds().size();
			assertTrue(expectedPeopleCount > 0);
			final Set<PersonId> expectedPeople = scenario.getPeopleIds();
			assertEquals(expectedPeople, new LinkedHashSet<>(environment.getPeople()));
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getPeopleForGroup(GroupId)}
	 */
	@Test
	public void testGetPeopleForGroup() {
		/*
		 * Assert people can be retrieved by their association with groups.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(3);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 0;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// select 15 people at random from the people in the simulation
			// for each group
			final List<PersonId> people = environment.getPeople();
			// show that there are enough people for the test to be valid
			assertTrue(people.size() > 100);

			// add some groups

			int groupCount = 0;
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				for (int i = 0; i < 5; i++) {
					environment.addGroup(testGroupTypeId);
					groupCount++;
				}
			}

			final Map<GroupId, Set<PersonId>> expectedPeoplePerGroup = new LinkedHashMap<>();
			for (int i = 0; i < groupCount; i++) {
				GroupId groupId = new GroupId(i);
				expectedPeoplePerGroup.put(groupId, new LinkedHashSet<>());
			}

			// add people at random to the groups
			final RandomGenerator rng = environment.getRandomGenerator();

			for (int groupIndex = 0; groupIndex < groupCount; groupIndex++) {
				GroupId groupId = new GroupId(groupIndex);
				final Set<PersonId> selectedPeople = new LinkedHashSet<>();
				for (int j = 0; j < 15; j++) {
					final int index = rng.nextInt(people.size());
					final PersonId person = people.get(index);
					selectedPeople.add(person);
				}
				for (final PersonId personId : selectedPeople) {
					environment.addPersonToGroup(personId, groupId);
					expectedPeoplePerGroup.get(groupId).add(personId);
				}
			}

			// show that the people associated with each group matches
			// our expectations
			for (int groupIndex = 0; groupIndex < groupCount; groupIndex++) {
				GroupId groupId = new GroupId(groupIndex);
				final List<PersonId> peopleInGroup = environment.getPeopleForGroup(groupId);
				final Set<PersonId> actualPeople = new LinkedHashSet<>(peopleInGroup);
				// show that the list returned by the environment had
				// unique values
				assertEquals(peopleInGroup.size(), actualPeople.size());
				// show that the people associated with the group match
				// our expectations
				final Set<PersonId> expectedPeople = expectedPeoplePerGroup.get(groupId);
				assertEquals(expectedPeople, actualPeople);
			}
		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the group id is null
			assertModelException(() -> environment.getPeopleForGroup(null), SimulationErrorType.NULL_GROUP_ID);
			// if the group id is unknown
			assertModelException(() -> environment.getPeopleForGroup(new GroupId(-1)), SimulationErrorType.UNKNOWN_GROUP_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getPeopleForGroupType(GroupTypeId)}
	 */
	@Test
	public void testGetPeopleForGroupType() {
		/*
		 * Assert people can be retrieved by their association with group types.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(4);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 0;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// select 15 people at random from the people in the simulation
			// for each group
			final List<PersonId> people = environment.getPeople();
			// show that there are enough people for the test to be valid
			assertTrue(people.size() > 100);

			// add some groups
			int expectedGroupId = 0;
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				for (int i = 0; i < 5; i++) {
					final GroupId actualGroupId = environment.addGroup(testGroupTypeId);
					assertEquals(expectedGroupId, actualGroupId.getValue());
					expectedGroupId++;
				}
			}
			// add people at random to the groups
			final Map<TestGroupTypeId, Set<PersonId>> expectedPeoplePerGroupTypeMap = new LinkedHashMap<>();
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				expectedPeoplePerGroupTypeMap.put(testGroupTypeId, new LinkedHashSet<>());
			}

			final RandomGenerator rng = environment.getRandomGenerator();
			int groupIndex = 0;
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				for (int i = 0; i < 5; i++) {
					final Set<PersonId> selectedPeople = new LinkedHashSet<>();
					for (int j = 0; j < 15; j++) {
						final int index = rng.nextInt(people.size());
						final PersonId person = people.get(index);
						selectedPeople.add(person);
					}
					GroupId groupId = new GroupId(groupIndex++);
					for (final PersonId personId : selectedPeople) {
						environment.addPersonToGroup(personId, groupId);
						expectedPeoplePerGroupTypeMap.get(testGroupTypeId).add(personId);
					}
				}
			}

			// show that the people associated with each group type matches
			// our expectations
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				final List<PersonId> peopleInGroupType = environment.getPeopleForGroupType(testGroupTypeId);
				final Set<PersonId> actualPeople = new LinkedHashSet<>(peopleInGroupType);
				assertEquals(peopleInGroupType.size(), actualPeople.size());
				final Set<PersonId> expectedPeople = expectedPeoplePerGroupTypeMap.get(testGroupTypeId);
				assertEquals(expectedPeople, actualPeople);
			}

		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the group type is null
			assertModelException(() -> environment.getPeopleForGroupType(null), SimulationErrorType.NULL_GROUP_TYPE_ID);
			// if the group type is unknown
			assertModelException(() -> environment.getPeopleForGroupType(TestGroupTypeId.getUnknownGroupTypeId()), SimulationErrorType.UNKNOWN_GROUP_TYPE_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests {@link EnvironmentImpl#getPeopleInCompartment(CompartmentId)}
	 */
	@Test
	public void testGetPeopleInCompartment() {
		/*
		 * Assert that we know the person id of every person in every
		 * compartment by building a map from each compartmentId to a set of
		 * person id values we expect to find in each compartment.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(5);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			for (final TestCompartmentId testCompartmentId : TestCompartmentId.values()) {
				final Set<PersonId> expectedPeopleInCompartment = new LinkedHashSet<>();
				for (final PersonId personId : scenario.getPeopleIds()) {
					if (scenario.getPersonCompartment(personId).equals(testCompartmentId)) {
						expectedPeopleInCompartment.add(personId);
					}
				}
				final Set<PersonId> actualPeopleInCompartment = new LinkedHashSet<>(environment.getPeopleInCompartment(testCompartmentId));
				assertEquals(expectedPeopleInCompartment, actualPeopleInCompartment);
			}
		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the compartment id is null
			assertModelException(() -> environment.getPeopleInCompartment(null), SimulationErrorType.NULL_COMPARTMENT_ID);
			// if the compartment is unknown
			assertModelException(() -> environment.getPeopleInCompartment(TestCompartmentId.getUnknownCompartmentId()), SimulationErrorType.UNKNOWN_COMPARTMENT_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getPeopleInRegion(RegionId)}
	 */
	@Test
	public void testGetPeopleInRegion() {
		/*
		 * Assert that we know the person id of every person in every region by
		 * building a map from each compartmentId to a set of person id values
		 * we expect to find in each compartment.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(6);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			for (final TestRegionId testRegionId : TestRegionId.values()) {
				final Set<PersonId> expectedPeopleInRegion = new LinkedHashSet<>();
				for (final PersonId personId : scenario.getPeopleIds()) {
					if (scenario.getPersonRegion(personId).equals(testRegionId)) {
						expectedPeopleInRegion.add(personId);
					}
				}
				final Set<PersonId> actualPeopleInRegion = new LinkedHashSet<>(environment.getPeopleInRegion(testRegionId));
				assertEquals(expectedPeopleInRegion, actualPeopleInRegion);
			}
		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the region id is null
			assertModelException(() -> environment.getPeopleInRegion(null), SimulationErrorType.NULL_REGION_ID);
			// if the region is unknown
			assertModelException(() -> environment.getPeopleInRegion(TestRegionId.getUnknownRegionId()), SimulationErrorType.UNKNOWN_REGION_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link} {@link EnvironmentImpl#getPeopleWithoutResource(ResourceId)}
	 */
	@Test
	public void testGetPeopleWithoutResource() {
		/*
		 * Distribute to some people a positive amount of a resource and check
		 * that the environment reports the people we expect.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(7);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			/*
			 * Distribute some resource 1 to some people
			 */
			assertTrue(environment.getPopulationCount() > 10);
			final Set<PersonId> expectedPeople = new LinkedHashSet<>();
			for (final PersonId personId : environment.getPeople()) {
				if ((personId.getValue() % 3) == 0) {
					final RegionId regionId = environment.getPersonRegion(personId);
					environment.addResourceToRegion(TestResourceId.RESOURCE1, regionId, 10);
					environment.transferResourceToPerson(TestResourceId.RESOURCE1, personId, 10);
				} else {
					expectedPeople.add(personId);
				}
			}
			final Set<PersonId> actualPeople = new LinkedHashSet<>(environment.getPeopleWithoutResource(TestResourceId.RESOURCE1));

			assertEquals(expectedPeople, actualPeople);

		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the resource id is null
			assertModelException(() -> environment.getPeopleWithoutResource(null), SimulationErrorType.NULL_RESOURCE_ID);

			// if the resource id is unknown
			assertModelException(() -> environment.getPeopleWithoutResource(TestResourceId.getUnknownResourceId()), SimulationErrorType.UNKNOWN_RESOURCE_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests
	 * {@link EnvironmentImpl#getPeopleWithPropertyValue(PersonPropertyId, Object)}
	 */
	@Test
	public void testGetPeopleWithPropertyValue() {
		/*
		 * For each person and person property, retrieve the values into a map
		 * that groups person identifiers by property value. Verify that these
		 * are the same people that we retrieve from the simulation by value.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(8);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.TRUE, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			/*
			 * Fill the personPropertyValueMap
			 */
			final Map<MultiKey, Set<PersonId>> personPropertyValueMap = new LinkedHashMap<>();
			for (final PersonId personId : environment.getPeople()) {
				for (final TestPersonPropertyId testPersonPropertyId : TestPersonPropertyId.values()) {
					final Object propertyValue = environment.getPersonPropertyValue(personId, testPersonPropertyId);
					final MultiKey multiKey = new MultiKey(testPersonPropertyId, propertyValue);
					Set<PersonId> people = personPropertyValueMap.get(multiKey);
					if (people == null) {
						people = new LinkedHashSet<>();
						personPropertyValueMap.put(multiKey, people);
					}
					people.add(personId);
				}
			}

			/*
			 * Compare the people we determined had particular property values
			 * to those that the environment returns for the same property
			 * values.
			 */

			for (final MultiKey multiKey : personPropertyValueMap.keySet()) {
				final TestPersonPropertyId testPersonPropertyId = (TestPersonPropertyId) multiKey.getKey(0);
				final Object propertyValue = multiKey.getKey(1);
				final Set<PersonId> expectedPeople = personPropertyValueMap.get(multiKey);
				final Set<PersonId> actualPeople = new LinkedHashSet<>(environment.getPeopleWithPropertyValue(testPersonPropertyId, propertyValue));
				assertEquals(expectedPeople, actualPeople);
			}

		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the property id is null
			assertModelException(() -> environment.getPeopleWithPropertyValue(null, 5), SimulationErrorType.NULL_PERSON_PROPERTY_ID);

			// if the property id is not a person property
			assertModelException(() -> environment.getPeopleWithPropertyValue(TestPersonPropertyId.getUnknownPersonPropertyId(), 5), SimulationErrorType.UNKNOWN_PERSON_PROPERTY_ID);

			// if the property value is null
			assertModelException(() -> environment.getPeopleWithPropertyValue(TestPersonPropertyId.PERSON_PROPERTY_1, null), SimulationErrorType.NULL_PERSON_PROPERTY_VALUE);

			// if the property value is not compatible with the property
			// definition
			PropertyDefinition propertyDefinition = environment.getPersonPropertyDefinition(TestPersonPropertyId.PERSON_PROPERTY_1);
			Object incompatiblePropertyValue = generateIncompatiblePropertyValue(propertyDefinition, environment.getRandomGenerator());
			assertModelException(() -> environment.getPeopleWithPropertyValue(TestPersonPropertyId.PERSON_PROPERTY_1, incompatiblePropertyValue), SimulationErrorType.INCOMPATIBLE_VALUE);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getPeopleWithResource(ResourceId)}
	 */
	@Test
	public void testGetPeopleWithResource() {
		/*
		 * Distribute to some people a positive amount of a resource and check
		 * that the environment reports the people we expect.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(9);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			/*
			 * Distribute some resource 1 to some people
			 */
			assertTrue(environment.getPopulationCount() > 10);
			final Set<PersonId> expectedPeople = new LinkedHashSet<>();
			for (final PersonId personId : environment.getPeople()) {
				if ((personId.getValue() % 3) == 0) {
					final RegionId regionId = environment.getPersonRegion(personId);
					environment.addResourceToRegion(TestResourceId.RESOURCE1, regionId, 10);
					environment.transferResourceToPerson(TestResourceId.RESOURCE1, personId, 10);
					expectedPeople.add(personId);
				}
			}
			final Set<PersonId> actualPeople = new LinkedHashSet<>(environment.getPeopleWithResource(TestResourceId.RESOURCE1));

			assertEquals(expectedPeople, actualPeople);

		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the resource id is null
			assertModelException(() -> environment.getPeopleWithResource(null), SimulationErrorType.NULL_RESOURCE_ID);

			// if the resource id is unknown
			assertModelException(() -> environment.getPeopleWithResource(TestResourceId.getUnknownResourceId()), SimulationErrorType.UNKNOWN_RESOURCE_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getPersonCompartment(PersonId)}
	 */
	@Test
	public void testGetPersonCompartment() {
		/*
		 * Assert that we get the compartment id associated with each person and
		 * that it will match the value given to that person at simulation
		 * initialization.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(10);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			for (final PersonId personId : scenario.getPeopleIds()) {
				final TestCompartmentId expectedCompartmentId = scenario.getPersonCompartment(personId);
				final TestCompartmentId actualCompartmentId = environment.getPersonCompartment(personId);
				assertEquals(expectedCompartmentId, actualCompartmentId);
			}
		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the person is null
			assertModelException(() -> environment.getPersonCompartment(null), SimulationErrorType.NULL_PERSON_ID);

			// if the person is unknown
			assertModelException(() -> environment.getPersonCompartment(new PersonId(-5)), SimulationErrorType.UNKNOWN_PERSON_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getPersonCompartmentArrivalTime(PersonId)}
	 */
	@Test
	public void testGetPersonCompartmentArrivalTime() {
		/*
		 * For each person first show that the compartment arrival time is zero.
		 * Next move each person so that the new compartment arrival times will
		 * be the current time and test that this is so. Finally, move forward
		 * in time and show that the compartment arrival times still reflect the
		 * time when we set them and not the current time.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(11);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		/*
		 * Show that each person arrived in its compartment at time = 0
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			final double expectedCompartmentArrivalTime = 0;
			for (final PersonId personId : scenario.getPeopleIds()) {
				final double actualCompartmentArrivalTime = environment.getPersonCompartmentArrivalTime(personId);
				assertEquals(expectedCompartmentArrivalTime, actualCompartmentArrivalTime, 0);
			}
		});

		/*
		 * Move each person to next compartment and show that the compartment
		 * arrival time is the current time
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			final double expectedCompartmentArrivalTime = 2.0;
			for (final PersonId personId : scenario.getPeopleIds()) {
				// move the person to the next compartment
				final TestCompartmentId currentCompartmentId = environment.getPersonCompartment(personId);
				final TestCompartmentId nextCompartmentId = currentCompartmentId.next();
				environment.setPersonCompartment(personId, nextCompartmentId);

				// show that the person arrived at their current compartment
				// at the current time
				final double actualCompartmentArrivalTime = environment.getPersonCompartmentArrivalTime(personId);
				assertEquals(expectedCompartmentArrivalTime, actualCompartmentArrivalTime, 0);
			}
		});

		/*
		 * Move forward in time and show that all the compartment arrival times
		 * still reflect the time when the people were moved.
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			final double expectedCompartmentArrivalTime = 2.0;
			for (final PersonId personId : scenario.getPeopleIds()) {
				// show that the person arrived at their current compartment
				// when they were previously moved and not the current time.
				final double actualCompartmentArrivalTime = environment.getPersonCompartmentArrivalTime(personId);
				assertEquals(expectedCompartmentArrivalTime, actualCompartmentArrivalTime, 0);
			}
		});

		/*
		 * Precondition Tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the person is null
			assertModelException(() -> environment.getPersonCompartmentArrivalTime(null), SimulationErrorType.NULL_PERSON_ID);

			// if the person is unknown
			assertModelException(() -> environment.getPersonCompartmentArrivalTime(new PersonId(-1)), SimulationErrorType.UNKNOWN_PERSON_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getPersonCountForGroup(GroupId)} id
	 */
	@Test
	public void testGetPersonCountForGroup() {
		/*
		 * Assert that the number of people in a group can be retrieved
		 */

		final long seed = SEED_PROVIDER.getSeedValue(12);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 0;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			final List<PersonId> people = environment.getPeople();
			// show that there are enough people for the test to be valid
			assertTrue(people.size() > 100);

			// add some groups
			int groupCount = 0;
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				for (int i = 0; i < 5; i++) {
					environment.addGroup(testGroupTypeId);
					groupCount++;
				}
			}

			// add people at random to the groups
			final RandomGenerator rng = environment.getRandomGenerator();
			final Random random = new Random(rng.nextLong());
			for (int groupIndex = 0; groupIndex < groupCount; groupIndex++) {
				GroupId groupId = new GroupId(groupIndex);
				final int personCount = rng.nextInt(20) + 10;
				Collections.shuffle(people, random);
				for (int i = 0; i < personCount; i++) {
					final PersonId personId = people.get(i);
					environment.addPersonToGroup(personId, groupId);
				}
			}

			// show that the people associated with each group matches
			// our expectations
			for (int groupIndex = 0; groupIndex < groupCount; groupIndex++) {
				GroupId groupId = new GroupId(groupIndex);
				final int expectedGroupCount = environment.getPeopleForGroup(groupId).size();
				final int actualGroupCount = environment.getPersonCountForGroup(groupId);
				assertEquals(expectedGroupCount, actualGroupCount);
			}

		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the group id is null
			assertModelException(() -> environment.getPersonCountForGroup(null), SimulationErrorType.NULL_GROUP_ID);
			// if the group id is unknown
			assertModelException(() -> environment.getPersonCountForGroup(new GroupId(-1)), SimulationErrorType.UNKNOWN_GROUP_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getPersonCountForGroupType(GroupTypeId)}
	 */
	@Test
	public void testGetPersonCountForGroupType() {
		/*
		 * Assert that the number of people associated with a group type can be
		 * retrieved.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(13);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 0;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// select 15 people at random from the people in the simulation
			// for each group
			final List<PersonId> people = environment.getPeople();
			// show that there are enough people for the test to be valid
			assertTrue(people.size() > 100);

			// add some groups
			int groupCount = 0;
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				for (int i = 0; i < 5; i++) {
					environment.addGroup(testGroupTypeId);
					groupCount++;
				}
			}
			// add people at random to the groups
			final RandomGenerator rng = environment.getRandomGenerator();
			final Random random = new Random(rng.nextLong());

			for (int groupIndex = 0; groupIndex < groupCount; groupIndex++) {
				GroupId groupId = new GroupId(groupIndex);
				final int personCount = rng.nextInt(20) + 10;
				Collections.shuffle(people, random);
				for (int i = 0; i < personCount; i++) {
					final PersonId personId = people.get(i);
					environment.addPersonToGroup(personId, groupId);
				}
			}

			// show that the people associated with each group type matches
			// our expectations
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {

				int expectedPersonCount = environment.getPeopleForGroupType(testGroupTypeId).size();
				int actualPersonCount = environment.getPersonCountForGroupType(testGroupTypeId);
				assertEquals(expectedPersonCount, actualPersonCount);

			}

		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the group type is null
			assertModelException(() -> environment.getPersonCountForGroupType(null), SimulationErrorType.NULL_GROUP_TYPE_ID);
			// if the group type is unknown
			assertModelException(() -> environment.getPersonCountForGroupType(TestGroupTypeId.getUnknownGroupTypeId()), SimulationErrorType.UNKNOWN_GROUP_TYPE_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

}
