package gcm.automated;


import static gcm.automated.support.EnvironmentSupport.addStandardComponentsAndTypes;
import static gcm.automated.support.EnvironmentSupport.addStandardPeople;
import static gcm.automated.support.EnvironmentSupport.addStandardPropertyDefinitions;
import static gcm.automated.support.EnvironmentSupport.addStandardTrackingAndScenarioId;
import static gcm.automated.support.EnvironmentSupport.addTaskPlanContainer;
import static gcm.automated.support.EnvironmentSupport.assertAllPlansExecuted;
import static gcm.automated.support.EnvironmentSupport.generateIncompatiblePropertyValue;
import static gcm.automated.support.EnvironmentSupport.generatePropertyValue;
import static gcm.automated.support.EnvironmentSupport.getRandomGenerator;
import static gcm.automated.support.EnvironmentSupport.getReplication;
import static gcm.automated.support.ExceptionAssertion.assertModelException;
import static gcm.simulation.partition.Filter.compartment;
import static gcm.simulation.partition.Filter.region;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Optional;
import java.util.Random;
import java.util.Set;

import org.apache.commons.math3.random.RandomGenerator;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import gcm.automated.support.EnvironmentSupport;
import gcm.automated.support.EnvironmentSupport.PropertyAssignmentPolicy;
import gcm.automated.support.SeedProvider;
import gcm.automated.support.TaskPlan;
import gcm.automated.support.TaskPlanContainer;
import gcm.automated.support.TestCompartmentId;
import gcm.automated.support.TestGlobalComponentId;
import gcm.automated.support.TestGroupTypeId;
import gcm.automated.support.TestMaterialId;
import gcm.automated.support.TestMaterialsProducerId;
import gcm.automated.support.TestRegionId;
import gcm.automated.support.TestResourceId;
import gcm.replication.Replication;
import gcm.scenario.BatchId;
import gcm.scenario.BatchPropertyId;
import gcm.scenario.CompartmentId;
import gcm.scenario.CompartmentPropertyId;
import gcm.scenario.GroupId;
import gcm.scenario.MaterialId;
import gcm.scenario.PersonId;
import gcm.scenario.PropertyDefinition;
import gcm.scenario.RegionId;
import gcm.scenario.ResourceId;
import gcm.scenario.Scenario;
import gcm.scenario.ScenarioBuilder;
import gcm.scenario.StageId;
import gcm.scenario.UnstructuredScenarioBuilder;
import gcm.simulation.EnvironmentImpl;
import gcm.simulation.Simulation;
import gcm.simulation.SimulationErrorType;
import gcm.simulation.partition.Filter;
import gcm.simulation.partition.Partition;
import gcm.simulation.partition.PartitionSampler;
import gcm.util.annotations.UnitTest;
import gcm.util.annotations.UnitTestMethod;

@UnitTest(target = EnvironmentImpl.class)

public class AT_EnvironmentImpl_20 {

	private static SeedProvider SEED_PROVIDER;

	@BeforeClass
	public static void beforeClass() {
		SEED_PROVIDER = new SeedProvider(EnvironmentSupport.getMetaSeed(20));
	}

	/**
	 * Internal test(not part of public tests) to show that there are no large
	 * gaps in the seed cases generated by the SeedProvider.
	 */
	@AfterClass
	public static void afterClass() {
//		 System.out.println(AT_EnvironmentImpl_20.class.getSimpleName() + " "
//		 + SEED_PROVIDER.generateUnusedSeedReport());

	}

	/**
	 * Tests {@link EnvironmentImpl#removeGroup(GroupId)}
	 */
	@Test
	@UnitTestMethod(name = "removeGroup", args = {GroupId.class})
	public void testRemoveGroup() {
		/*
		 * Assert that the groups can be removed
		 */
		final long seed = SEED_PROVIDER.getSeedValue(1);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			final Random random = new Random(environment.getRandomGenerator().nextLong());
			final List<PersonId> people = environment.getPeople();

			/*
			 * Add groups and put a few people in each, remove the group and
			 * show that the group no longer exists and that the group is not
			 * associated with any of the people who had been placed in the
			 * group.
			 */
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				final GroupId groupId = environment.addGroup(testGroupTypeId);
				assertTrue(environment.groupExists(groupId));
				Collections.shuffle(people, random);
				final Set<PersonId> selectedPeople = new LinkedHashSet<>();
				for (int i = 0; i < 15; i++) {
					final PersonId personId = people.get(i);
					selectedPeople.add(personId);
				}
				for (final PersonId personId : selectedPeople) {
					environment.addPersonToGroup(personId, groupId);
				}
				environment.removeGroup(groupId);

				assertFalse(environment.groupExists(groupId));
				for (final PersonId personId : selectedPeople) {
					final List<GroupId> groupIds = environment.getGroupsForGroupTypeAndPerson(testGroupTypeId, personId);
					final Set<GroupId> actualGroupIds = new LinkedHashSet<>(groupIds);
					assertFalse(actualGroupIds.contains(groupId));
				}

			}
		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the group id is null
			assertModelException(() -> environment.removeGroup(null), SimulationErrorType.NULL_GROUP_ID);
			// if the group id is unknown
			assertModelException(() -> environment.removeGroup(new GroupId(-1)), SimulationErrorType.UNKNOWN_GROUP_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#removePerson(PersonId)}
	 */
	@Test
	@UnitTestMethod(name = "removePerson", args = {PersonId.class})
	public void testRemovePerson() {
		/*
		 * Assert that a person can be removed, showing that the population
		 * counts change as expected and that the person does not exist.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(2);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;
		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestCompartmentId.COMPARTMENT_1, testTime++, (environment) -> {
			// if the personId is null
			assertModelException(() -> environment.removePerson(null), SimulationErrorType.NULL_PERSON_ID);
			// if the personId is unknown
			assertModelException(() -> environment.removePerson(new PersonId(-1)), SimulationErrorType.UNKNOWN_PERSON_ID);
		});

		taskPlanContainer.addTaskPlan(TestRegionId.REGION_1, testTime++, (environment) -> {
			/*
			 * Get a person from compartment 1, region 1
			 */

			final Filter filter = compartment(TestCompartmentId.COMPARTMENT_1).and(region(TestRegionId.REGION_1));

			environment.addPartition(Partition.builder().setFilter(filter).build(), "people of compartment 1");

			Optional<PersonId> optional = environment.samplePartition("people of compartment 1", PartitionSampler.builder().build());
			assertTrue(optional.isPresent());
			final PersonId personId = optional.get();
			assertTrue(environment.personExists(personId));
			assertTrue(environment.getPersonRegion(personId).equals(TestRegionId.REGION_1));
			assertTrue(environment.getPersonCompartment(personId).equals(TestCompartmentId.COMPARTMENT_1));

			/*
			 * now show that region a cannot remove the person
			 */
			assertModelException(() -> environment.removePerson(personId), SimulationErrorType.COMPONENT_LACKS_PERMISSION);

		});

		for (final TestCompartmentId testCompartmentId : TestCompartmentId.values()) {
			taskPlanContainer.addTaskPlan(testCompartmentId, testTime++, (environment) -> {
				/*
				 * Make sure that we have at least one person in the compartment
				 */
				assertTrue(environment.getCompartmentPopulationCount(testCompartmentId) > 0);

				int expectedCompartmentPopulationCount = environment.getCompartmentPopulationCount(testCompartmentId);
				int expectedTotalPopulationCount = environment.getPopulationCount();
				final List<PersonId> people = environment.getPeopleInCompartment(testCompartmentId);

				for (final PersonId personId : people) {
					environment.removePerson(personId);
					expectedCompartmentPopulationCount--;
					expectedTotalPopulationCount--;
					assertFalse(environment.personExists(personId));
					assertFalse(new LinkedHashSet<>(environment.getPeople()).contains(personId));
					assertEquals(expectedCompartmentPopulationCount, environment.getCompartmentPopulationCount(testCompartmentId));
					assertEquals(expectedTotalPopulationCount, environment.getPopulationCount());
				}
			});
		}

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#removePersonFromGroup(PersonId, GroupId)}
	 */
	@Test
	@UnitTestMethod(name = "removePersonFromGroup", args = {PersonId.class, GroupId.class})
	public void testRemovePersonFromGroup() {
		/*
		 * Assert that people an be removed from groups
		 */
		final long seed = SEED_PROVIDER.getSeedValue(3);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 0;
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			int groupCount = 0;
			// create some groups
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				for (int i = 0; i < 10; i++) {
					final GroupId groupId = environment.addGroup(testGroupTypeId);
					assertEquals(groupCount, groupId.getValue());
					groupCount++;
				}
			}

			final List<PersonId> people = environment.getPeople();
			// show that there are enough people to make a valid test
			assertTrue(people.size() > 100);

			for (final PersonId personId : people) {
				// pick a random group
				final GroupId groupId = new GroupId(environment.getRandomGenerator().nextInt(groupCount));
				// put the person in the group
				environment.addPersonToGroup(personId, groupId);
				// show that the person is now in the group
				assertTrue(environment.isGroupMember(personId, groupId));
				// remove the person from the group
				environment.removePersonFromGroup(personId, groupId);
				// show that the person is not in the group
				assertFalse(environment.isGroupMember(personId, groupId));
			}

		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the group id is null
			assertModelException(() -> environment.removePersonFromGroup(new PersonId(0), null), SimulationErrorType.NULL_GROUP_ID);
			// if the group id is unknown
			assertModelException(() -> environment.removePersonFromGroup(new PersonId(0), new GroupId(-1)), SimulationErrorType.UNKNOWN_GROUP_ID);
			// if the person id is null
			assertModelException(() -> environment.removePersonFromGroup(null, new GroupId(0)), SimulationErrorType.NULL_PERSON_ID);
			// if the person id is unknown
			assertModelException(() -> environment.removePersonFromGroup(new PersonId(-1), new GroupId(0)), SimulationErrorType.UNKNOWN_PERSON_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#removePlan(Object)}
	 */
	@Test
	@UnitTestMethod(name = "removePlan", args = {Object.class})
	public void testRemovePlan() {
		/*
		 * Create a test plan to remove a future test plan and then show that
		 * the removed test plan did not get executed.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(4);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		TaskPlan taskPlan1 = taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, 10, (environment) -> {
			fail();
		});

		TaskPlan taskPlan2 = taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, 1, (environment) -> {
			// cancel test plan 1
			Optional<Object> optional = environment.removePlan(taskPlan1.getKey());
			assertTrue(optional.isPresent());
		});

		/*
		 * Precondition tests
		 */
		TaskPlan taskPlan3 = taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, 1, (environment) -> {
			assertModelException(() -> environment.removePlan(null), SimulationErrorType.NULL_PLAN_KEY);
		});

		/*
		 * Test Plan 1 should have been canceled by Test Plan 2
		 *
		 */
		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertFalse(taskPlan1.planExecuted());

		assertTrue(taskPlan2.planExecuted());
		assertTrue(taskPlan3.planExecuted());
	}

	/**
	 * Tests
	 * {@link EnvironmentImpl#removeResourceFromPerson(ResourceId, PersonId, long)}
	 */
	@Test
	@UnitTestMethod(name = "removeResourceFromPerson", args = {ResourceId.class, PersonId.class, long.class})
	public void testRemoveResourceFromPerson() {
		/*
		 * Remove each of the resources from people in the simulation and show
		 * that their resource levels drop while the resource levels of the
		 * region remain stable.
		 *
		 * Test preconditions in the second test plan
		 */

		final long seed = SEED_PROVIDER.getSeedValue(6);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// we assume that there are people in every region, otherwise
			// the test won't execute
			for (final TestRegionId testRegionId : TestRegionId.values()) {
				assertTrue(environment.getRegionPopulationCount(testRegionId) > 0);
			}

			// set the max amount we will take from person
			final long maxAmount = 100;

			/*
			 * first, make sure that we have enough resource on each person by
			 * adding up to the maxAmount
			 */
			for (final TestRegionId testRegionId : TestRegionId.values()) {
				final List<PersonId> peopleInRegion = environment.getPeopleInRegion(testRegionId);

				for (final TestResourceId testResourceId : TestResourceId.values()) {
					for (final PersonId personId : peopleInRegion) {
						final long currentLevel = environment.getPersonResourceLevel(personId, testResourceId);
						final long amountToAdd = maxAmount - currentLevel;
						if (amountToAdd > 0) {
							environment.addResourceToRegion(testResourceId, testRegionId, amountToAdd);
							environment.transferResourceToPerson(testResourceId, personId, amountToAdd);
						}
					}
				}
			}

			/*
			 * Next, remove random amounts from each person testing the person
			 * and region levels as we go.
			 */
			for (final TestRegionId testRegionId : TestRegionId.values()) {
				final List<PersonId> peopleInRegion = environment.getPeopleInRegion(testRegionId);

				for (final TestResourceId testResourceId : TestResourceId.values()) {
					for (final PersonId personId : peopleInRegion) {
						// get the current levels
						final long currentRegionResourceLevel = environment.getRegionResourceLevel(testRegionId, testResourceId);
						final long currentPersonResourceLevel = environment.getPersonResourceLevel(personId, testResourceId);

						// determine the amount to transfer
						final long amountToRemove = environment.getRandomGenerator().nextInt((int) maxAmount) + 1;

						// remove the amount
						environment.removeResourceFromPerson(testResourceId, personId, amountToRemove);

						// test the levels
						final long expectedRegionResourceLevel = currentRegionResourceLevel;
						final long actualRegionResourceLevel = environment.getRegionResourceLevel(testRegionId, testResourceId);
						assertEquals(expectedRegionResourceLevel, actualRegionResourceLevel);

						final long expectedPersonResourceLevel = currentPersonResourceLevel - amountToRemove;
						final long actualPersonResourceLevel = environment.getPersonResourceLevel(personId, testResourceId);
						assertEquals(expectedPersonResourceLevel, actualPersonResourceLevel);
					}
				}
			}

		});
		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// make sure person 1 exists and has a positive amount of
			// resource 1 so that the error assertions will throw model
			// exceptions for the intended reasons.
			final PersonId personId = new PersonId(1);
			assertTrue(environment.personExists(personId));
			final RegionId regionId = environment.getPersonRegion(personId);
			final ResourceId resourceId = TestResourceId.RESOURCE1;
			environment.addResourceToRegion(resourceId, regionId, 100);
			environment.transferResourceToPerson(resourceId, personId, 100);

			// if the person id is unknown
			assertModelException(() -> environment.removeResourceFromPerson(resourceId, null, 0), SimulationErrorType.NULL_PERSON_ID);
			// if the person id is unknown
			assertModelException(() -> environment.removeResourceFromPerson(resourceId, new PersonId(-1), 0), SimulationErrorType.UNKNOWN_PERSON_ID);
			// if the resource id is null
			assertModelException(() -> environment.removeResourceFromPerson(null, personId, 0), SimulationErrorType.NULL_RESOURCE_ID);
			// if the resource id is unknown
			assertModelException(() -> environment.removeResourceFromPerson(TestResourceId.getUnknownResourceId(), personId, 0), SimulationErrorType.UNKNOWN_RESOURCE_ID);
			// if the amount is negative
			assertModelException(() -> environment.removeResourceFromPerson(resourceId, personId, -1), SimulationErrorType.NEGATIVE_RESOURCE_AMOUNT);

			final long resourceLevel = environment.getPersonResourceLevel(personId, resourceId);
			// if the amount is in excess of the amount the person possesses
			assertModelException(() -> environment.removeResourceFromPerson(resourceId, personId, resourceLevel + 1), SimulationErrorType.INSUFFICIENT_RESOURCES_AVAILABLE);
		});
		/*
		 * To support the tests that show that only the owning compartment or
		 * region of a person can remove resource from that person we will add
		 * resources to each person so that the model exceptions will have the
		 * correct proximal cause.
		 */

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			for (final PersonId personId : environment.getPeople()) {
				final RegionId regionId = environment.getPersonRegion(personId);
				for (final TestResourceId testResourceId : TestResourceId.values()) {
					environment.addResourceToRegion(testResourceId, regionId, 100);
					environment.transferResourceToPerson(testResourceId, personId, 100);
				}
			}
		});

		/*
		 * Show that compartment 2 cannot remove resource from a person in
		 * compartment 1
		 */
		taskPlanContainer.addTaskPlan(TestCompartmentId.COMPARTMENT_2, testTime++, (environment) -> {
			final Object key = new Object();
			final Filter filter = compartment(TestCompartmentId.COMPARTMENT_1);
					
			environment.addPartition(Partition.builder().setFilter(filter).build(), key);
			Optional<PersonId> optional = environment.samplePartition(key,PartitionSampler.builder().build());
			assertTrue(optional.isPresent());
			final PersonId personId = optional.get();
			// if invoker is not a global component or the person's region
			// or the person's compartment
			assertModelException(() -> environment.removeResourceFromPerson(TestResourceId.RESOURCE1, personId, 1), SimulationErrorType.COMPONENT_LACKS_PERMISSION);
			environment.removePartition(key);
		});

		/*
		 * Show that region 2 cannot remove resource from a person in region 1
		 */
		taskPlanContainer.addTaskPlan(TestRegionId.REGION_2, testTime++, (environment) -> {
			final Object key = new Object();
			final Filter filter = region(TestRegionId.REGION_1);
			environment.addPartition(Partition.builder().setFilter(filter).build(), key);
			Optional<PersonId> optional = environment.samplePartition(key,PartitionSampler.builder().build());
			assertTrue(optional.isPresent());
			PersonId personId = optional.get();

			// if invoker is not a global component or the person's region
			// or the person's compartment
			assertModelException(() -> environment.removeResourceFromPerson(TestResourceId.RESOURCE1, personId, 1), SimulationErrorType.COMPONENT_LACKS_PERMISSION);
			environment.removePartition(key);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests
	 * {@link EnvironmentImpl#removeResourceFromRegion(ResourceId, RegionId, long)}
	 */
	@Test
	@UnitTestMethod(name = "removeResourceFromRegion", args = {ResourceId.class, RegionId.class, long.class})
	public void testRemoveResourceFromRegion() {
		/*
		 * For each region and resource, remove random units from the region.
		 * Assert that the resulting levels are correct.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(7);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			for (final TestRegionId testRegionId : TestRegionId.values()) {
				for (final TestResourceId testResourceId : TestResourceId.values()) {
					// determine the current level
					final long currentResourceLevel = environment.getRegionResourceLevel(testRegionId, testResourceId);

					// generate a positive amount to add so that we have
					// something that can be removed
					long amount = environment.getRandomGenerator().nextInt(99) + 1;

					// add amount to region
					long expectedResourceLevel = currentResourceLevel + amount;
					environment.addResourceToRegion(testResourceId, testRegionId, amount);

					// make sure that we still agree
					long actualResourceLevel = environment.getRegionResourceLevel(testRegionId, testResourceId);
					assertEquals(expectedResourceLevel, actualResourceLevel);

					// now generate an amount to remove
					amount = environment.getRandomGenerator().nextInt((int) expectedResourceLevel) + 1;

					// remove the amount
					expectedResourceLevel -= amount;
					environment.removeResourceFromRegion(testResourceId, testRegionId, amount);

					// make sure that we still agree
					actualResourceLevel = environment.getRegionResourceLevel(testRegionId, testResourceId);
					assertEquals(expectedResourceLevel, actualResourceLevel);
				}
			}

		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the region id is null
			assertModelException(() -> environment.removeResourceFromRegion(TestResourceId.RESOURCE1, null, 0), SimulationErrorType.NULL_REGION_ID);
			// if the region id is unknown
			assertModelException(() -> environment.removeResourceFromRegion(TestResourceId.RESOURCE1, TestRegionId.getUnknownRegionId(), 0), SimulationErrorType.UNKNOWN_REGION_ID);
			// if the resource id is null
			assertModelException(() -> environment.removeResourceFromRegion(null, TestRegionId.REGION_1, 0), SimulationErrorType.NULL_RESOURCE_ID);
			// if the resource id is unknown
			assertModelException(() -> environment.removeResourceFromRegion(TestResourceId.getUnknownResourceId(), TestRegionId.REGION_1, 0), SimulationErrorType.UNKNOWN_RESOURCE_ID);
			// if the amount is negative
			assertModelException(() -> environment.removeResourceFromRegion(TestResourceId.RESOURCE1, TestRegionId.REGION_1, -1), SimulationErrorType.NEGATIVE_RESOURCE_AMOUNT);
			// if the amount is in excess of the amount the region possesses
			final long regionResourceLevel = environment.getRegionResourceLevel(TestRegionId.REGION_1, TestResourceId.RESOURCE1);
			assertModelException(() -> environment.removeResourceFromRegion(TestResourceId.RESOURCE1, TestRegionId.REGION_1, regionResourceLevel + 1),
					SimulationErrorType.INSUFFICIENT_RESOURCES_AVAILABLE);
		});

		taskPlanContainer.addTaskPlan(TestRegionId.REGION_2, testTime++, (environment) -> {
			// if invoker is not a global component or the given region
			assertModelException(() -> environment.removeResourceFromRegion(TestResourceId.RESOURCE1, TestRegionId.REGION_1, 0), SimulationErrorType.COMPONENT_LACKS_PERMISSION);
		});

		taskPlanContainer.addTaskPlan(TestCompartmentId.COMPARTMENT_1, testTime++, (environment) -> {
			// if invoker is not a global component or the given region
			assertModelException(() -> environment.removeResourceFromRegion(TestResourceId.RESOURCE1, TestRegionId.REGION_1, 0), SimulationErrorType.COMPONENT_LACKS_PERMISSION);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests
	 * {@link EnvironmentImpl#setBatchPropertyValue(BatchId, BatchPropertyId, Object)}
	 */
	@Test
	@UnitTestMethod(name = "setBatchPropertyValue", args = {BatchId.class, BatchPropertyId.class, Object.class})
	public void testSetBatchPropertyValue() {
		/*
		 * For each material and material property definition, set a new
		 * property value. Test that the value we set is now reflected in the
		 * simulation.
		 */

		long seed = SEED_PROVIDER.getSeedValue(8);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.TRUE, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {

			for (final MaterialId materialId : environment.getMaterialIds()) {
				final BatchId batchId = environment.createBatch(materialId, 10);
				for (final BatchPropertyId batchPropertyId : environment.getBatchPropertyIds(materialId)) {
					final PropertyDefinition propertyDefinition = environment.getBatchPropertyDefinition(materialId, batchPropertyId);
					final Object currentValue = environment.getBatchPropertyValue(batchId, batchPropertyId);
					/*
					 * Derive a new value that is not the same as the current
					 * value so that when we assert that the new value is now in
					 * place we are not actually seeing the old value.
					 */
					Object newValue = null;
					while (true) {
						newValue = generatePropertyValue(propertyDefinition, environment.getRandomGenerator());
						if (!newValue.equals(currentValue)) {
							break;
						}
					}
					/*
					 * Set the value
					 */
					environment.setBatchPropertyValue(batchId, batchPropertyId, newValue);
					/*
					 * Test that the values agree
					 */
					final Object updatedValue = environment.getBatchPropertyValue(batchId, batchPropertyId);
					assertEquals(newValue, updatedValue);
				}
			}
			assertEquals(1, environment.getTime(), 0);

		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {

			final BatchPropertyId batchPropertyId = TestMaterialId.MATERIAL_1.getBatchPropertyIds()[0];
			final PropertyDefinition propertyDefinition = environment.getBatchPropertyDefinition(TestMaterialId.MATERIAL_1, batchPropertyId);
			final Object propertyValue = generatePropertyValue(propertyDefinition, environment.getRandomGenerator());
			final Object inconpatiblePropertyValue = generateIncompatiblePropertyValue(propertyDefinition, environment.getRandomGenerator());

			final BatchId batchId = environment.createBatch(TestMaterialId.MATERIAL_1, 10.05);

			// if the batch id is null
			assertModelException(() -> environment.setBatchPropertyValue(null, batchPropertyId, propertyValue), SimulationErrorType.NULL_BATCH_ID);
			// if the batch id is unknown
			assertModelException(() -> environment.setBatchPropertyValue(new BatchId(-1), batchPropertyId, propertyValue), SimulationErrorType.UNKNOWN_BATCH_ID);
			// if property id is null
			assertModelException(() -> environment.setBatchPropertyValue(batchId, null, propertyValue), SimulationErrorType.NULL_BATCH_PROPERTY_ID);
			// if property id is unknown
			assertModelException(() -> environment.setBatchPropertyValue(batchId, TestMaterialId.getUnknownBatchPropertyId(), propertyValue), SimulationErrorType.UNKNOWN_BATCH_PROPERTY_ID);
			// if the value is null
			assertModelException(() -> environment.setBatchPropertyValue(batchId, batchPropertyId, null), SimulationErrorType.NULL_BATCH_PROPERTY_VALUE);
			// if the value is incompatible with the defined type for the
			// property
			assertModelException(() -> environment.setBatchPropertyValue(batchId, batchPropertyId, inconpatiblePropertyValue), SimulationErrorType.INCOMPATIBLE_VALUE);
			// if the batch is part of an offered stage
			final StageId stageId = environment.createStage();
			environment.moveBatchToStage(batchId, stageId);
			environment.setStageOffer(stageId, true);
			assertModelException(() -> environment.setBatchPropertyValue(batchId, batchPropertyId, propertyValue), SimulationErrorType.OFFERED_STAGE_UNALTERABLE);

		});

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_2, testTime++, (environment) -> {

			final List<BatchId> inventoryBatches = environment.getInventoryBatches(TestMaterialsProducerId.MATERIALS_PRODUCER_1);
			BatchPropertyId selectedPropertyId = null;
			TestMaterialId selectedBatchMaterial = null;
			BatchId selectedBatchID = null;

			for (final BatchId batchId : inventoryBatches) {
				final TestMaterialId testMaterialId = (TestMaterialId) environment.getBatchMaterial(batchId);
				if (testMaterialId.getBatchPropertyIds().length > 0) {
					selectedPropertyId = testMaterialId.getBatchPropertyIds()[0];
					selectedBatchMaterial = testMaterialId;
					selectedBatchID = batchId;
					break;
				}
			}
			assertNotNull(selectedBatchID);
			assertNotNull(selectedBatchMaterial);
			assertNotNull(selectedPropertyId);
			final PropertyDefinition propertyDefinition = environment.getBatchPropertyDefinition(selectedBatchMaterial, selectedPropertyId);
			final Object propertyValue = generatePropertyValue(propertyDefinition, environment.getRandomGenerator());

			final BatchPropertyId finalPropertyId = selectedPropertyId;
			final BatchId finalBatchID = selectedBatchID;

			// if invoker is not the owning materials producer component
			assertModelException(() -> environment.setBatchPropertyValue(finalBatchID, finalPropertyId, propertyValue), SimulationErrorType.COMPONENT_LACKS_PERMISSION);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

		seed = SEED_PROVIDER.getSeedValue(9);
		randomGenerator = getRandomGenerator(seed);

		scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.FALSE, randomGenerator);

		taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		scenario = scenarioBuilder.build();

		replication = getReplication(randomGenerator);

		testTime = 1;

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {

			final BatchPropertyId batchPropertyId = TestMaterialId.MATERIAL_1.getBatchPropertyIds()[0];
			final PropertyDefinition propertyDefinition = environment.getBatchPropertyDefinition(TestMaterialId.MATERIAL_1, batchPropertyId);
			final Object propertyValue = generatePropertyValue(propertyDefinition, environment.getRandomGenerator());
			final BatchId batchId = environment.createBatch(TestMaterialId.MATERIAL_1, 10);
			// if the property has been defined as immutable
			assertModelException(() -> environment.setBatchPropertyValue(batchId, batchPropertyId, propertyValue), SimulationErrorType.IMMUTABLE_VALUE);

		});

		simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests
	 * {@link EnvironmentImpl#setCompartmentPropertyValue(CompartmentId, CompartmentPropertyId, Object)}
	 */
	@Test
	@UnitTestMethod(name = "setCompartmentPropertyValue", args = {CompartmentId.class, CompartmentPropertyId.class, Object.class})
	public void testSetCompartmentPropertyValue() {

		/*
		 * For each compartment and compartment property definition, show that
		 * the current value is the default value we expect from the property
		 * definition. Then show that we can change the value.
		 */
		long seed = SEED_PROVIDER.getSeedValue(0);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.TRUE, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			for (final TestCompartmentId testCompartmentId : TestCompartmentId.values()) {
				for (final CompartmentPropertyId propertyID : testCompartmentId.getCompartmentPropertyIds()) {
					/*
					 * We first assert that the current value of the property is
					 * the default for the definition.
					 */

					final PropertyDefinition propertyDefinition = environment.getCompartmentPropertyDefinition(testCompartmentId, propertyID);
					assertTrue(propertyDefinition.getDefaultValue().isPresent());
					final Object expectedPropertyValue = propertyDefinition.getDefaultValue().get();
					final Object actualPropertyValue = environment.getCompartmentPropertyValue(testCompartmentId, propertyID);
					assertEquals(expectedPropertyValue, actualPropertyValue);

					Object updatedPropertyValue = null;
					while ((updatedPropertyValue == null) || updatedPropertyValue.equals(actualPropertyValue)) {
						updatedPropertyValue = generatePropertyValue(propertyDefinition, environment.getRandomGenerator());
					}
					environment.setCompartmentPropertyValue(testCompartmentId, propertyID, updatedPropertyValue);
					final Object retrievedPropertyValue = environment.getCompartmentPropertyValue(testCompartmentId, propertyID);
					assertEquals(updatedPropertyValue, retrievedPropertyValue);
				}
			}

		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			CompartmentId compartmentId = TestCompartmentId.COMPARTMENT_1;
			CompartmentPropertyId compartmentPropertyId = TestCompartmentId.COMPARTMENT_1.getCompartmentPropertyId(0);
			final PropertyDefinition propertyDefinition = environment.getCompartmentPropertyDefinition(compartmentId, compartmentPropertyId);
			final Object propertyValue = generatePropertyValue(propertyDefinition, environment.getRandomGenerator());
			final Object inconsistentPropertyValue = generateIncompatiblePropertyValue(propertyDefinition, environment.getRandomGenerator());

			// if the compartment id is null
			assertModelException(() -> environment.setCompartmentPropertyValue(null, compartmentPropertyId, propertyValue), SimulationErrorType.NULL_COMPARTMENT_ID);
			// if the compartment id is unknown
			assertModelException(() -> environment.setCompartmentPropertyValue(TestCompartmentId.getUnknownCompartmentId(), compartmentPropertyId, propertyValue),
					SimulationErrorType.UNKNOWN_COMPARTMENT_ID);
			// if the property id is null
			assertModelException(() -> environment.setCompartmentPropertyValue(compartmentId, null, propertyValue), SimulationErrorType.NULL_COMPARTMENT_PROPERTY_ID);
			// if the property id is unknown
			assertModelException(() -> environment.setCompartmentPropertyValue(compartmentId, TestCompartmentId.getUnknownCompartmentPropertyId(), propertyValue),
					SimulationErrorType.UNKNOWN_COMPARTMENT_PROPERTY_ID);
			// if the value is null
			assertModelException(() -> environment.setCompartmentPropertyValue(compartmentId, compartmentPropertyId, null), SimulationErrorType.NULL_COMPARTMENT_PROPERTY_VALUE);
			// if the value is incompatible with the defined type for
			// the property
			assertModelException(() -> environment.setCompartmentPropertyValue(compartmentId, compartmentPropertyId, inconsistentPropertyValue), SimulationErrorType.INCOMPATIBLE_VALUE);

		});

		taskPlanContainer.addTaskPlan(TestCompartmentId.COMPARTMENT_2, testTime++, (environment) -> {

			CompartmentId compartmentId = TestCompartmentId.COMPARTMENT_1;
			CompartmentPropertyId compartmentPropertyId = TestCompartmentId.COMPARTMENT_1.getCompartmentPropertyId(0);
			final PropertyDefinition propertyDefinition = environment.getCompartmentPropertyDefinition(compartmentId, compartmentPropertyId);
			final Object propertyValue = generatePropertyValue(propertyDefinition, environment.getRandomGenerator());

			// if the invoker is not a global component of the given
			// compartment
			assertModelException(() -> environment.setCompartmentPropertyValue(TestCompartmentId.COMPARTMENT_1, compartmentPropertyId, propertyValue), SimulationErrorType.COMPONENT_LACKS_PERMISSION);

		});

		taskPlanContainer.addTaskPlan(TestRegionId.REGION_1, testTime++, (environment) -> {

			CompartmentId compartmentId = TestCompartmentId.COMPARTMENT_1;
			CompartmentPropertyId compartmentPropertyId = TestCompartmentId.COMPARTMENT_1.getCompartmentPropertyId(0);
			final PropertyDefinition propertyDefinition = environment.getCompartmentPropertyDefinition(compartmentId, compartmentPropertyId);
			final Object propertyValue = generatePropertyValue(propertyDefinition, environment.getRandomGenerator());

			// if the invoker is not a global component of the given
			// compartment
			assertModelException(() -> environment.setCompartmentPropertyValue(TestCompartmentId.COMPARTMENT_1, compartmentPropertyId, propertyValue), SimulationErrorType.COMPONENT_LACKS_PERMISSION);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

		/*
		 * We will have to create the test plan executer again, this time
		 * forcing all property definitions to be set to not allow mutated
		 * property values.
		 */

		seed = SEED_PROVIDER.getSeedValue(5);
		randomGenerator = getRandomGenerator(seed);

		scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.FALSE, randomGenerator);

		taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		scenario = scenarioBuilder.build();

		replication = getReplication(randomGenerator);

		testTime = 1;

		taskPlanContainer.addTaskPlan(TestCompartmentId.COMPARTMENT_1, testTime++, (environment) -> {
			CompartmentId compartmentId = TestCompartmentId.COMPARTMENT_1;
			CompartmentPropertyId compartmentPropertyId = TestCompartmentId.COMPARTMENT_1.getCompartmentPropertyId(0);
			final PropertyDefinition propertyDefinition = environment.getCompartmentPropertyDefinition(compartmentId, compartmentPropertyId);
			final Object propertyValue = generatePropertyValue(propertyDefinition, environment.getRandomGenerator());

			// if the property has been defined as immutable
			assertModelException(() -> environment.setCompartmentPropertyValue(TestCompartmentId.COMPARTMENT_1, compartmentPropertyId, propertyValue), SimulationErrorType.IMMUTABLE_VALUE);

		});

		simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

}
