package gcm.automated;

import static gcm.automated.support.EnvironmentSupport.addStandardComponentsAndTypes;
import static gcm.automated.support.EnvironmentSupport.addStandardPeople;
import static gcm.automated.support.EnvironmentSupport.addStandardPropertyDefinitions;
import static gcm.automated.support.EnvironmentSupport.addStandardTrackingAndScenarioId;
import static gcm.automated.support.EnvironmentSupport.addTaskPlanContainer;
import static gcm.automated.support.EnvironmentSupport.assertAllPlansExecuted;
import static gcm.automated.support.EnvironmentSupport.generateIncompatiblePropertyValue;
import static gcm.automated.support.EnvironmentSupport.generatePropertyValue;
import static gcm.automated.support.EnvironmentSupport.getRandomGenerator;
import static gcm.automated.support.EnvironmentSupport.getReplication;
import static gcm.automated.support.ExceptionAssertion.assertModelException;
import static gcm.simulation.Filter.compartment;
import static gcm.simulation.Filter.region;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.List;

import org.apache.commons.math3.random.RandomGenerator;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import gcm.automated.support.EnvironmentSupport;
import gcm.automated.support.EnvironmentSupport.PropertyAssignmentPolicy;
import gcm.automated.support.SeedProvider;
import gcm.automated.support.TaskPlanContainer;
import gcm.automated.support.TestCompartmentId;
import gcm.automated.support.TestGlobalComponentId;
import gcm.automated.support.TestMaterialId;
import gcm.automated.support.TestMaterialsProducerId;
import gcm.automated.support.TestRegionId;
import gcm.automated.support.TestResourceId;
import gcm.replication.Replication;
import gcm.scenario.BatchId;
import gcm.scenario.MaterialsProducerId;
import gcm.scenario.PersonId;
import gcm.scenario.PropertyDefinition;
import gcm.scenario.RegionId;
import gcm.scenario.ResourceId;
import gcm.scenario.ResourcePropertyId;
import gcm.scenario.Scenario;
import gcm.scenario.ScenarioBuilder;
import gcm.scenario.StageId;
import gcm.scenario.UnstructuredScenarioBuilder;
import gcm.simulation.EnvironmentImpl;
import gcm.simulation.Filter;
import gcm.simulation.Simulation;
import gcm.simulation.SimulationErrorType;
import gcm.util.annotations.UnitTest;
import gcm.util.annotations.UnitTestMethod;

@UnitTest(target = EnvironmentImpl.class)

public class AT_EnvironmentImpl_22 {

	private static SeedProvider SEED_PROVIDER;

	@BeforeClass
	public static void beforeClass() {
		SEED_PROVIDER = new SeedProvider(EnvironmentSupport.getMetaSeed(22));
	}

	/**
	 * Internal test(not part of public tests) to show that there are no large
	 * gaps in the seed cases generated by the SeedProvider.
	 */
	@AfterClass
	public static void afterClass() {
		// System.out.println(SEED_PROVIDER.generateUnusedSeedReport());
	}

	/**
	 * Tests
	 * {@link EnvironmentImpl#setResourcePropertyValue(ResourceId, ResourcePropertyId, Object)}
	 */
	@Test
	@UnitTestMethod(name = "setResourcePropertyValue", args = { ResourceId.class, ResourcePropertyId.class, Object.class })
	public void testSetResourcePropertyValue() {
		/*
		 * For each resource and resource property definition, set a new
		 * property value. Test that the value we set is now reflected in the
		 * simulation.
		 */
		long seed = SEED_PROVIDER.getSeedValue(0);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.TRUE, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			for (final TestResourceId testResourceId : TestResourceId.values()) {
				for (final ResourcePropertyId resourcePropertyId : testResourceId.getResourcePropertyIds()) {
					final PropertyDefinition propertyDefinition = environment.getResourcePropertyDefinition(testResourceId, resourcePropertyId);
					final Object currentValue = environment.getResourcePropertyValue(testResourceId, resourcePropertyId);
					/*
					 * Derive a new value that is not the same as the current
					 * value so that when we assert that the new value is now in
					 * place we are not actually seeing the old value.
					 */
					Object newValue = null;
					while (true) {
						newValue = generatePropertyValue(propertyDefinition, environment.getRandomGenerator());
						if (!newValue.equals(currentValue)) {
							break;
						}
					}
					/*
					 * Set the value
					 */
					environment.setResourcePropertyValue(testResourceId, resourcePropertyId, newValue);
					/*
					 * Test that the values agree
					 */
					final Object updatedValue = environment.getResourcePropertyValue(testResourceId, resourcePropertyId);
					assertEquals(newValue, updatedValue);
				}
			}

			assertEquals(1, environment.getTime(), 0);

		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			ResourceId resourceId = TestResourceId.RESOURCE3;

			ResourcePropertyId resourcePropertyId = TestResourceId.RESOURCE3.getResourcePropertyIds()[0];

			final PropertyDefinition propertyDefinition = environment.getResourcePropertyDefinition(resourceId, resourcePropertyId);
			final Object propertyValue = generatePropertyValue(propertyDefinition, environment.getRandomGenerator());
			final Object incompatibleProperyValue = generateIncompatiblePropertyValue(propertyDefinition, environment.getRandomGenerator());

			// if the resource id is null
			assertModelException(() -> environment.setResourcePropertyValue(null, resourcePropertyId, propertyValue), SimulationErrorType.NULL_RESOURCE_ID);
			// if the resource id is unknown
			assertModelException(() -> environment.setResourcePropertyValue(TestResourceId.getUnknownResourceId(), resourcePropertyId, propertyValue), SimulationErrorType.UNKNOWN_RESOURCE_ID);
			// if the property id is null
			assertModelException(() -> environment.setResourcePropertyValue(resourceId, null, propertyValue), SimulationErrorType.NULL_RESOURCE_PROPERTY_ID);
			// if the property id is unknown
			assertModelException(() -> environment.setResourcePropertyValue(resourceId, TestResourceId.getUnknownResourcePropertyId(), propertyValue),
					SimulationErrorType.UNKNOWN_RESOURCE_PROPERTY_ID);
			// if the value is null
			assertModelException(() -> environment.setResourcePropertyValue(resourceId, resourcePropertyId, null), SimulationErrorType.NULL_RESOURCE_PROPERTY_VALUE);
			// if the value is incompatible with the defined type for
			// the property
			assertModelException(() -> environment.setResourcePropertyValue(resourceId, resourcePropertyId, incompatibleProperyValue), SimulationErrorType.INCOMPATIBLE_VALUE);

		});

		taskPlanContainer.addTaskPlan(TestRegionId.REGION_1, testTime++, (environment) -> {

			ResourceId resourceId = TestResourceId.RESOURCE5;
			ResourcePropertyId resourcePropertyId = TestResourceId.RESOURCE5.getResourcePropertyIds()[0];
			final PropertyDefinition propertyDefinition = environment.getResourcePropertyDefinition(resourceId, resourcePropertyId);
			final Object propertyValue = generatePropertyValue(propertyDefinition, environment.getRandomGenerator());

			// if the invoker is not a global component
			assertModelException(() -> environment.setResourcePropertyValue(resourceId, resourcePropertyId, propertyValue), SimulationErrorType.COMPONENT_LACKS_PERMISSION);

		});

		taskPlanContainer.addTaskPlan(TestCompartmentId.COMPARTMENT_1, testTime++, (environment) -> {
			ResourceId resourceId = TestResourceId.RESOURCE5;
			ResourcePropertyId resourcePropertyId = TestResourceId.RESOURCE5.getResourcePropertyIds()[0];
			final PropertyDefinition propertyDefinition = environment.getResourcePropertyDefinition(resourceId, resourcePropertyId);
			final Object propertyValue = generatePropertyValue(propertyDefinition, environment.getRandomGenerator());

			// if the invoker is not a global component
			assertModelException(() -> environment.setResourcePropertyValue(resourceId, resourcePropertyId, propertyValue), SimulationErrorType.COMPONENT_LACKS_PERMISSION);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

		seed = SEED_PROVIDER.getSeedValue(1);
		randomGenerator = getRandomGenerator(seed);

		scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.FALSE, randomGenerator);

		taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		scenario = scenarioBuilder.build();

		replication = getReplication(randomGenerator);

		testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			ResourceId resourceId = TestResourceId.RESOURCE5;
			ResourcePropertyId resourcePropertyId = TestResourceId.RESOURCE5.getResourcePropertyIds()[0];
			final PropertyDefinition propertyDefinition = environment.getResourcePropertyDefinition(resourceId, resourcePropertyId);
			final Object propertyValue = generatePropertyValue(propertyDefinition, environment.getRandomGenerator());
			// if the property has been defined as immutable
			assertModelException(() -> environment.setResourcePropertyValue(resourceId, resourcePropertyId, propertyValue), SimulationErrorType.IMMUTABLE_VALUE);

		});

		simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#setStageOffer(StageId, boolean)}
	 */
	@Test
	@UnitTestMethod(name = "setStageOffer", args = { StageId.class, boolean.class })
	public void testSetStageOffer() {
		/*
		 * Create stages and show that we can set the offer state at will
		 */

		final long seed = SEED_PROVIDER.getSeedValue(2);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			final StageId stageId = environment.createStage();

			environment.setStageOffer(stageId, true);
			assertTrue(environment.isStageOffered(stageId));
			environment.setStageOffer(stageId, false);
			assertFalse(environment.isStageOffered(stageId));

			environment.setStageOffer(stageId, true);
			assertTrue(environment.isStageOffered(stageId));
			environment.setStageOffer(stageId, false);
			assertFalse(environment.isStageOffered(stageId));
		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			// if the stage id is null
			assertModelException(() -> environment.setStageOffer(null, true), SimulationErrorType.NULL_STAGE_ID);
			// if the stage id is unknown
			assertModelException(() -> environment.setStageOffer(new StageId(-1), true), SimulationErrorType.UNKNOWN_STAGE_ID);
		});

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_2, testTime++, (environment) -> {
			// if invoker is not the owning materials producer component
			assertModelException(() -> environment.setStageOffer(new StageId(0), true), SimulationErrorType.COMPONENT_LACKS_PERMISSION);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#shiftBatchContent(BatchId, BatchId, double)}
	 */
	@Test
	@UnitTestMethod(name = "shiftBatchContent", args = { BatchId.class, BatchId.class, double.class })
	public void testShiftBatchContent() {
		/*
		 * Show that we shift content between stages
		 */

		final long seed = SEED_PROVIDER.getSeedValue(3);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			final BatchId batchId1 = environment.createBatch(TestMaterialId.MATERIAL_1, 10);
			final BatchId batchId2 = environment.createBatch(TestMaterialId.MATERIAL_1, 7);
			environment.shiftBatchContent(batchId1, batchId2, 5);
			assertEquals(5, environment.getBatchAmount(batchId1), EnvironmentSupport.COMPARISON_EPSILON);
			assertEquals(12, environment.getBatchAmount(batchId2), EnvironmentSupport.COMPARISON_EPSILON);
		});

		// precondition tests
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			final StageId stageId = environment.createStage();
			final BatchId batchId1 = environment.createBatch(TestMaterialId.MATERIAL_1, 10);
			final BatchId batchId2 = environment.createBatch(TestMaterialId.MATERIAL_1, 7);
			final BatchId batchId3 = environment.createBatch(TestMaterialId.MATERIAL_2, 7);
			final BatchId batchId4 = environment.createBatch(TestMaterialId.MATERIAL_1, Double.MAX_VALUE * 0.7);
			final BatchId batchId5 = environment.createBatch(TestMaterialId.MATERIAL_1, Double.MAX_VALUE * 0.7);

			// if the source batch id is null
			assertModelException(() -> environment.shiftBatchContent(null, batchId2, 5), SimulationErrorType.NULL_BATCH_ID);

			// if the destination batch id is null
			assertModelException(() -> environment.shiftBatchContent(batchId1, null, 5), SimulationErrorType.NULL_BATCH_ID);

			// if the source batch id is unknown
			assertModelException(() -> environment.shiftBatchContent(new BatchId(-1), batchId2, 5), SimulationErrorType.UNKNOWN_BATCH_ID);

			// if the destination batch id is unknown
			assertModelException(() -> environment.shiftBatchContent(batchId1, new BatchId(-1), 5), SimulationErrorType.UNKNOWN_BATCH_ID);

			// if the material ids of the batches are not equal
			assertModelException(() -> environment.shiftBatchContent(batchId1, batchId3, 5), SimulationErrorType.MATERIAL_TYPE_MISMATCH);

			// if the batches are not distinct
			assertModelException(() -> environment.shiftBatchContent(batchId1, batchId1, 5), SimulationErrorType.REFLEXIVE_BATCH_SHIFT);

			// if the source batch is part of an offered stage
			environment.moveBatchToStage(batchId1, stageId);
			environment.setStageOffer(stageId, true);
			assertModelException(() -> environment.shiftBatchContent(batchId1, batchId2, 5), SimulationErrorType.OFFERED_STAGE_UNALTERABLE);
			environment.setStageOffer(stageId, false);
			environment.moveBatchToInventory(batchId1);

			// if the destination batch is part of an offered stage
			environment.moveBatchToStage(batchId2, stageId);
			environment.setStageOffer(stageId, true);
			assertModelException(() -> environment.shiftBatchContent(batchId1, batchId2, 5), SimulationErrorType.OFFERED_STAGE_UNALTERABLE);
			environment.setStageOffer(stageId, false);
			environment.moveBatchToInventory(batchId2);

			// if the amount is negative
			assertModelException(() -> environment.shiftBatchContent(batchId1, batchId2, -5), SimulationErrorType.NEGATIVE_MATERIAL_AMOUNT);

			// if the amount exceeds the capacity of the source batch
			assertModelException(() -> environment.shiftBatchContent(batchId1, batchId2, 500), SimulationErrorType.INSUFFICIENT_MATERIAL_AVAILABLE);

			// if the amount is not finite
			assertModelException(() -> environment.shiftBatchContent(batchId1, batchId2, Double.POSITIVE_INFINITY), SimulationErrorType.NON_FINITE_MATERIAL_AMOUNT);
			assertModelException(() -> environment.shiftBatchContent(batchId1, batchId2, Double.NEGATIVE_INFINITY), SimulationErrorType.NON_FINITE_MATERIAL_AMOUNT);
			assertModelException(() -> environment.shiftBatchContent(batchId1, batchId2, Double.NaN), SimulationErrorType.NON_FINITE_MATERIAL_AMOUNT);

			// if the amount results in a non finite amount in the receiving
			// batch
			double batchAmount = environment.getBatchAmount(batchId4);
			assertModelException(() -> environment.shiftBatchContent(batchId4, batchId5, batchAmount), SimulationErrorType.MATERIAL_ARITHMETIC_EXCEPTION);
		});

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_2, testTime++, (environment) -> {
			// pick two batches in another materials producer that are of
			// material 1 and have at least one unit
			List<BatchId> foreignBatches = new ArrayList<>();
			final List<BatchId> inventoryBatches = environment.getInventoryBatches(TestMaterialsProducerId.MATERIALS_PRODUCER_1);
			for (final BatchId batchId : inventoryBatches) {
				if (!environment.getBatchStageId(batchId).isPresent()) {
					if (environment.getBatchMaterial(batchId).equals(TestMaterialId.MATERIAL_1)) {
						if (environment.getBatchAmount(batchId) > 0) {
							foreignBatches.add(batchId);
						}
					}
				}
				if (foreignBatches.size() == 2) {
					break;
				}
			}
			assertTrue(foreignBatches.size() >= 2);

			// create a local batch to work with of the appropriate material
			// type
			final BatchId localBatchId = environment.createBatch(TestMaterialId.MATERIAL_1, 10);

			// create two final variables to satisfy lambda requirements
			final BatchId foreignBatchId1 = foreignBatches.get(0);
			final BatchId foreignBatchId2 = foreignBatches.get(1);

			// if the batches are not owned by the same materials producer
			assertModelException(() -> environment.shiftBatchContent(foreignBatchId1, localBatchId, 1), SimulationErrorType.BATCH_SHIFT_WITH_MULTIPLE_OWNERS);
			assertModelException(() -> environment.shiftBatchContent(localBatchId, foreignBatchId1, 1), SimulationErrorType.BATCH_SHIFT_WITH_MULTIPLE_OWNERS);

			// if the invoking component is not the owner of both batches
			assertModelException(() -> environment.shiftBatchContent(foreignBatchId1, foreignBatchId2, 1), SimulationErrorType.COMPONENT_LACKS_PERMISSION);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#stageExists(StageId)}
	 */
	@Test
	@UnitTestMethod(name = "stageExists", args = { StageId.class })
	public void testStageExists() {
		/*
		 * Show that stages exist as expected after construction and after
		 * destruction
		 */

		final long seed = SEED_PROVIDER.getSeedValue(4);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			final StageId stageId1 = environment.createStage();
			final StageId stageId2 = environment.createStage();
			assertTrue(environment.stageExists(stageId1));
			assertTrue(environment.stageExists(stageId2));
			environment.destroyStage(stageId1, false);
			assertFalse(environment.stageExists(stageId1));
			assertTrue(environment.stageExists(stageId2));
			environment.destroyStage(stageId2, false);
			assertFalse(environment.stageExists(stageId1));
			assertFalse(environment.stageExists(stageId2));
		});

		// no precondition tests

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests
	 * {@link EnvironmentImpl#transferOfferedStageToMaterialsProducer(StageId, MaterialsProducerId)}
	 */
	@Test
	@UnitTestMethod(name = "transferOfferedStageToMaterialsProducer", args = { StageId.class, MaterialsProducerId.class })
	public void testTransferOfferedStageToMaterialsProducer() {
		/*
		 * Show that we transfer an offered stage from various component actors
		 */
		final long seed = SEED_PROVIDER.getSeedValue(5);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		/*
		 * producer 1 offers and then transfers to producer 2
		 */
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			final BatchId batchId1 = environment.createBatch(TestMaterialId.MATERIAL_1, 10);
			final BatchId batchId2 = environment.createBatch(TestMaterialId.MATERIAL_2, 7);
			final StageId stageId = environment.createStage();
			environment.moveBatchToStage(batchId1, stageId);
			environment.moveBatchToStage(batchId2, stageId);
			environment.setStageOffer(stageId, true);
			environment.transferOfferedStageToMaterialsProducer(stageId, TestMaterialsProducerId.MATERIALS_PRODUCER_2);

			// the batches and stage should still be together under the
			// ownership of MATERIALS_PRODUCER_2 and the stage should no
			// longer be offered
			assertEquals(stageId, environment.getBatchStageId(batchId1).get());
			assertEquals(stageId, environment.getBatchStageId(batchId2).get());
			assertEquals(TestMaterialsProducerId.MATERIALS_PRODUCER_2, environment.getBatchProducer(batchId1));
			assertEquals(TestMaterialsProducerId.MATERIALS_PRODUCER_2, environment.getBatchProducer(batchId2));
			assertEquals(TestMaterialsProducerId.MATERIALS_PRODUCER_2, environment.getStageProducer(stageId));
			assertFalse(environment.isStageOffered(stageId));
		});

		/*
		 * producer 1 offers
		 */
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			final BatchId batchId1 = environment.createBatch(TestMaterialId.MATERIAL_1, 10);
			final BatchId batchId2 = environment.createBatch(TestMaterialId.MATERIAL_2, 7);
			final StageId stageId = environment.createStage();
			environment.moveBatchToStage(batchId1, stageId);
			environment.moveBatchToStage(batchId2, stageId);
			environment.setStageOffer(stageId, true);
		});

		/*
		 * producer 2 transfers producer 1's offer to itself
		 */
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_2, testTime++, (environment) -> {
			final List<StageId> offeredStages = environment.getOfferedStages(TestMaterialsProducerId.MATERIALS_PRODUCER_1);
			assertTrue(offeredStages.size() > 0);
			final StageId stageId = offeredStages.get(0);
			environment.transferOfferedStageToMaterialsProducer(stageId, TestMaterialsProducerId.MATERIALS_PRODUCER_2);

			// the batches and stage should still be together under the
			// ownership of MATERIALS_PRODUCER_2 and the stage should no
			// longer be offered
			for (final BatchId batchId : environment.getStageBatches(stageId)) {
				assertEquals(stageId, environment.getBatchStageId(batchId).get());
				assertEquals(TestMaterialsProducerId.MATERIALS_PRODUCER_2, environment.getBatchProducer(batchId));
			}
			assertEquals(TestMaterialsProducerId.MATERIALS_PRODUCER_2, environment.getStageProducer(stageId));
			assertFalse(environment.isStageOffered(stageId));
		});

		/*
		 * producer 1 offers
		 */
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			final BatchId batchId1 = environment.createBatch(TestMaterialId.MATERIAL_1, 10);
			final BatchId batchId2 = environment.createBatch(TestMaterialId.MATERIAL_2, 7);
			final StageId stageId = environment.createStage();
			environment.moveBatchToStage(batchId1, stageId);
			environment.moveBatchToStage(batchId2, stageId);
			environment.setStageOffer(stageId, true);
		});

		/*
		 * global 1 transfers producer 1's offer to itself
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			final List<StageId> offeredStages = environment.getOfferedStages(TestMaterialsProducerId.MATERIALS_PRODUCER_1);
			assertTrue(offeredStages.size() > 0);
			final StageId stageId = offeredStages.get(0);
			environment.transferOfferedStageToMaterialsProducer(stageId, TestMaterialsProducerId.MATERIALS_PRODUCER_2);

			// the batches and stage should still be together under the
			// ownership of MATERIALS_PRODUCER_2 and the stage should no
			// longer be offered
			for (final BatchId batchId : environment.getStageBatches(stageId)) {
				assertEquals(stageId, environment.getBatchStageId(batchId).get());
				assertEquals(TestMaterialsProducerId.MATERIALS_PRODUCER_2, environment.getBatchProducer(batchId));
			}
			assertEquals(TestMaterialsProducerId.MATERIALS_PRODUCER_2, environment.getStageProducer(stageId));
			assertFalse(environment.isStageOffered(stageId));
		});

		// precondition tests
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			final BatchId batchId1 = environment.createBatch(TestMaterialId.MATERIAL_1, 10);
			final BatchId batchId2 = environment.createBatch(TestMaterialId.MATERIAL_2, 7);
			final StageId stageId = environment.createStage();
			environment.moveBatchToStage(batchId1, stageId);
			environment.moveBatchToStage(batchId2, stageId);
			environment.setStageOffer(stageId, true);

			// if stage id is null
			assertModelException(() -> environment.transferOfferedStageToMaterialsProducer(null, TestMaterialsProducerId.MATERIALS_PRODUCER_2), SimulationErrorType.NULL_STAGE_ID);
			// if stage id is unknown
			assertModelException(() -> environment.transferOfferedStageToMaterialsProducer(new StageId(-1), TestMaterialsProducerId.MATERIALS_PRODUCER_2), SimulationErrorType.UNKNOWN_STAGE_ID);
			// if stage is not in the offered state
			environment.setStageOffer(stageId, false);
			assertModelException(() -> environment.transferOfferedStageToMaterialsProducer(stageId, TestMaterialsProducerId.MATERIALS_PRODUCER_2),
					SimulationErrorType.UNOFFERED_STAGE_NOT_TRANSFERABLE);
			environment.setStageOffer(stageId, true);
			// if the materials producer id is null
			assertModelException(() -> environment.transferOfferedStageToMaterialsProducer(stageId, null), SimulationErrorType.NULL_MATERIALS_PRODUCER_ID);
			// if the materials producer is unknown
			assertModelException(() -> environment.transferOfferedStageToMaterialsProducer(stageId, TestMaterialsProducerId.getUnknownMaterialsProducerId()),
					SimulationErrorType.UNKNOWN_MATERIALS_PRODUCER_ID);
			// if the material producer is the invoking materials
			// producer
			assertModelException(() -> environment.transferOfferedStageToMaterialsProducer(stageId, TestMaterialsProducerId.MATERIALS_PRODUCER_1), SimulationErrorType.REFLEXIVE_STAGE_TRANSFER);
		});

		taskPlanContainer.addTaskPlan(TestRegionId.REGION_1, testTime++, (environment) -> {
			// find the offered stage from producer 2

			final List<StageId> offeredStages = environment.getOfferedStages(TestMaterialsProducerId.MATERIALS_PRODUCER_1);
			assertTrue(offeredStages.size() > 0);
			final StageId stageId = offeredStages.get(0);

			// if invoker is not a materials producer component or a
			// global component
			assertModelException(() -> environment.transferOfferedStageToMaterialsProducer(stageId, TestMaterialsProducerId.MATERIALS_PRODUCER_3), SimulationErrorType.COMPONENT_LACKS_PERMISSION);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests
	 * {@link EnvironmentImpl#transferProducedResourceToRegion(MaterialsProducerId, ResourceId, RegionId, long)}
	 */
	@Test
	@UnitTestMethod(name = "transferProducedResourceToRegion", args = { MaterialsProducerId.class, ResourceId.class, RegionId.class, long.class })
	public void testTransferProducedResourceToRegion() {
		/*
		 * Show that we transfer a resource to a region
		 */
		final long seed = SEED_PROVIDER.getSeedValue(6);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		/*
		 * The owning producer can transfer the resource
		 */
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			long expectedResourceLevel = environment.getRegionResourceLevel(TestRegionId.REGION_1, TestResourceId.RESOURCE1);
			assertTrue(expectedResourceLevel == 0);
			final BatchId batchId1 = environment.createBatch(TestMaterialId.MATERIAL_1, 10);
			final BatchId batchId2 = environment.createBatch(TestMaterialId.MATERIAL_2, 7);
			final StageId stageId = environment.createStage();
			environment.moveBatchToStage(batchId1, stageId);
			environment.moveBatchToStage(batchId2, stageId);
			environment.convertStageToResource(stageId, TestResourceId.RESOURCE1, 300);
			assertFalse(environment.stageExists(stageId));
			assertFalse(environment.batchExists(batchId1));
			assertFalse(environment.batchExists(batchId2));
			environment.transferProducedResourceToRegion(TestMaterialsProducerId.MATERIALS_PRODUCER_1, TestResourceId.RESOURCE1, TestRegionId.REGION_1, 100);
			expectedResourceLevel += 100;
			assertEquals(expectedResourceLevel, environment.getRegionResourceLevel(TestRegionId.REGION_1, TestResourceId.RESOURCE1));
		});

		/*
		 * The receiving region can transfer the resource
		 */
		taskPlanContainer.addTaskPlan(TestRegionId.REGION_1, testTime++, (environment) -> {
			long expectedResourceLevel = environment.getRegionResourceLevel(TestRegionId.REGION_1, TestResourceId.RESOURCE1);
			environment.transferProducedResourceToRegion(TestMaterialsProducerId.MATERIALS_PRODUCER_1, TestResourceId.RESOURCE1, TestRegionId.REGION_1, 10);
			expectedResourceLevel += 10;
			assertEquals(expectedResourceLevel, environment.getRegionResourceLevel(TestRegionId.REGION_1, TestResourceId.RESOURCE1));
		});

		/*
		 * A global component can transfer the resource
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			long expectedResourceLevel = environment.getRegionResourceLevel(TestRegionId.REGION_1, TestResourceId.RESOURCE1);
			environment.transferProducedResourceToRegion(TestMaterialsProducerId.MATERIALS_PRODUCER_1, TestResourceId.RESOURCE1, TestRegionId.REGION_1, 10);
			expectedResourceLevel += 10;
			assertEquals(expectedResourceLevel, environment.getRegionResourceLevel(TestRegionId.REGION_1, TestResourceId.RESOURCE1));
		});

		// precondition tests
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			// from the previous test, we have that region 1 still has at
			// least 180 units of resource 1 and thus the 100 unit for
			// transfer is allowed

			// if region id is null
			assertModelException(() -> environment.transferProducedResourceToRegion(TestMaterialsProducerId.MATERIALS_PRODUCER_1, TestResourceId.RESOURCE1, null, 100),
					SimulationErrorType.NULL_REGION_ID);
			// if region id is unknown
			assertModelException(() -> environment.transferProducedResourceToRegion(TestMaterialsProducerId.MATERIALS_PRODUCER_1, TestResourceId.RESOURCE1, TestRegionId.getUnknownRegionId(), 100),
					SimulationErrorType.UNKNOWN_REGION_ID);
			// if resource id is null
			assertModelException(() -> environment.transferProducedResourceToRegion(TestMaterialsProducerId.MATERIALS_PRODUCER_1, null, TestRegionId.REGION_1, 100),
					SimulationErrorType.NULL_RESOURCE_ID);
			// if resource id is unknown
			assertModelException(() -> environment.transferProducedResourceToRegion(TestMaterialsProducerId.MATERIALS_PRODUCER_1, TestResourceId.getUnknownResourceId(), TestRegionId.REGION_1, 100),
					SimulationErrorType.UNKNOWN_RESOURCE_ID);
			// if the amount is negative
			assertModelException(() -> environment.transferProducedResourceToRegion(TestMaterialsProducerId.MATERIALS_PRODUCER_1, TestResourceId.RESOURCE1, TestRegionId.REGION_1, -100),
					SimulationErrorType.NEGATIVE_RESOURCE_AMOUNT);
			// if the amount is in excess of the the resource level of the
			// materials producer
			assertModelException(() -> environment.transferProducedResourceToRegion(TestMaterialsProducerId.MATERIALS_PRODUCER_1, TestResourceId.RESOURCE1, TestRegionId.REGION_1, 1000),
					SimulationErrorType.INSUFFICIENT_RESOURCES_AVAILABLE);

			// if the amount results in an overflow of the corresponding
			// region's inventory level
			final BatchId batchId3 = environment.createBatch(TestMaterialId.MATERIAL_3, 1);
			final StageId stageId3 = environment.createStage();
			environment.moveBatchToStage(batchId3, stageId3);
			environment.convertStageToResource(stageId3, TestResourceId.RESOURCE3, Long.MAX_VALUE - 10000);
			environment.transferProducedResourceToRegion(TestMaterialsProducerId.MATERIALS_PRODUCER_1, TestResourceId.RESOURCE3, TestRegionId.REGION_1, Long.MAX_VALUE - 10000);

			final BatchId batchId4 = environment.createBatch(TestMaterialId.MATERIAL_3, 1);
			final StageId stageId4 = environment.createStage();
			environment.moveBatchToStage(batchId4, stageId4);
			environment.convertStageToResource(stageId4, TestResourceId.RESOURCE3, 20000);
			assertModelException(() -> environment.transferProducedResourceToRegion(TestMaterialsProducerId.MATERIALS_PRODUCER_1, TestResourceId.RESOURCE3, TestRegionId.REGION_1, 20000),
					SimulationErrorType.RESOURCE_ARITHMETIC_EXCEPTION);
		});

		/*
		 * a non receiving region cannot transfer the resource
		 */
		taskPlanContainer.addTaskPlan(TestRegionId.REGION_2, testTime++, (environment) -> {
			// if invoker is not the owning materials
			// producer component, the receiving region or a global
			// component
			assertModelException(() -> environment.transferProducedResourceToRegion(TestMaterialsProducerId.MATERIALS_PRODUCER_1, TestResourceId.RESOURCE1, TestRegionId.REGION_1, 100),
					SimulationErrorType.COMPONENT_LACKS_PERMISSION);
		});

		/*
		 * a compartment cannot transfer the resource
		 */
		taskPlanContainer.addTaskPlan(TestCompartmentId.COMPARTMENT_1, testTime++, (environment) -> {
			// if invoker is not the owning materials
			// producer component, the receiving region or a global
			// component
			assertModelException(() -> environment.transferProducedResourceToRegion(TestMaterialsProducerId.MATERIALS_PRODUCER_1, TestResourceId.RESOURCE1, TestRegionId.REGION_1, 100),
					SimulationErrorType.COMPONENT_LACKS_PERMISSION);
		});

		/*
		 * a non-owning materials producer cannot transfer the resource
		 */
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_3, testTime++, (environment) -> {
			// if invoker is not the owning materials
			// producer component, the receiving region or a global
			// component
			assertModelException(() -> environment.transferProducedResourceToRegion(TestMaterialsProducerId.MATERIALS_PRODUCER_1, TestResourceId.RESOURCE1, TestRegionId.REGION_1, 100),
					SimulationErrorType.COMPONENT_LACKS_PERMISSION);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests
	 * {@link EnvironmentImpl#transferResourceBetweenRegions(ResourceId, RegionId, RegionId, long)}
	 */
	@Test
	@UnitTestMethod(name = "transferResourceBetweenRegions", args = { ResourceId.class, RegionId.class, RegionId.class, long.class})
	public void testTransferResourceBetweenRegions() {
		/*
		 * For each pair of regions (distinct from one another) and each
		 * resource type transfer a random amount of resource from one region to
		 * another and then show that the resulting levels in both regions are
		 * correct.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(7);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			for (final TestResourceId testResourceId : TestResourceId.values()) {
				for (final TestRegionId sourceRegionId : TestRegionId.values()) {

					for (final TestRegionId destinationRegionId : TestRegionId.values()) {
						if (sourceRegionId == destinationRegionId) {
							continue;
						}

						/*
						 * Add a small amount to the source region to make sure
						 * we have a positive level and give us some breathing
						 * room to generate a random amount to transfer
						 */

						environment.addResourceToRegion(testResourceId, sourceRegionId, 100);
						final long sourceLevel = environment.getRegionResourceLevel(sourceRegionId, testResourceId);
						final long destinationLevel = environment.getRegionResourceLevel(destinationRegionId, testResourceId);

						// determine an amount to transfer that is positive
						final int transferAmount = environment.getRandomGenerator().nextInt((int) sourceLevel) + 1;

						// make the transfer
						environment.transferResourceBetweenRegions(testResourceId, sourceRegionId, destinationRegionId, transferAmount);

						// test that the levels for both regions meet our
						// expectations
						final long expectedSourceLevel = sourceLevel - transferAmount;
						final long actualSourceLevel = environment.getRegionResourceLevel(sourceRegionId, testResourceId);
						assertEquals(expectedSourceLevel, actualSourceLevel);

						final long expectedDestinationLevel = destinationLevel + transferAmount;
						final long actualDestinationLevel = environment.getRegionResourceLevel(destinationRegionId, testResourceId);
						assertEquals(expectedDestinationLevel, actualDestinationLevel);

					}
				}
			}
		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// make sure there is sufficient resource in region 1
			final long amount = 100;
			environment.addResourceToRegion(TestResourceId.RESOURCE1, TestRegionId.REGION_1, amount);
			final long currentLevel = environment.getRegionResourceLevel(TestRegionId.REGION_1, TestResourceId.RESOURCE1);

			// if the source region id is null
			assertModelException(() -> environment.transferResourceBetweenRegions(TestResourceId.RESOURCE1, null, TestRegionId.REGION_2, amount), SimulationErrorType.NULL_REGION_ID);

			// if the source region id is unknown
			assertModelException(() -> environment.transferResourceBetweenRegions(TestResourceId.RESOURCE1, TestRegionId.getUnknownRegionId(), TestRegionId.REGION_2, amount),
					SimulationErrorType.UNKNOWN_REGION_ID);

			// if the destination region id is null
			assertModelException(() -> environment.transferResourceBetweenRegions(TestResourceId.RESOURCE1, TestRegionId.REGION_1, null, amount), SimulationErrorType.NULL_REGION_ID);

			// if the destination region id is unknown
			assertModelException(() -> environment.transferResourceBetweenRegions(TestResourceId.RESOURCE1, TestRegionId.REGION_1, TestRegionId.getUnknownRegionId(), amount),
					SimulationErrorType.UNKNOWN_REGION_ID);

			// if the source region id and the destination region are
			// the same
			assertModelException(() -> environment.transferResourceBetweenRegions(TestResourceId.RESOURCE1, TestRegionId.REGION_1, TestRegionId.REGION_1, amount),
					SimulationErrorType.REFLEXIVE_RESOURCE_TRANSFER);

			// if the resource id is null
			assertModelException(() -> environment.transferResourceBetweenRegions(null, TestRegionId.REGION_1, TestRegionId.REGION_2, amount), SimulationErrorType.NULL_RESOURCE_ID);

			// if the resource id is unknown
			assertModelException(() -> environment.transferResourceBetweenRegions(TestResourceId.getUnknownResourceId(), TestRegionId.REGION_1, TestRegionId.REGION_2, amount),
					SimulationErrorType.UNKNOWN_RESOURCE_ID);

			// if the amount is negative
			assertModelException(() -> environment.transferResourceBetweenRegions(TestResourceId.RESOURCE1, TestRegionId.REGION_1, TestRegionId.REGION_2, -1),
					SimulationErrorType.NEGATIVE_RESOURCE_AMOUNT);

			// if the amount is in excess of the amount the source
			// region possesses
			assertModelException(() -> environment.transferResourceBetweenRegions(TestResourceId.RESOURCE1, TestRegionId.REGION_1, TestRegionId.REGION_2, currentLevel + 1),
					SimulationErrorType.INSUFFICIENT_RESOURCES_AVAILABLE);

			// if the amount results in an overflow of the corresponding
			// destination region's inventory level

			// max out region2's resource level
			long regionResourceLevel = environment.getRegionResourceLevel(TestRegionId.REGION_2, TestResourceId.RESOURCE2);
			environment.addResourceToRegion(TestResourceId.RESOURCE2, TestRegionId.REGION_2, Long.MAX_VALUE - regionResourceLevel);
			// ensure that region1 has a positive level
			environment.addResourceToRegion(TestResourceId.RESOURCE2, TestRegionId.REGION_1, 100);

			// transfer some of region1's resource to region2
			assertModelException(() -> environment.transferResourceBetweenRegions(TestResourceId.RESOURCE2, TestRegionId.REGION_1, TestRegionId.REGION_2, 100),
					SimulationErrorType.RESOURCE_ARITHMETIC_EXCEPTION);

		});

		taskPlanContainer.addTaskPlan(TestRegionId.REGION_1, testTime++, (environment) -> {
			// make sure there is sufficient resource in region 1
			final long amount = 100;
			environment.addResourceToRegion(TestResourceId.RESOURCE1, TestRegionId.REGION_1, amount);

			// if invoker is not a global component
			assertModelException(() -> environment.transferResourceBetweenRegions(TestResourceId.RESOURCE1, TestRegionId.REGION_1, TestRegionId.REGION_2, amount),
					SimulationErrorType.COMPONENT_LACKS_PERMISSION);
		});

		taskPlanContainer.addTaskPlan(TestCompartmentId.COMPARTMENT_1, testTime++, (environment) -> {
			// if invoker is not a global component
			assertModelException(() -> environment.transferResourceBetweenRegions(TestResourceId.RESOURCE1, TestRegionId.REGION_1, TestRegionId.REGION_2, 0),
					SimulationErrorType.COMPONENT_LACKS_PERMISSION);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests
	 * {@link EnvironmentImpl#transferResourceFromPerson(ResourceId, PersonId, long)}
	 */
	@Test
	@UnitTestMethod(name = "transferResourceFromPerson", args = { ResourceId.class, PersonId.class, long.class})
	public void testTransferResourceFromPerson() {
		/*
		 * For each person in each region and each resource type, transfer a
		 * random amount from the person back to their region. Show that the
		 * resulting levels are what we expect.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(8);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// we assume that there are people in every region
			for (final TestRegionId testRegionId : TestRegionId.values()) {
				assertTrue(environment.getRegionPopulationCount(testRegionId) > 0);
			}
			// set the max amount we will take from person
			final long maxAmount = 100;

			/*
			 * first, make sure that we have enough resource on each person
			 */
			for (final TestRegionId testRegionId : TestRegionId.values()) {
				final List<PersonId> peopleInRegion = environment.getPeopleInRegion(testRegionId);

				for (final TestResourceId testResourceId : TestResourceId.values()) {
					for (final PersonId personId : peopleInRegion) {
						final long currentLevel = environment.getPersonResourceLevel(personId, testResourceId);
						final long amountToAdd = maxAmount - currentLevel;
						if (amountToAdd > 0) {
							environment.addResourceToRegion(testResourceId, testRegionId, amountToAdd);
							environment.transferResourceToPerson(testResourceId, personId, amountToAdd);
						}
					}
				}
			}

			/*
			 * Next, transfer random amounts from each person back to their
			 * region, testing the levels as we go.
			 */
			for (final TestRegionId testRegionId : TestRegionId.values()) {
				final List<PersonId> peopleInRegion = environment.getPeopleInRegion(testRegionId);

				for (final TestResourceId testResourceId : TestResourceId.values()) {
					for (final PersonId personId : peopleInRegion) {
						final long currentRegionResourceLevel = environment.getRegionResourceLevel(testRegionId, testResourceId);
						final long currentPersonResourceLevel = environment.getPersonResourceLevel(personId, testResourceId);

						// determine the amount to transfer
						final long amountToTransfer = environment.getRandomGenerator().nextInt((int) maxAmount) + 1;

						// transfer the resource
						environment.transferResourceFromPerson(testResourceId, personId, amountToTransfer);

						// test the levels
						final long expectedRegionResourceLevel = currentRegionResourceLevel + amountToTransfer;
						final long actualRegionResourceLevel = environment.getRegionResourceLevel(testRegionId, testResourceId);
						assertEquals(expectedRegionResourceLevel, actualRegionResourceLevel);

						final long expectedPersonResourceLevel = currentPersonResourceLevel - amountToTransfer;
						final long actualPersonResourceLevel = environment.getPersonResourceLevel(personId, testResourceId);
						assertEquals(expectedPersonResourceLevel, actualPersonResourceLevel);

					}
				}
			}
		});
		/*
		 * Precondition tests
		 */

		/*
		 * We specify a fixed positive amount to transfer from a person to be
		 * used across multiple tests where there is some entanglement between
		 * test states.
		 */
		final long amount = 100;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			/*
			 * ensure that the person has a positive amount to transfer
			 */
			final Object key = new Object();
			final Filter filter =

					compartment(TestCompartmentId.COMPARTMENT_1).and(region(TestRegionId.REGION_1));

			environment.addPopulationIndex(filter, key);
			final PersonId personId = environment.getRandomIndexedPerson(key).get();

			environment.addResourceToRegion(TestResourceId.RESOURCE1, TestRegionId.REGION_1, amount);
			environment.transferResourceToPerson(TestResourceId.RESOURCE1, personId, amount);

			final long currentPersonLevel = environment.getPersonResourceLevel(personId, TestResourceId.RESOURCE1);

			// if the person id is null
			assertModelException(() -> environment.transferResourceFromPerson(TestResourceId.RESOURCE1, null, amount), SimulationErrorType.NULL_PERSON_ID);
			// if the person id is unknown
			assertModelException(() -> environment.transferResourceFromPerson(TestResourceId.RESOURCE1, new PersonId(-1), amount), SimulationErrorType.UNKNOWN_PERSON_ID);
			// if the resource id is null
			assertModelException(() -> environment.transferResourceFromPerson(null, personId, amount), SimulationErrorType.NULL_RESOURCE_ID);
			// if the resource id is unknown
			assertModelException(() -> environment.transferResourceFromPerson(TestResourceId.getUnknownResourceId(), personId, amount), SimulationErrorType.UNKNOWN_RESOURCE_ID);
			// if the amount is negative
			assertModelException(() -> environment.transferResourceFromPerson(TestResourceId.RESOURCE1, personId, -1), SimulationErrorType.NEGATIVE_RESOURCE_AMOUNT);
			// if the amount is in excess of the amount the person
			// possesses
			assertModelException(() -> environment.transferResourceFromPerson(TestResourceId.RESOURCE1, personId, currentPersonLevel + 1), SimulationErrorType.INSUFFICIENT_RESOURCES_AVAILABLE);

			// if the amount results in an overflow of the corresponding
			// region's inventory level

			// set the person's resource level to zero
			long personResourceLevel = environment.getPersonResourceLevel(personId, TestResourceId.RESOURCE2);
			environment.removeResourceFromPerson(TestResourceId.RESOURCE2, personId, personResourceLevel);
			// max out the region's inventory
			long regionResourceLevel = environment.getRegionResourceLevel(TestRegionId.REGION_1, TestResourceId.RESOURCE2);
			environment.addResourceToRegion(TestResourceId.RESOURCE2, TestRegionId.REGION_1, Long.MAX_VALUE - regionResourceLevel);
			// transfer it to the person
			environment.transferResourceToPerson(TestResourceId.RESOURCE2, personId, Long.MAX_VALUE);
			// add a bit more to the region
			environment.addResourceToRegion(TestResourceId.RESOURCE2, TestRegionId.REGION_1, 50);
			// transfer the large amount back to the region
			assertModelException(() -> environment.transferResourceFromPerson(TestResourceId.RESOURCE2, personId, Long.MAX_VALUE), SimulationErrorType.RESOURCE_ARITHMETIC_EXCEPTION);

			environment.removePopulationIndex(key);
		});

		/*
		 * This test plan exists to ensure the next two tests will have
		 * sufficient resource levels
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			/*
			 * ensure that every person has a positive amount to transfer
			 */
			for (final PersonId personId : environment.getPeople()) {
				final RegionId regionId = environment.getPersonRegion(personId);
				environment.addResourceToRegion(TestResourceId.RESOURCE1, regionId, amount);
				environment.transferResourceToPerson(TestResourceId.RESOURCE1, personId, amount);
			}
		});

		taskPlanContainer.addTaskPlan(TestRegionId.REGION_2, testTime++, (environment) -> {
			/*
			 * from above we know that there should be sufficient resource
			 */
			final Object key = new Object();
			final Filter filter = compartment(TestCompartmentId.COMPARTMENT_1).and(region(TestRegionId.REGION_1));

			environment.addPopulationIndex(filter, key);
			final PersonId personId = environment.getRandomIndexedPerson(key).get();

			assertTrue(environment.getPersonResourceLevel(personId, TestResourceId.RESOURCE1) >= amount);

			// if invoker is not a global component , the person's region
			// or the person's compartment
			assertModelException(() -> environment.transferResourceFromPerson(TestResourceId.RESOURCE1, personId, amount), SimulationErrorType.COMPONENT_LACKS_PERMISSION);

			environment.removePopulationIndex(key);
		});

		taskPlanContainer.addTaskPlan(TestCompartmentId.COMPARTMENT_2, testTime++, (environment) -> {
			/*
			 * from above we know that there should be sufficient resource
			 */
			final Object key = new Object();
			final Filter filter = compartment(TestCompartmentId.COMPARTMENT_1).and(region(TestRegionId.REGION_1));

			environment.addPopulationIndex(filter, key);
			final PersonId personId = environment.getRandomIndexedPerson(key).get();

			assertTrue(environment.getPersonResourceLevel(personId, TestResourceId.RESOURCE1) >= amount);

			// if invoker is not a global component , the person's region
			// or the person's compartment
			assertModelException(() -> environment.transferResourceFromPerson(TestResourceId.RESOURCE1, personId, amount), SimulationErrorType.COMPONENT_LACKS_PERMISSION);

			environment.removePopulationIndex(key);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

}
