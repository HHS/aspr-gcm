package gcm.automated;

import static gcm.automated.support.EnvironmentSupport.addStandardComponentsAndTypes;
import static gcm.automated.support.EnvironmentSupport.addStandardPeople;
import static gcm.automated.support.EnvironmentSupport.addStandardPropertyDefinitions;
import static gcm.automated.support.EnvironmentSupport.addStandardTrackingAndScenarioId;
import static gcm.automated.support.EnvironmentSupport.addTaskPlanContainer;
import static gcm.automated.support.EnvironmentSupport.assertAllPlansExecuted;
import static gcm.automated.support.EnvironmentSupport.getRandomGenerator;
import static gcm.automated.support.EnvironmentSupport.getReplication;
import static gcm.automated.support.ExceptionAssertion.assertModelException;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Optional;

import org.apache.commons.math3.random.RandomGenerator;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import gcm.automated.support.EnvironmentSupport;
import gcm.automated.support.EnvironmentSupport.PropertyAssignmentPolicy;
import gcm.automated.support.SeedProvider;
import gcm.automated.support.TaskPlanContainer;
import gcm.automated.support.TestGlobalComponentId;
import gcm.automated.support.TestPersonPropertyId;
import gcm.manual.demo.identifiers.RandomGeneratorId;
import gcm.replication.Replication;
import gcm.scenario.PersonId;
import gcm.scenario.PersonPropertyId;
import gcm.scenario.PropertyDefinition;
import gcm.scenario.Scenario;
import gcm.scenario.ScenarioBuilder;
import gcm.scenario.UnstructuredScenarioBuilder;
import gcm.simulation.EnvironmentImpl;
import gcm.simulation.Equality;
import gcm.simulation.Filter;
import gcm.simulation.Simulation;
import gcm.simulation.SimulationErrorType;
import gcm.util.annotations.UnitTest;

@UnitTest(target = EnvironmentImpl.class)

public class AT_EnvironmentImpl_24 {

	private static SeedProvider SEED_PROVIDER;

	@BeforeClass
	public static void beforeClass() {
		SEED_PROVIDER = new SeedProvider(EnvironmentSupport.getMetaSeed(24));
	}

	/**
	 * Internal test(not part of public tests) to show that there are no large
	 * gaps in the seed cases generated by the SeedProvider.
	 */
	@AfterClass
	public static void afterClass() {
		//		System.out.println(AT_EnvironmentImpl_24.class.getSimpleName() + " " + SEED_PROVIDER.generateUnusedSeedReport());
	}

	/**
	 * Tests
	 * {@link EnvironmentImpl#getPersonCountForPropertyValue(PersonPropertyId, Object)}
	 */
	@Test
	public void testGetPersonCountForPropertyValue() {

		final long seed = SEED_PROVIDER.getSeedValue(0);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 30);
		PersonPropertyId personPropertyId = TestPersonPropertyId.PERSON_PROPERTY_1;
		PropertyDefinition propertyDefinition = PropertyDefinition.builder().setType(Integer.class).setDefaultValue(0).build();
		Map<Object, PropertyDefinition> forcedPropertyDefinitions = new LinkedHashMap<>();
		forcedPropertyDefinitions.put(personPropertyId, propertyDefinition);
		addStandardPropertyDefinitions(scenarioBuilder, forcedPropertyDefinitions, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			assert (environment.getPopulationCount() >= 30);

			for (int i = 0; i < 10; i++) {
				PersonId personId = new PersonId(i);
				environment.setPersonPropertyValue(personId, personPropertyId, 30);
			}

			for (int i = 0; i < 10; i++) {
				PersonId personId = new PersonId(i + 10);
				environment.setPersonPropertyValue(personId, personPropertyId, 40);
			}

			for (int i = 0; i < 10; i++) {
				PersonId personId = new PersonId(i + 20);
				environment.setPersonPropertyValue(personId, personPropertyId, 50);
			}

			assertEquals(10, environment.getPersonCountForPropertyValue(personPropertyId, 30));
			assertEquals(10, environment.getPersonCountForPropertyValue(personPropertyId, 40));
			assertEquals(10, environment.getPersonCountForPropertyValue(personPropertyId, 50));
		});

		// precondition tests
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			PersonPropertyId unknownPersonPropertyId = TestPersonPropertyId.getUnknownPersonPropertyId();

			// if the property id is null
			assertModelException(() -> environment.getPersonCountForPropertyValue(null, 30), SimulationErrorType.NULL_PERSON_PROPERTY_ID);

			// if the property id is unknown
			assertModelException(() -> environment.getPersonCountForPropertyValue(unknownPersonPropertyId, 30), SimulationErrorType.UNKNOWN_PERSON_PROPERTY_ID);

			// if the property value is null
			assertModelException(() -> environment.getPersonCountForPropertyValue(personPropertyId, null), SimulationErrorType.NULL_PERSON_PROPERTY_VALUE);

			// if the property value is not compatible with the property
			// definition
			assertModelException(() -> environment.getPersonCountForPropertyValue(personPropertyId, "bad value"), SimulationErrorType.INCOMPATIBLE_VALUE);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests
	 * {@link EnvironmentImpl#getRandomIndexedPersonFromGenerator(Object,RandomNumberGeneratorId)}
	 */
	@Test
	public void testGetRandomIndexedPersonFromGenerator() {

		final long seed = SEED_PROVIDER.getSeedValue(1);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 30);
		PersonPropertyId personPropertyId = TestPersonPropertyId.PERSON_PROPERTY_1;
		PropertyDefinition propertyDefinition = PropertyDefinition.builder().setType(Integer.class).setDefaultValue(0).build();
		Map<Object, PropertyDefinition> forcedPropertyDefinitions = new LinkedHashMap<>();
		forcedPropertyDefinitions.put(personPropertyId, propertyDefinition);
		addStandardPropertyDefinitions(scenarioBuilder, forcedPropertyDefinitions, PropertyAssignmentPolicy.RANDOM, randomGenerator);
		scenarioBuilder.addRandomNumberGeneratorId(RandomGeneratorId.BLITZEN);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		Object key30 = new Object();
		Object key40 = new Object();
		Object key50 = new Object();
		

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			assert (environment.getPopulationCount() >= 30);

			for (int i = 0; i < 10; i++) {
				PersonId personId = new PersonId(i);
				environment.setPersonPropertyValue(personId, personPropertyId, 30);
			}

			for (int i = 0; i < 10; i++) {
				PersonId personId = new PersonId(i + 10);
				environment.setPersonPropertyValue(personId, personPropertyId, 40);
			}

			for (int i = 0; i < 10; i++) {
				PersonId personId = new PersonId(i + 20);
				environment.setPersonPropertyValue(personId, personPropertyId, 50);
			}

			environment.addPopulationIndex(Filter.property(personPropertyId, Equality.EQUAL, 30), key30);
			environment.addPopulationIndex(Filter.property(personPropertyId, Equality.EQUAL, 40), key40);
			environment.addPopulationIndex(Filter.property(personPropertyId, Equality.EQUAL, 50), key50);

			for (int i = 0; i < 100; i++) {
				Optional<PersonId> personIdOptional = environment.getRandomIndexedPersonFromGenerator(key30, RandomGeneratorId.BLITZEN);
				assertTrue(personIdOptional.isPresent());
				PersonId personId = personIdOptional.get();
				assertTrue(personId.getValue()>=0);
				assertTrue(personId.getValue()<10);				
			}
			for (int i = 0; i < 100; i++) {
				Optional<PersonId> personIdOptional = environment.getRandomIndexedPersonFromGenerator(key40, RandomGeneratorId.BLITZEN);
				assertTrue(personIdOptional.isPresent());
				PersonId personId = personIdOptional.get();
				assertTrue(personId.getValue()>=10);
				assertTrue(personId.getValue()<20);				
			}
			for (int i = 0; i < 100; i++) {
				Optional<PersonId> personIdOptional = environment.getRandomIndexedPersonFromGenerator(key50, RandomGeneratorId.BLITZEN);
				assertTrue(personIdOptional.isPresent());
				PersonId personId = personIdOptional.get();
				assertTrue(personId.getValue()>=20);
				assertTrue(personId.getValue()<30);				
			}
		});

		// precondition tests
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// if the key is null
			assertModelException(() -> environment.getRandomIndexedPersonFromGenerator(null, RandomGeneratorId.BLITZEN), SimulationErrorType.NULL_POPULATION_INDEX_KEY);

			// if the key does not correspond to an existing population index
			assertModelException(() -> environment.getRandomIndexedPersonFromGenerator(new Object(), RandomGeneratorId.BLITZEN), SimulationErrorType.UNKNOWN_POPULATION_INDEX_KEY);
			
			// if the randomNumberGeneratorId is null
			assertModelException(() -> environment.getRandomIndexedPersonFromGenerator(key30, null), SimulationErrorType.NULL_RANDOM_NUMBER_GENERATOR_ID);

			// if the randomNumberGeneratorId is unknown
			assertModelException(() -> environment.getRandomIndexedPersonFromGenerator(key30, RandomGeneratorId.COMET), SimulationErrorType.UNKNOWN_RANDOM_NUMBER_GENERATOR_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}
	
	

}
