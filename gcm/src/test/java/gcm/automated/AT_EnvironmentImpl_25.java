package gcm.automated;

import static gcm.automated.support.EnvironmentSupport.addStandardComponentsAndTypes;
import static gcm.automated.support.EnvironmentSupport.addStandardPeople;
import static gcm.automated.support.EnvironmentSupport.addStandardPropertyDefinitions;
import static gcm.automated.support.EnvironmentSupport.addStandardTrackingAndScenarioId;
import static gcm.automated.support.EnvironmentSupport.addTaskPlanContainer;
import static gcm.automated.support.EnvironmentSupport.assertAllPlansExecuted;
import static gcm.automated.support.EnvironmentSupport.getRandomGenerator;
import static gcm.automated.support.EnvironmentSupport.getReplication;
import static gcm.automated.support.ExceptionAssertion.assertModelException;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Random;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

import org.apache.commons.math3.random.RandomGenerator;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import gcm.automated.support.EnvironmentSupport;
import gcm.automated.support.EnvironmentSupport.PropertyAssignmentPolicy;
import gcm.automated.support.SeedProvider;
import gcm.automated.support.TaskPlanContainer;
import gcm.automated.support.TestCompartmentId;
import gcm.automated.support.TestGlobalComponentId;
import gcm.automated.support.TestGroupTypeId;
import gcm.automated.support.TestPersonPropertyId;
import gcm.automated.support.TestRandomGeneratorId;
import gcm.automated.support.TestRegionId;
import gcm.automated.support.TestResourceId;
import gcm.replication.Replication;
import gcm.scenario.CompartmentId;
import gcm.scenario.GroupId;
import gcm.scenario.PersonId;
import gcm.scenario.PersonPropertyId;
import gcm.scenario.PropertyDefinition;
import gcm.scenario.RandomNumberGeneratorId;
import gcm.scenario.RegionId;
import gcm.scenario.ResourceId;
import gcm.scenario.Scenario;
import gcm.scenario.ScenarioBuilder;
import gcm.scenario.UnstructuredScenarioBuilder;
import gcm.simulation.Environment;
import gcm.simulation.EnvironmentImpl;
import gcm.simulation.Simulation;
import gcm.simulation.SimulationErrorType;
import gcm.simulation.partition.GroupTypeCountMap;
import gcm.simulation.partition.LabelSet;
import gcm.simulation.partition.LabelSetInfo;
import gcm.simulation.partition.Partition;
import gcm.simulation.partition.PartitionSampler;
import gcm.util.annotations.UnitTest;
import gcm.util.annotations.UnitTestMethod;

@UnitTest(target = EnvironmentImpl.class)

public class AT_EnvironmentImpl_25 {

	private static SeedProvider SEED_PROVIDER;

	@BeforeClass
	public static void beforeClass() {
		SEED_PROVIDER = new SeedProvider(EnvironmentSupport.getMetaSeed(25));
	}

	/**
	 * Internal test(not part of public tests) to show that there are no large gaps
	 * in the seed cases generated by the SeedProvider.
	 */
	@AfterClass
	public static void afterClass() {
//		System.out
//				.println(AT_EnvironmentImpl_25.class.getSimpleName() + " " + SEED_PROVIDER.generateUnusedSeedReport());
	}

	/*
	 * Utility class for getting random people from population indices
	 */
//	private static class Counter {
//
//		public Counter(int count) {
//			this.count = count;
//		}
//
//		int count;
//	}

//	private static double getWeight(ObservableEnvironment observableEnvironment, LabelSetInfo labelSetInfo) {
//		if (!labelSetInfo.getCompartmentLabel().isPresent()) {
//			throw new RuntimeException("no compartment label");
//		}
//		if (!labelSetInfo.getRegionLabel().isPresent()) {
//			throw new RuntimeException("no region label");
//		}
//
//		Integer compartmentLabel = (Integer) labelSetInfo.getCompartmentLabel().get();
//		Integer regionLabel = (Integer) labelSetInfo.getRegionLabel().get();
//
//		double p1;
//		switch (compartmentLabel) {
//		case 0:
//			p1 = 1;
//			break;
//		default:
//			p1 = 0;
//			break;
//		}
//
//		double p2;
//		switch (regionLabel) {
//		case 0:
//			p2 = 0.1;
//			break;
//		case 1:
//			p2 = 0.3;
//			break;
//		default:
//			p2 = 0.6;
//			break;
//		}
//
//		return p1 * p2;
//
//	}

//	private static double getZeroWeight(ObservableEnvironment observableEnvironment, LabelSetInfo labelSetInfo) {
//		return 0;
//	}

	private static enum PartitionChoice {
		COMPARTMENT, REGION, PROPERTY1, PROPERTY2, RESOURCE1, RESOURCE2, GROUP;
	}

	private static void buildBaseScenario(ScenarioBuilder scenarioBuilder, RandomGenerator randomGenerator) {

		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		Map<Object, PropertyDefinition> forcedPropertyDefinitions = new LinkedHashMap<>();
		PropertyDefinition propertyDefinition = PropertyDefinition.builder().setType(Integer.class).setDefaultValue(0)
				.build();
		forcedPropertyDefinitions.put(TestPersonPropertyId.PERSON_PROPERTY_1, propertyDefinition);
		propertyDefinition = PropertyDefinition.builder().setType(String.class).setDefaultValue("nope").build();
		forcedPropertyDefinitions.put(TestPersonPropertyId.PERSON_PROPERTY_2, propertyDefinition);
		addStandardPropertyDefinitions(scenarioBuilder, forcedPropertyDefinitions, PropertyAssignmentPolicy.TRUE,
				randomGenerator);
		addStandardPeople(scenarioBuilder, 300);

	}

	// defines how we label compartments
	static Function<CompartmentId, Object> compartmentPartitionFunction = (CompartmentId compartmentId) -> {
		TestCompartmentId testCompartmentId = (TestCompartmentId) compartmentId;
		switch (testCompartmentId) {
		case COMPARTMENT_1:
		case COMPARTMENT_2:
		case COMPARTMENT_3:
			return 0;
		case COMPARTMENT_4:
		case COMPARTMENT_5:
		default:
			return 1;
		}
	};

	// defines how we label regions
	static Function<RegionId, Object> regionPartitionFunction = (RegionId regionId) -> {
		TestRegionId testRegionId = (TestRegionId) regionId;
		switch (testRegionId) {
		case REGION_1:
		case REGION_2:
			return 0;
		case REGION_3:
		case REGION_4:
			return 1;
		default:
			return 2;
		}
	};

	// defines how we label resource 1
	static Function<Long, Object> personResource1PartitionFunction = (Long value) -> {
		if (value == 0) {
			return "zilch";
		}
		if (value < 4) {
			return "some";
		}
		return "whoa";
	};

	// defines how we label resource 2
	static Function<Long, Object> personResource2PartitionFunction = (Long value) -> {
		if (value == 0) {
			return "none";
		}
		if (value < 2) {
			return "good";
		}
		return "too much";
	};

	// defines how we label property1 values
	static Function<Object, Object> property1Function = (Object value) -> ((Integer) value) % 2;

	// defines how we label property2 values
	static Function<Object, Object> property2Function = (Object value) -> ((String) value).length() % 3;

	// defines how we label group types
	static Function<GroupTypeCountMap, Object> groupPartitionFunction = (GroupTypeCountMap groupTypeCountMap) -> {
		int group1Count = groupTypeCountMap.getGroupCount(TestGroupTypeId.GROUP_TYPE_1);
		int group2Count = groupTypeCountMap.getGroupCount(TestGroupTypeId.GROUP_TYPE_2);
		return 2 * group1Count + group2Count;
	};

	// helps generate randomized values for property 1
	static Function<RandomGenerator, Integer> property1InitializerFunction = (RandomGenerator r) -> {
		return r.nextInt(2);
	};

	// helps generate randomized values for property 2
	static Function<RandomGenerator, String> property2InitializerFunction = (RandomGenerator r) -> {
		switch (r.nextInt(3)) {
		case 0:
			return "yep";
		case 1:
			return "nope";
		default:
			return "maybe";
		}
	};

	// helps generate randomized values for property 1
	static Function<RandomGenerator, Long> resource1InitializerFunction = (RandomGenerator r) -> {
		return (long) r.nextInt(5);
	};

	// helps generate randomized values for property 2
	static Function<RandomGenerator, Long> resource2InitializerFunction = (RandomGenerator r) -> {
		return (long) r.nextInt(4);
	};

	private static void makeRandomPersonAssignments(Environment environment, RandomGenerator randomGenerator) {
		// add some groups to the simulation
		List<GroupId> type1Groups = new ArrayList<>();
		List<GroupId> type2Groups = new ArrayList<>();
		for (int i = 0; i < 10; i++) {
			type1Groups.add(environment.addGroup(TestGroupTypeId.GROUP_TYPE_1));
			type2Groups.add(environment.addGroup(TestGroupTypeId.GROUP_TYPE_2));
		}

		List<PersonId> people = environment.getPeople();
		for (int i = 0; i < people.size(); i++) {
			PersonId personId = people.get(i);
			environment.setPersonPropertyValue(personId, TestPersonPropertyId.PERSON_PROPERTY_1,
					property1InitializerFunction.apply(randomGenerator));
			environment.setPersonPropertyValue(personId, TestPersonPropertyId.PERSON_PROPERTY_2,
					property2InitializerFunction.apply(randomGenerator));

			RegionId personRegion = environment.getPersonRegion(personId);

			long amount = resource1InitializerFunction.apply(randomGenerator);
			environment.addResourceToRegion(TestResourceId.RESOURCE1, personRegion, amount);
			environment.transferResourceToPerson(TestResourceId.RESOURCE1, personId, amount);

			amount = resource2InitializerFunction.apply(randomGenerator);
			environment.addResourceToRegion(TestResourceId.RESOURCE2, personRegion, amount);
			environment.transferResourceToPerson(TestResourceId.RESOURCE2, personId, amount);

			int groupCount = randomGenerator.nextInt(3);
			Collections.shuffle(type1Groups, new Random(randomGenerator.nextLong()));
			for (int j = 0; j < groupCount; j++) {
				GroupId groupId = type1Groups.get(j);
				environment.addPersonToGroup(personId, groupId);
			}

			groupCount = randomGenerator.nextInt(4);
			Collections.shuffle(type2Groups, new Random(randomGenerator.nextLong()));
			for (int j = 0; j < groupCount; j++) {
				GroupId groupId = type2Groups.get(j);
				environment.addPersonToGroup(personId, groupId);
			}

		}

	}

	private static Map<LabelSetInfo, Set<PersonId>> getExpectedPartitionedPeople(Environment environment,
			Set<PartitionChoice> partionChoices) {

		List<PersonId> people = environment.getPeople();
		Map<LabelSetInfo, Set<PersonId>> expectedPartitioning = new LinkedHashMap<>();
		for (PersonId personId : people) {
			// retrieve the various characteristics of the person and convert them into
			// labels
			RegionId personRegion = environment.getPersonRegion(personId);
			Object regionLabel = regionPartitionFunction.apply(personRegion);

			CompartmentId personCompartment = environment.getPersonCompartment(personId);
			Object compartmentLabel = compartmentPartitionFunction.apply(personCompartment);

			Object personProperty1Value = environment.getPersonPropertyValue(personId,
					TestPersonPropertyId.PERSON_PROPERTY_1);
			Object personProperty1Label = property1Function.apply(personProperty1Value);

			Object personProperty2Value = environment.getPersonPropertyValue(personId,
					TestPersonPropertyId.PERSON_PROPERTY_2);
			Object personProperty2Label = property2Function.apply(personProperty2Value);

			long personResource1Level = environment.getPersonResourceLevel(personId, TestResourceId.RESOURCE1);
			Object personResource1Label = personResource1PartitionFunction.apply(personResource1Level);

			long personResource2Level = environment.getPersonResourceLevel(personId, TestResourceId.RESOURCE2);
			Object personResource2Label = personResource2PartitionFunction.apply(personResource2Level);

			int groupCount1 = environment.getGroupCountForGroupTypeAndPerson(TestGroupTypeId.GROUP_TYPE_1, personId);
			int groupCount2 = environment.getGroupCountForGroupTypeAndPerson(TestGroupTypeId.GROUP_TYPE_2, personId);
			GroupTypeCountMap groupTypeCountMap = GroupTypeCountMap.builder()
					.setCount(TestGroupTypeId.GROUP_TYPE_1, groupCount1)
					.setCount(TestGroupTypeId.GROUP_TYPE_2, groupCount2).build();

			Object groupLabel = groupPartitionFunction.apply(groupTypeCountMap);

			// use the labels to create a label set that fits the person
			LabelSet labelSet = LabelSet.create();
			for (PartitionChoice partitionChoice : partionChoices) {
				switch (partitionChoice) {
				case COMPARTMENT:
					labelSet = labelSet.with(LabelSet.create().compartment(compartmentLabel));
					break;
				case GROUP:
					labelSet = labelSet.with(LabelSet.create().group(groupLabel));
					break;
				case PROPERTY1:
					labelSet = labelSet.with(
							LabelSet.create().property(TestPersonPropertyId.PERSON_PROPERTY_1, personProperty1Label));
					break;
				case PROPERTY2:
					labelSet = labelSet.with(
							LabelSet.create().property(TestPersonPropertyId.PERSON_PROPERTY_2, personProperty2Label));
					break;
				case REGION:
					labelSet = labelSet.with(LabelSet.create().region(regionLabel));
					break;
				case RESOURCE1:
					labelSet = labelSet
							.with(LabelSet.create().resource(TestResourceId.RESOURCE1, personResource1Label));
					break;
				case RESOURCE2:
					labelSet = labelSet
							.with(LabelSet.create().resource(TestResourceId.RESOURCE2, personResource2Label));
					break;
				default:
					throw new RuntimeException("unhandled case");
				}
			}
			LabelSetInfo labelSetInfo = LabelSetInfo.build(labelSet);
			// add the population query to the expectedPartitioning if it is new and add the
			// person to the set of people we expect to be associated with this query
			Set<PersonId> partitionPeople = expectedPartitioning.get(labelSetInfo);
			if (partitionPeople == null) {
				partitionPeople = new LinkedHashSet<>();
				expectedPartitioning.put(labelSetInfo, partitionPeople);
			}
			partitionPeople.add(personId);
		}
		return expectedPartitioning;
	}

	private static Partition createPopulationPartitionDefinition(Set<PartitionChoice> partionChoices) {

		Partition result = Partition.create();

		for (PartitionChoice partitionChoice : partionChoices) {
			switch (partitionChoice) {
			case COMPARTMENT:
				result = result.with(Partition.create().compartment(compartmentPartitionFunction));
				break;
			case GROUP:
				result = result.with(Partition.create().group(groupPartitionFunction));
				break;
			case PROPERTY1:
				result = result
						.with(Partition.create().property(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function));
				break;
			case PROPERTY2:
				result = result
						.with(Partition.create().property(TestPersonPropertyId.PERSON_PROPERTY_2, property2Function));
				break;
			case REGION:
				result = result.with(Partition.create().region(regionPartitionFunction));
				break;
			case RESOURCE1:
				result = result
						.with(Partition.create().resource(TestResourceId.RESOURCE1, personResource1PartitionFunction));
				break;
			case RESOURCE2:
				result = result
						.with(Partition.create().resource(TestResourceId.RESOURCE2, personResource2PartitionFunction));
				break;
			default:
				throw new RuntimeException("unhandled case");
			}
		}

		return result;
	}

	private static LabelSet getLabelSet(LabelSetInfo labelSetInfo) {
		LabelSet result = LabelSet.create();
		if (labelSetInfo.getCompartmentLabel().isPresent()) {
			result = result.with(LabelSet.create().compartment(labelSetInfo.getCompartmentLabel().get()));
		}
		if (labelSetInfo.getRegionLabel().isPresent()) {
			result = result.with(LabelSet.create().region(labelSetInfo.getRegionLabel().get()));
		}
		if (labelSetInfo.getGroupLabel().isPresent()) {
			result = result.with(LabelSet.create().group(labelSetInfo.getGroupLabel().get()));
		}
		for (PersonPropertyId personPropertyId : labelSetInfo.getPersonPropertyIds()) {
			result = result.with(LabelSet.create().property(personPropertyId,
					labelSetInfo.getPersonPropertyLabel(personPropertyId).get()));
		}
		for (ResourceId recourceId : labelSetInfo.getPersonResourceIds()) {
			result = result.with(
					LabelSet.create().resource(recourceId, labelSetInfo.getPersonResourceLabel(recourceId).get()));
		}
		return result;
	}

	/**
	 * Tests {@link EnvironmentImpl#getPartitionSize(PersonPropertyId, Object)}
	 */
	@Test
	@UnitTestMethod(name = "getPartitionSize", args = { Object.class, LabelSet.class })
	public void testGetPartitionSize() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(1);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;
		Object key = "key";

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<PartitionChoice> partitionChoices = EnumSet.allOf(PartitionChoice.class);

			// define the partition
			Partition partition = createPopulationPartitionDefinition(partitionChoices);

			// add the partition to the simulation
			environment.addPopulationPartition(partition, key);

			makeRandomPersonAssignments(environment, randomGenerator);

			// Group the people in the simulation by their labels, giving us the expected
			// partitioning
			Map<LabelSetInfo, Set<PersonId>> expectedPartitioning = getExpectedPartitionedPeople(environment,
					partitionChoices);

			// show that each labelSet corresponds to the expected number of
			// people
			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {
				LabelSet labelSet = getLabelSet(labelSetInfo);
				int expectedSize = expectedPartitioning.get(labelSetInfo).size();
				int actualSize = environment.getPartitionSize(key, labelSet);
				assertEquals(expectedSize, actualSize);

			}

			// We now reduce the partition choices so that each query will correspond to
			// multiple elements of the partition.
			partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT, PartitionChoice.REGION);

			expectedPartitioning = getExpectedPartitionedPeople(environment, partitionChoices);

			// show that each labelSet corresponds to the expected number of
			// people
			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {
				LabelSet labelSet = getLabelSet(labelSetInfo);
				int expectedSize = expectedPartitioning.get(labelSetInfo).size();
				int actualSize = environment.getPartitionSize(key, labelSet);
				assertEquals(expectedSize, actualSize);
			}
		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key3 = "key3";

			Partition partition = Partition.create().compartment(compartmentPartitionFunction)
					.property(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function);
			environment.addPopulationPartition(partition, key3);

			LabelSet labelSet = LabelSet.create().compartment(0).property(TestPersonPropertyId.PERSON_PROPERTY_1, 1);
			LabelSet incompatiblelabelSet = LabelSet.create().compartment(0)
					.property(TestPersonPropertyId.PERSON_PROPERTY_2, 1);

			// if the key is null
			assertModelException(() -> environment.getPartitionSize(null, labelSet),
					SimulationErrorType.NULL_POPULATION_PARTITION_KEY);
			// if the key does not correspond to an existing partition
			assertModelException(() -> environment.getPartitionSize("bad key", labelSet),
					SimulationErrorType.UNKNOWN_POPULATION_PARTITION_KEY);
			// if the label set is null
			assertModelException(() -> environment.getPartitionSize(key3, null), SimulationErrorType.NULL_LABEL_SET);
			// if the label set is incompatible with the partition
			assertModelException(() -> environment.getPartitionSize(key3, incompatiblelabelSet),
					SimulationErrorType.INCOMPATIBLE_LABEL_SET);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getPartitionPeople(Object, LabelSet)
	 */
	@Test
	@UnitTestMethod(name = "getPartitionPeople", args = { Object.class, LabelSet.class })
	public void testGetPartitionPeople() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(0);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;
		Object key = "key";

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<PartitionChoice> partitionChoices = EnumSet.allOf(PartitionChoice.class);

			// define the partition
			Partition partition = createPopulationPartitionDefinition(partitionChoices);

			// add the partition to the simulation
			environment.addPopulationPartition(partition, key);

			makeRandomPersonAssignments(environment, randomGenerator);

			// Group the people in the simulation by their labels, giving us the expected
			// partitioning -- each labelSet will correspond to exactly one
			// element of the partition

			Map<LabelSetInfo, Set<PersonId>> expectedPartitioning = getExpectedPartitionedPeople(environment,
					partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {
				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				LabelSet labelSet = getLabelSet(labelSetInfo);
				List<PersonId> partitionPeople = environment.getPartitionPeople(key, labelSet);
				assertEquals(expectedPeople.size(), partitionPeople.size());
				Set<PersonId> actualPeople = partitionPeople.stream()
						.collect(Collectors.toCollection(LinkedHashSet::new));
				assertEquals(expectedPeople, actualPeople);
			}

			// We now reduce the partition choices so that each query will correspond to
			// multiple elements of the partition.
			partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT, PartitionChoice.PROPERTY1);
			expectedPartitioning = getExpectedPartitionedPeople(environment, partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {
				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				LabelSet labelSet = getLabelSet(labelSetInfo);
				List<PersonId> partitionPeople = environment.getPartitionPeople(key, labelSet);
				assertEquals(expectedPeople.size(), partitionPeople.size());
				Set<PersonId> actualPeople = partitionPeople.stream()
						.collect(Collectors.toCollection(LinkedHashSet::new));
				assertEquals(expectedPeople, actualPeople);
			}
		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key3 = "key3";
			Partition partition = Partition.create().compartment(compartmentPartitionFunction)
					.property(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function);
			environment.addPopulationPartition(partition, key3);

			LabelSet labelSet = LabelSet.create().compartment(0).property(TestPersonPropertyId.PERSON_PROPERTY_1, 1);
			LabelSet incompatiblelabelSet = LabelSet.create().compartment(0)
					.property(TestPersonPropertyId.PERSON_PROPERTY_2, 1);

			// if the key is null
			assertModelException(() -> environment.getPartitionPeople(null, labelSet),
					SimulationErrorType.NULL_POPULATION_PARTITION_KEY);
			// if the key does not correspond to an existing partition
			assertModelException(() -> environment.getPartitionPeople("bad key", labelSet),
					SimulationErrorType.UNKNOWN_POPULATION_PARTITION_KEY);
			// if the label set is null
			assertModelException(() -> environment.getPartitionPeople(key3, null), SimulationErrorType.NULL_LABEL_SET);
			// if the label set is incompatible with the partition
			assertModelException(() -> environment.getPartitionPeople(key3, incompatiblelabelSet),
					SimulationErrorType.INCOMPATIBLE_LABEL_SET);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#addPopulationPartition(Partition, Object)
	 */
	@Test
	@UnitTestMethod(name = "addPopulationPartition", args = { Partition.class, Object.class })
	public void testAddPopulationPartition() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(4);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key = "key";
			Set<PartitionChoice> partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT);
			Partition partition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPopulationPartition(partition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePopulationPartition(key);
			assertFalse(environment.populationPartitionExists(key));

			partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT, PartitionChoice.PROPERTY1);
			partition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPopulationPartition(partition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePopulationPartition(key);
			assertFalse(environment.populationPartitionExists(key));

			partitionChoices = EnumSet.of(PartitionChoice.GROUP, PartitionChoice.PROPERTY1);
			partition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPopulationPartition(partition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePopulationPartition(key);
			assertFalse(environment.populationPartitionExists(key));

		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key1 = "key1";
			Object key2 = "key2";
			Partition partition = Partition.create().compartment(compartmentPartitionFunction)
					.property(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function);

			Partition badPropertyPartition = Partition.create().compartment(compartmentPartitionFunction)
					.property(TestPersonPropertyId.getUnknownPersonPropertyId(), property1Function);

			Partition badResourcePartition = Partition.create().compartment(compartmentPartitionFunction)
					.resource(TestResourceId.getUnknownResourceId(), personResource1PartitionFunction);

			environment.addPopulationPartition(partition, key1);

			// if the population partition definition is null
			assertModelException(() -> environment.addPopulationPartition(null, key2),
					SimulationErrorType.NULL_POPULATION_PARTITION_DEFINITION);

			// if the key is null
			assertModelException(() -> environment.addPopulationPartition(partition, null),
					SimulationErrorType.NULL_POPULATION_PARTITION_KEY);

			// if the key corresponds to an existing population partition
			assertModelException(() -> environment.addPopulationPartition(partition, key1),
					SimulationErrorType.DUPLICATE_POPULATION_PARTITION);

			// if the definition contains an unknown person property id
			assertModelException(() -> environment.addPopulationPartition(badPropertyPartition, key2),
					SimulationErrorType.UNKNOWN_PERSON_PROPERTY_ID);

			// if the definition contains an unknown resource id
			assertModelException(() -> environment.addPopulationPartition(badResourcePartition, key2),
					SimulationErrorType.UNKNOWN_RESOURCE_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#removePopulationPartition(Object)
	 */
	@Test
	@UnitTestMethod(name = "removePopulationPartition", args = { Object.class })
	public void testRemovePopulationPartition() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(5);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key = "key";
			Set<PartitionChoice> partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT);
			Partition partition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPopulationPartition(partition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePopulationPartition(key);
			assertFalse(environment.populationPartitionExists(key));

			partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT, PartitionChoice.PROPERTY1);
			partition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPopulationPartition(partition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePopulationPartition(key);
			assertFalse(environment.populationPartitionExists(key));

			partitionChoices = EnumSet.of(PartitionChoice.GROUP, PartitionChoice.PROPERTY1);
			partition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPopulationPartition(partition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePopulationPartition(key);
			assertFalse(environment.populationPartitionExists(key));

		});

		/*
		 * Precondition tests -- none
		 */

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// if the key is null
			assertModelException(() -> environment.removePopulationPartition(null),
					SimulationErrorType.NULL_POPULATION_PARTITION_KEY);

			// if the key does not correspond to an existing population index
			assertModelException(() -> environment.removePopulationPartition("unknown key"),
					SimulationErrorType.UNKNOWN_POPULATION_PARTITION_KEY);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#populationPartitionExists(Object)
	 */
	@Test
	@UnitTestMethod(name = "populationPartitionExists", args = { Object.class })
	public void testPopulationPartitionExists() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(3);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key = "key";
			Set<PartitionChoice> partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT);
			Partition partition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPopulationPartition(partition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePopulationPartition(key);
			assertFalse(environment.populationPartitionExists(key));

			partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT, PartitionChoice.PROPERTY1);
			partition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPopulationPartition(partition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePopulationPartition(key);
			assertFalse(environment.populationPartitionExists(key));

			partitionChoices = EnumSet.of(PartitionChoice.GROUP, PartitionChoice.PROPERTY1);
			partition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPopulationPartition(partition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePopulationPartition(key);
			assertFalse(environment.populationPartitionExists(key));

		});

		/*
		 * Precondition tests -- none
		 */

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests {@link EnvironmentImpl#personIsInPopulationPartition(PersonId, Object,
	 * LabelSet)
	 */
	@Test
	@UnitTestMethod(name = "personIsInPopulationPartition", args = { PersonId.class, Object.class, LabelSet.class })
	public void testPersonIsInPopulationPartition() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(2);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;
		Object key = "key";

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<PartitionChoice> partitionChoices = EnumSet.allOf(PartitionChoice.class);

			// define the partition
			Partition partition = createPopulationPartitionDefinition(partitionChoices);

			// add the partition to the simulation
			environment.addPopulationPartition(partition, key);

			makeRandomPersonAssignments(environment, randomGenerator);

			// Group the people in the simulation by their labels, giving us the expected
			// partitioning
			Map<LabelSetInfo, Set<PersonId>> expectedPartitioning = getExpectedPartitionedPeople(environment,
					partitionChoices);

			// show that each labelSet corresponds to the expected number of
			// people

			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				for (PersonId personId : expectedPeople) {
					LabelSet labelSet = getLabelSet(labelSetInfo);
					assertTrue(environment.personIsInPopulationPartition(personId, key, labelSet));
				}
			}

			// We now reduce the partition choices so that each query will correspond to
			// multiple elements of the partition.
			partitionChoices = EnumSet.of(PartitionChoice.PROPERTY1, PartitionChoice.PROPERTY2,
					PartitionChoice.RESOURCE1, PartitionChoice.RESOURCE2);

			expectedPartitioning = getExpectedPartitionedPeople(environment, partitionChoices);

			// show that each labelSet corresponds to the expected number of
			// people

			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				for (PersonId personId : expectedPeople) {
					LabelSet labelSet = getLabelSet(labelSetInfo);
					assertTrue(environment.personIsInPopulationPartition(personId, key, labelSet));
				}
			}

		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			Object key3 = "key3";
			Partition partition = Partition.create().compartment(compartmentPartitionFunction)
					.property(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function);
			environment.addPopulationPartition(partition, key3);

			LabelSet labelSet = LabelSet.create().compartment(0).property(TestPersonPropertyId.PERSON_PROPERTY_1, 1);
			LabelSet incompatiblelabelSet = LabelSet.create().compartment(0)
					.property(TestPersonPropertyId.PERSON_PROPERTY_2, 1);
			PersonId goodPersonId = new PersonId(0);
			PersonId badPersonId = new PersonId(10000000);

			// if the key is null
			assertModelException(() -> environment.personIsInPopulationPartition(goodPersonId, null, labelSet),
					SimulationErrorType.NULL_POPULATION_PARTITION_KEY);
			// if the key does not correspond to an existing partition
			assertModelException(() -> environment.personIsInPopulationPartition(goodPersonId, "bad key", labelSet),
					SimulationErrorType.UNKNOWN_POPULATION_PARTITION_KEY);

			// if the personId is null
			assertModelException(() -> environment.personIsInPopulationPartition(null, key3, labelSet),
					SimulationErrorType.NULL_PERSON_ID);
			// if the personId does not correspond to an existing person
			assertModelException(() -> environment.personIsInPopulationPartition(badPersonId, key3, labelSet),
					SimulationErrorType.UNKNOWN_PERSON_ID);

			// if the label set is null
			assertModelException(() -> environment.personIsInPopulationPartition(goodPersonId, key3, null),
					SimulationErrorType.NULL_LABEL_SET);
			// if the label set is incompatible with the partition
			assertModelException(
					() -> environment.personIsInPopulationPartition(goodPersonId, key3, incompatiblelabelSet),
					SimulationErrorType.INCOMPATIBLE_LABEL_SET);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#samplePartition(Object, PartitionSampler)} Test
	 * limited to precondition tests.
	 */
	@Test
	@UnitTestMethod(name = "samplePartition", args = { Object.class, PartitionSampler.class })
	public void testSamplePartition_precondition_checks() {

		/*
		 * Assert that group contacts via MonoWeightingFunctions work properly
		 */

		final long seed = SEED_PROVIDER.getSeedValue(10);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		RandomNumberGeneratorId randomNumberGeneratorId = TestRandomGeneratorId.BLITZEN;

		scenarioBuilder.addRandomNumberGeneratorId(randomNumberGeneratorId);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 0;

//		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
//
//			Object key = "key1";
//			Partition partition = Partition.create().compartment(AT_EnvironmentImpl_26.compartmentPartitionFunction)
//					.region(AT_EnvironmentImpl_26.regionPartitionFunction);
//			environment.addPopulationPartition(partition, key);
//
//			// use a uniform distribution with 10000 repetitions
//
//			final Map<MultiKey, Counter> actualSelections = new LinkedHashMap<>();
//			actualSelections.put(new MultiKey(0, 0), new Counter(0));
//			actualSelections.put(new MultiKey(0, 1), new Counter(0));
//			actualSelections.put(new MultiKey(0, 2), new Counter(0));
//			actualSelections.put(new MultiKey(1, 0), new Counter(0));
//			actualSelections.put(new MultiKey(1, 1), new Counter(0));
//			actualSelections.put(new MultiKey(1, 2), new Counter(0));
//
//			final Map<MultiKey, Counter> expectedSelections = new LinkedHashMap<>();
//
//			int sampleCount = 10000;
//
//			expectedSelections.put(new MultiKey(0, 0), new Counter(sampleCount / 10));
//			expectedSelections.put(new MultiKey(0, 1), new Counter(3 * sampleCount / 10));
//			expectedSelections.put(new MultiKey(0, 2), new Counter(6 * sampleCount / 10));
//			expectedSelections.put(new MultiKey(1, 0), new Counter(0));
//			expectedSelections.put(new MultiKey(1, 1), new Counter(0));
//			expectedSelections.put(new MultiKey(1, 2), new Counter(0));
//
//			for (int i = 0; i < 10000; i++) {
//
//				Optional<PersonId> opt = environment.samplePartition(key, AT_EnvironmentImpl_26::getWeight,
//						randomNumberGeneratorId);
//
//				assertTrue(opt.isPresent());
//				PersonId personId = opt.get();
//				CompartmentId compartmentId = environment.getPersonCompartment(personId);
//				Object compartmentLabel = compartmentPartitionFunction.apply(compartmentId);
//				RegionId regionId = environment.getPersonRegion(personId);
//				Object regionLabel = regionPartitionFunction.apply(regionId);
//				MultiKey multiKey = new MultiKey(compartmentLabel, regionLabel);
//				Counter counter = actualSelections.get(multiKey);
//				counter.count++;
//			}
//
//			for (MultiKey multiKey : expectedSelections.keySet()) {
//				Counter expectedCounter = expectedSelections.get(multiKey);
//				Counter actualCounter = actualSelections.get(multiKey);
//				int tolerance = expectedCounter.count / 10;
//				assertTrue(FastMath.abs(expectedCounter.count - actualCounter.count) <= tolerance);
//			}
//
//		});

		// show that a weighting function that returns all zeros will result in
		// an optional where no value is present
//		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
//
//			Object key = "key2";
//			Partition partition = Partition.create().compartment(AT_EnvironmentImpl_26.compartmentPartitionFunction)
//					.region(AT_EnvironmentImpl_26.regionPartitionFunction);
//			environment.addPopulationPartition(partition, key);
//
//			Optional<PersonId> opt = environment.samplePartition(key, AT_EnvironmentImpl_26::getZeroWeight,
//					randomNumberGeneratorId);
//			assertTrue(!opt.isPresent());
//		});

		// test preconditions
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key = "key3";
			Object badKey = "badKey";
			Partition partition = Partition.create().compartment(AT_EnvironmentImpl_25.compartmentPartitionFunction)
					.region(AT_EnvironmentImpl_25.regionPartitionFunction);
			environment.addPopulationPartition(partition, key);

			// if the key is null
			assertModelException(() -> environment.samplePartition(null, PartitionSampler.create()),
					SimulationErrorType.NULL_POPULATION_PARTITION_KEY);

			// if the key does not correspond to an existing population partition
			assertModelException(() -> environment.samplePartition(badKey, PartitionSampler.create()),
					SimulationErrorType.UNKNOWN_POPULATION_PARTITION_KEY);

			// if the partition sampler is null
			assertModelException(() -> environment.samplePartition(key, (PartitionSampler) null),
					SimulationErrorType.NULL_PARTITION_SAMPLER);

			// if the partition sampler's label set is incompatible with the population
			// partition
			assertModelException(() -> {
				LabelSet labelSet = LabelSet.create().compartment("asdf").resource(TestResourceId.RESOURCE1, "asdf");
				PartitionSampler partitionSampler = PartitionSampler.create().labelSet(labelSet);
				environment.samplePartition(key, partitionSampler);
			}, SimulationErrorType.INCOMPATIBLE_LABEL_SET);

			// if the randomNumberGeneratorId does not correspond to an existing random
			// Number Generator Id in the scenario
			assertModelException(
					() -> environment.samplePartition(key,
							PartitionSampler.create().generator(TestRandomGeneratorId.PRANCER)),
					SimulationErrorType.UNKNOWN_RANDOM_NUMBER_GENERATOR_ID);

			// if the excluded person is unknown
			assertModelException(
					() -> environment.samplePartition(key,
							PartitionSampler.create().excludePerson(new PersonId(1000000))),
					SimulationErrorType.UNKNOWN_PERSON_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#samplePartition(Object, LabelSet,
	 * RandomNumberGeneratorId, PersonId). Test limited to PartitionSampler with
	 * LabelSet, alternate random number generator and excluded person.
	 */
	@Test
	@UnitTestMethod(name = "samplePartition", args = { Object.class, PartitionSampler.class })
	public void testSamplePartition_LabelSet_RNG_PersonId() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(17);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		RandomNumberGeneratorId randomNumberGeneratorId = TestRandomGeneratorId.BLITZEN;
		scenarioBuilder.addRandomNumberGeneratorId(randomNumberGeneratorId);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;
		Object key = "key";

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<PartitionChoice> partitionChoices = EnumSet.allOf(PartitionChoice.class);

			// define the partition
			Partition partition = createPopulationPartitionDefinition(partitionChoices);

			// add the partition to the simulation
			environment.addPopulationPartition(partition, key);

			makeRandomPersonAssignments(environment, randomGenerator);

			// Group the people in the simulation by their labels, giving us the expected
			// partitioning
			Map<LabelSetInfo, Set<PersonId>> expectedPartitioning = getExpectedPartitionedPeople(environment,
					partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation

			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {
				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				List<PersonId> expectedPeopleList = new ArrayList<>(expectedPeople);
				Collections.shuffle(expectedPeopleList, new Random(randomGenerator.nextLong()));
				// we know that each labelSet corresponds to at least one person
				PersonId excludedPersonId = expectedPeopleList.get(0);

				for (int i = 0; i < 10; i++) {
					LabelSet labelSet = getLabelSet(labelSetInfo);
					PartitionSampler partitionSampler = PartitionSampler.create().labelSet(labelSet)
							.generator(randomNumberGeneratorId).excludePerson(excludedPersonId);
					Optional<PersonId> optional = environment.samplePartition(key, partitionSampler);
					if (expectedPeople.size() > 1) {
						assertTrue(optional.isPresent());
						PersonId selectedPersonId = optional.get();
						assertTrue(expectedPeople.contains(selectedPersonId));
					} else {
						assertFalse(optional.isPresent());
					}
				}
			}

			// We now reduce the partition choices so that each query will correspond to
			// multiple elements of the partition.

			partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT, PartitionChoice.GROUP,
					PartitionChoice.RESOURCE2);
			expectedPartitioning = getExpectedPartitionedPeople(environment, partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation

			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {
				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				List<PersonId> expectedPeopleList = new ArrayList<>(expectedPeople);
				Collections.shuffle(expectedPeopleList, new Random(randomGenerator.nextLong()));
				// we know that each labelSet corresponds to at least one person
				PersonId excludedPersonId = expectedPeopleList.get(0);

				for (int i = 0; i < 10; i++) {
					LabelSet labelSet = getLabelSet(labelSetInfo);
					PartitionSampler partitionSampler = PartitionSampler.create().labelSet(labelSet)
							.generator(randomNumberGeneratorId).excludePerson(excludedPersonId);
					Optional<PersonId> optional = environment.samplePartition(key, partitionSampler);
					if (expectedPeople.size() > 1) {
						assertTrue(optional.isPresent());
						PersonId selectedPersonId = optional.get();
						assertTrue(expectedPeople.contains(selectedPersonId));
					} else {
						assertFalse(optional.isPresent());
					}
				}
			}

			// show that a population query resulting in an empty partition cannot return a
			// randomly selected person
			PersonId personId = new PersonId(0);
			Object key2 = "key2";
			Partition partitionDefinition = Partition.create().property(TestPersonPropertyId.PERSON_PROPERTY_1,
					property1Function);
			environment.addPopulationPartition(partitionDefinition, key2);
			LabelSet labelSet = LabelSet.create().property(TestPersonPropertyId.PERSON_PROPERTY_1, 1000);
			PartitionSampler partitionSampler = PartitionSampler.create().labelSet(labelSet)
					.generator(randomNumberGeneratorId).excludePerson(personId);
			Optional<PersonId> optional = environment.samplePartition(key2, partitionSampler);
			assertFalse(optional.isPresent());

			// show that a population query resulting in a partition containing only the
			// excluded person cannot return a randomly selected person
			environment.setPersonPropertyValue(personId, TestPersonPropertyId.PERSON_PROPERTY_1, 1000);
			partitionSampler = PartitionSampler.create().labelSet(labelSet).generator(TestRandomGeneratorId.BLITZEN)
					.excludePerson(personId);
			optional = environment.samplePartition(key2, partitionSampler);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#samplePartition(Object, LabelSet). Test limited
	 * to PartitionSampler with LabelSet only.
	 */
	@Test
	@UnitTestMethod(name = "samplePartition", args = { Object.class, PartitionSampler.class })
	public void testSamplePartition_LabelSet() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(14);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;
		Object key = "key";

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<PartitionChoice> partitionChoices = EnumSet.allOf(PartitionChoice.class);

			// define the partition
			Partition partition = createPopulationPartitionDefinition(partitionChoices);

			// add the partition to the simulation
			environment.addPopulationPartition(partition, key);

			makeRandomPersonAssignments(environment, randomGenerator);

			// Group the people in the simulation by their labels, giving us the expected
			// partitioning
			Map<LabelSetInfo, Set<PersonId>> expectedPartitioning = getExpectedPartitionedPeople(environment,
					partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				// we know that each labelSet corresponds to at least one person
				for (int i = 0; i < 10; i++) {
					LabelSet labelSet = getLabelSet(labelSetInfo);
					PartitionSampler partitionSampler = PartitionSampler.create().labelSet(labelSet);
					Optional<PersonId> optional = environment.samplePartition(key, partitionSampler);
					assertTrue(optional.isPresent());
					PersonId selectedPersonId = optional.get();
					assertTrue(expectedPeople.contains(selectedPersonId));
				}
			}

			// We now reduce the partition choices so that each query will correspond to
			// multiple elements of the partition.
			partitionChoices = EnumSet.of(PartitionChoice.PROPERTY1, PartitionChoice.PROPERTY2, PartitionChoice.GROUP,
					PartitionChoice.COMPARTMENT);
			expectedPartitioning = getExpectedPartitionedPeople(environment, partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				// we know that each labelSet corresponds to at least one person
				for (int i = 0; i < 10; i++) {
					LabelSet labelSet = getLabelSet(labelSetInfo);
					PartitionSampler partitionSampler = PartitionSampler.create().labelSet(labelSet);
					Optional<PersonId> optional = environment.samplePartition(key, partitionSampler);
					assertTrue(optional.isPresent());
					PersonId selectedPersonId = optional.get();
					assertTrue(expectedPeople.contains(selectedPersonId));
				}
			}
			// show that a population query resulting in an empty partition cannot return a
			// randomly selected person
			Object key2 = "key2";
			Partition partitionDefinition = Partition.create().property(TestPersonPropertyId.PERSON_PROPERTY_1,
					property1Function);
			environment.addPopulationPartition(partitionDefinition, key2);
			LabelSet labelSet = LabelSet.create().property(TestPersonPropertyId.PERSON_PROPERTY_1, 1000);
			PartitionSampler partitionSampler = PartitionSampler.create().labelSet(labelSet);
			Optional<PersonId> optional = environment.samplePartition(key2, partitionSampler);
			assertFalse(optional.isPresent());

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests {@link EnvironmentImpl#samplePartition(Object, LabelSet, PersonId).
	 * Test limited to PartitionSampler with LabelSet and excluded person only.
	 */
	@Test
	@UnitTestMethod(name = "samplePartition", args = { Object.class, PartitionSampler.class })
	public void testSamplePartition_LabelSet_PersonId() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(15);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;
		Object key = "key";

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<PartitionChoice> partitionChoices = EnumSet.allOf(PartitionChoice.class);

			// define the partition
			Partition partition = createPopulationPartitionDefinition(partitionChoices);

			// add the partition to the simulation
			environment.addPopulationPartition(partition, key);

			makeRandomPersonAssignments(environment, randomGenerator);

			// Group the people in the simulation by their labels, giving us the expected
			// partitioning
			Map<LabelSetInfo, Set<PersonId>> expectedPartitioning = getExpectedPartitionedPeople(environment,
					partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				List<PersonId> expectedPeopleList = new ArrayList<>(expectedPeople);
				Collections.shuffle(expectedPeopleList, new Random(randomGenerator.nextLong()));
				// we know that each labelSet corresponds to at least one person
				PersonId excludedPersonId = expectedPeopleList.get(0);

				for (int i = 0; i < 10; i++) {
					LabelSet labelSet = getLabelSet(labelSetInfo);
					PartitionSampler partitionSampler = PartitionSampler.create().labelSet(labelSet)
							.excludePerson(excludedPersonId);
					Optional<PersonId> optional = environment.samplePartition(key, partitionSampler);
					if (expectedPeople.size() > 1) {
						assertTrue(optional.isPresent());
						PersonId selectedPersonId = optional.get();
						assertTrue(expectedPeople.contains(selectedPersonId));
					} else {
						assertFalse(optional.isPresent());
					}
				}
			}

			// We now reduce the partition choices so that each query will correspond to
			// multiple elements of the partition.
			partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT, PartitionChoice.PROPERTY1,
					PartitionChoice.RESOURCE1);
			expectedPartitioning = getExpectedPartitionedPeople(environment, partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				List<PersonId> expectedPeopleList = new ArrayList<>(expectedPeople);
				Collections.shuffle(expectedPeopleList, new Random(randomGenerator.nextLong()));
				// we know that each labelSet corresponds to at least one person
				PersonId excludedPersonId = expectedPeopleList.get(0);

				for (int i = 0; i < 10; i++) {
					LabelSet labelSet = getLabelSet(labelSetInfo);
					PartitionSampler partitionSampler = PartitionSampler.create().labelSet(labelSet)
							.excludePerson(excludedPersonId);
					Optional<PersonId> optional = environment.samplePartition(key, partitionSampler);
					if (expectedPeople.size() > 1) {
						assertTrue(optional.isPresent());
						PersonId selectedPersonId = optional.get();
						assertTrue(expectedPeople.contains(selectedPersonId));
					} else {
						assertFalse(optional.isPresent());
					}
				}
			}
			// show that a population query resulting in an empty partition cannot return a
			// randomly selected person
			PersonId personId = new PersonId(0);
			Object key2 = "key2";
			partition = Partition.create().property(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function);
			environment.addPopulationPartition(partition, key2);
			LabelSet labelSet = LabelSet.create().property(TestPersonPropertyId.PERSON_PROPERTY_1, 1000);
			PartitionSampler partitionSampler = PartitionSampler.create().labelSet(labelSet).excludePerson(personId);
			Optional<PersonId> optional = environment.samplePartition(key2, partitionSampler);
			assertFalse(optional.isPresent());

			// show that a population query resulting in a partition containing only the
			// excluded person cannot return a randomly selected person
			environment.setPersonPropertyValue(personId, TestPersonPropertyId.PERSON_PROPERTY_1, 1000);
			partitionSampler = PartitionSampler.create().labelSet(labelSet).excludePerson(personId);
			optional = environment.samplePartition(key2, partitionSampler);
			assertFalse(optional.isPresent());
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests {@link EnvironmentImpl#samplePartition(Object, LabelSet,
	 * RandomNumberGeneratorId). Test limited to PartitionSampler with LabelSet and
	 * alternate random number generator.
	 */
	@Test
	@UnitTestMethod(name = "samplePartition", args = { Object.class, PartitionSampler.class })
	public void testSamplePartition_LabelSet_RNG() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(16);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		RandomNumberGeneratorId randomNumberGeneratorId = TestRandomGeneratorId.COMET;
		scenarioBuilder.addRandomNumberGeneratorId(randomNumberGeneratorId);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;
		Object key = "key";

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<PartitionChoice> partitionChoices = EnumSet.allOf(PartitionChoice.class);

			// define the partition
			Partition partition = createPopulationPartitionDefinition(partitionChoices);

			// add the partition to the simulation
			environment.addPopulationPartition(partition, key);

			makeRandomPersonAssignments(environment, randomGenerator);

			// Group the people in the simulation by their labels, giving us the expected
			// partitioning

			Map<LabelSetInfo, Set<PersonId>> expectedPartitioning = getExpectedPartitionedPeople(environment,
					partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				// we know that each labelSet corresponds to at least one person
				for (int i = 0; i < 10; i++) {
					LabelSet labelSet = getLabelSet(labelSetInfo);
					PartitionSampler partitionSampler = PartitionSampler.create().labelSet(labelSet)
							.generator(randomNumberGeneratorId);
					Optional<PersonId> optional = environment.samplePartition(key, partitionSampler);
					assertTrue(optional.isPresent());
					PersonId selectedPersonId = optional.get();
					assertTrue(expectedPeople.contains(selectedPersonId));
				}
			}
			// We now reduce the partition choices so that each query will correspond to
			// multiple elements of the partition.
			partitionChoices = EnumSet.of(PartitionChoice.GROUP, PartitionChoice.REGION, PartitionChoice.RESOURCE1);
			expectedPartitioning = getExpectedPartitionedPeople(environment, partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				// we know that each labelSet corresponds to at least one person
				for (int i = 0; i < 10; i++) {
					LabelSet labelSet = getLabelSet(labelSetInfo);
					PartitionSampler partitionSampler = PartitionSampler.create().labelSet(labelSet)
							.generator(randomNumberGeneratorId);
					Optional<PersonId> optional = environment.samplePartition(key, partitionSampler);
					assertTrue(optional.isPresent());
					PersonId selectedPersonId = optional.get();
					assertTrue(expectedPeople.contains(selectedPersonId));
				}
			}
			// show that a population query resulting in an empty partition cannot return a
			// randomly selected person
			Object key2 = "key2";
			partition = Partition.create().property(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function);
			environment.addPopulationPartition(partition, key2);
			LabelSet labelSet = LabelSet.create().property(TestPersonPropertyId.PERSON_PROPERTY_1, 1000);
			PartitionSampler partitionSampler = PartitionSampler.create().labelSet(labelSet);
			Optional<PersonId> optional = environment.samplePartition(key2, partitionSampler);
			assertFalse(optional.isPresent());

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);

	}

}
