package gcm.automated;

import static gcm.automated.support.EnvironmentSupport.addStandardComponentsAndTypes;
import static gcm.automated.support.EnvironmentSupport.addStandardPeople;
import static gcm.automated.support.EnvironmentSupport.addStandardPropertyDefinitions;
import static gcm.automated.support.EnvironmentSupport.addStandardTrackingAndScenarioId;
import static gcm.automated.support.EnvironmentSupport.addTaskPlanContainer;
import static gcm.automated.support.EnvironmentSupport.assertAllPlansExecuted;
import static gcm.automated.support.EnvironmentSupport.getRandomGenerator;
import static gcm.automated.support.EnvironmentSupport.getReplication;
import static gcm.automated.support.ExceptionAssertion.assertModelException;
import static gcm.simulation.partition.LabelSet.*;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Random;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

import org.apache.commons.math3.random.RandomGenerator;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import gcm.automated.support.EnvironmentSupport;
import gcm.automated.support.EnvironmentSupport.PropertyAssignmentPolicy;
import gcm.automated.support.SeedProvider;
import gcm.automated.support.TaskPlanContainer;
import gcm.automated.support.TestCompartmentId;
import gcm.automated.support.TestGlobalComponentId;
import gcm.automated.support.TestGroupTypeId;
import gcm.automated.support.TestPersonPropertyId;
import gcm.automated.support.TestRegionId;
import gcm.automated.support.TestResourceId;
import gcm.scenario.CompartmentId;
import gcm.scenario.GroupId;
import gcm.scenario.PersonId;
import gcm.scenario.PersonPropertyId;
import gcm.scenario.PropertyDefinition;
import gcm.scenario.RandomNumberGeneratorId;
import gcm.scenario.RegionId;
import gcm.scenario.ResourceId;
import gcm.scenario.Scenario;
import gcm.scenario.ScenarioBuilder;
import gcm.scenario.UnstructuredScenarioBuilder;
import gcm.simulation.Environment;
import gcm.simulation.EnvironmentImpl;
import gcm.simulation.Simulation;
import gcm.simulation.SimulationErrorType;
import gcm.simulation.partition.GroupTypeCountMap;
import gcm.simulation.partition.LabelSet;
import gcm.simulation.partition.LabelSetInfo;
import gcm.simulation.partition.PopulationPartitionDefinition;
import gcm.util.annotations.UnitTest;
import gcm.util.annotations.UnitTestMethod;

@UnitTest(target = EnvironmentImpl.class)

public class AT_EnvironmentImpl_25 {

	private static SeedProvider SEED_PROVIDER;

	@BeforeClass
	public static void beforeClass() {
		SEED_PROVIDER = new SeedProvider(EnvironmentSupport.getMetaSeed(25));
	}

	/**
	 * Internal test(not part of public tests) to show that there are no large gaps
	 * in the seed cases generated by the SeedProvider.
	 */
	@AfterClass
	public static void afterClass() {
		System.out
				.println(AT_EnvironmentImpl_25.class.getSimpleName() + " " + SEED_PROVIDER.generateUnusedSeedReport());
	}

	private static enum PartitionChoice {
		COMPARTMENT, REGION, PROPERTY1, PROPERTY2, RESOURCE1, RESOURCE2, GROUP;
	}

	private static void buildBaseScenario(ScenarioBuilder scenarioBuilder, RandomGenerator randomGenerator) {

		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		Map<Object, PropertyDefinition> forcedPropertyDefinitions = new LinkedHashMap<>();
		PropertyDefinition propertyDefinition = PropertyDefinition.builder().setType(Integer.class).setDefaultValue(0)
				.build();
		forcedPropertyDefinitions.put(TestPersonPropertyId.PERSON_PROPERTY_1, propertyDefinition);
		propertyDefinition = PropertyDefinition.builder().setType(String.class).setDefaultValue("nope").build();
		forcedPropertyDefinitions.put(TestPersonPropertyId.PERSON_PROPERTY_2, propertyDefinition);
		addStandardPropertyDefinitions(scenarioBuilder, forcedPropertyDefinitions, PropertyAssignmentPolicy.TRUE,
				randomGenerator);
		addStandardPeople(scenarioBuilder, 300);

	}

	// defines how we label compartments
	static Function<CompartmentId, Object> compartmentPartitionFunction = (CompartmentId compartmentId) -> {
		TestCompartmentId testCompartmentId = (TestCompartmentId) compartmentId;
		switch (testCompartmentId) {
		case COMPARTMENT_1:
		case COMPARTMENT_2:
		case COMPARTMENT_3:
			return 0;
		case COMPARTMENT_4:
		case COMPARTMENT_5:
		default:
			return 1;
		}
	};

	// defines how we label regions
	static Function<RegionId, Object> regionPartitionFunction = (RegionId regionId) -> {
		TestRegionId testRegionId = (TestRegionId) regionId;
		switch (testRegionId) {
		case REGION_1:
		case REGION_2:
			return 0;
		case REGION_3:
		case REGION_4:
			return 1;
		default:
			return 2;
		}
	};

	// defines how we label resource 1
	static Function<Long, Object> personResource1PartitionFunction = (Long value) -> {
		if (value == 0) {
			return "zilch";
		}
		if (value < 4) {
			return "some";
		}
		return "whoa";
	};

	// defines how we label resource 2
	static Function<Long, Object> personResource2PartitionFunction = (Long value) -> {
		if (value == 0) {
			return "none";
		}
		if (value < 2) {
			return "good";
		}
		return "too much";
	};

	// defines how we label property1 values
	static Function<Object, Object> property1Function = (Object value) -> ((Integer) value) % 2;

	// defines how we label property2 values
	static Function<Object, Object> property2Function = (Object value) -> ((String) value).length() % 3;

	// defines how we label group types
	static Function<GroupTypeCountMap, Object> groupPartitionFunction = (GroupTypeCountMap groupTypeCountMap) -> {
		int group1Count = groupTypeCountMap.getGroupCount(TestGroupTypeId.GROUP_TYPE_1);
		int group2Count = groupTypeCountMap.getGroupCount(TestGroupTypeId.GROUP_TYPE_2);
		return 2 * group1Count + group2Count;
	};

	// helps generate randomized values for property 1
	static Function<RandomGenerator, Integer> property1InitializerFunction = (RandomGenerator r) -> {
		return r.nextInt(2);
	};

	// helps generate randomized values for property 2
	static Function<RandomGenerator, String> property2InitializerFunction = (RandomGenerator r) -> {
		switch (r.nextInt(3)) {
		case 0:
			return "yep";
		case 1:
			return "nope";
		default:
			return "maybe";
		}
	};

	// helps generate randomized values for property 1
	static Function<RandomGenerator, Long> resource1InitializerFunction = (RandomGenerator r) -> {
		return (long) r.nextInt(5);
	};

	// helps generate randomized values for property 2
	static Function<RandomGenerator, Long> resource2InitializerFunction = (RandomGenerator r) -> {
		return (long) r.nextInt(4);
	};

	private static void makeRandomPersonAssignments(Environment environment, RandomGenerator randomGenerator) {
		// add some groups to the simulation
		List<GroupId> type1Groups = new ArrayList<>();
		List<GroupId> type2Groups = new ArrayList<>();
		for (int i = 0; i < 10; i++) {
			type1Groups.add(environment.addGroup(TestGroupTypeId.GROUP_TYPE_1));
			type2Groups.add(environment.addGroup(TestGroupTypeId.GROUP_TYPE_2));
		}

		List<PersonId> people = environment.getPeople();
		for (int i = 0; i < people.size(); i++) {
			PersonId personId = people.get(i);
			environment.setPersonPropertyValue(personId, TestPersonPropertyId.PERSON_PROPERTY_1,
					property1InitializerFunction.apply(randomGenerator));
			environment.setPersonPropertyValue(personId, TestPersonPropertyId.PERSON_PROPERTY_2,
					property2InitializerFunction.apply(randomGenerator));

			RegionId personRegion = environment.getPersonRegion(personId);

			long amount = resource1InitializerFunction.apply(randomGenerator);
			environment.addResourceToRegion(TestResourceId.RESOURCE1, personRegion, amount);
			environment.transferResourceToPerson(TestResourceId.RESOURCE1, personId, amount);

			amount = resource2InitializerFunction.apply(randomGenerator);
			environment.addResourceToRegion(TestResourceId.RESOURCE2, personRegion, amount);
			environment.transferResourceToPerson(TestResourceId.RESOURCE2, personId, amount);

			int groupCount = randomGenerator.nextInt(3);
			Collections.shuffle(type1Groups, new Random(randomGenerator.nextLong()));
			for (int j = 0; j < groupCount; j++) {
				GroupId groupId = type1Groups.get(j);
				environment.addPersonToGroup(personId, groupId);
			}

			groupCount = randomGenerator.nextInt(4);
			Collections.shuffle(type2Groups, new Random(randomGenerator.nextLong()));
			for (int j = 0; j < groupCount; j++) {
				GroupId groupId = type2Groups.get(j);
				environment.addPersonToGroup(personId, groupId);
			}

		}

	}

	private static Map<LabelSetInfo, Set<PersonId>> getExpectedPartitionedPeople(Environment environment,
			Set<PartitionChoice> partionChoices) {

		List<PersonId> people = environment.getPeople();
		Map<LabelSetInfo, Set<PersonId>> expectedPartitioning = new LinkedHashMap<>();
		for (PersonId personId : people) {
			// retrieve the various characteristics of the person and convert them into
			// labels
			RegionId personRegion = environment.getPersonRegion(personId);
			Object regionLabel = regionPartitionFunction.apply(personRegion);

			CompartmentId personCompartment = environment.getPersonCompartment(personId);
			Object compartmentLabel = compartmentPartitionFunction.apply(personCompartment);

			Object personProperty1Value = environment.getPersonPropertyValue(personId,
					TestPersonPropertyId.PERSON_PROPERTY_1);
			Object personProperty1Label = property1Function.apply(personProperty1Value);

			Object personProperty2Value = environment.getPersonPropertyValue(personId,
					TestPersonPropertyId.PERSON_PROPERTY_2);
			Object personProperty2Label = property2Function.apply(personProperty2Value);

			long personResource1Level = environment.getPersonResourceLevel(personId, TestResourceId.RESOURCE1);
			Object personResource1Label = personResource1PartitionFunction.apply(personResource1Level);

			long personResource2Level = environment.getPersonResourceLevel(personId, TestResourceId.RESOURCE2);
			Object personResource2Label = personResource2PartitionFunction.apply(personResource2Level);

			int groupCount1 = environment.getGroupCountForGroupTypeAndPerson(TestGroupTypeId.GROUP_TYPE_1, personId);
			int groupCount2 = environment.getGroupCountForGroupTypeAndPerson(TestGroupTypeId.GROUP_TYPE_2, personId);
			GroupTypeCountMap groupTypeCountMap = GroupTypeCountMap.builder()
					.setCount(TestGroupTypeId.GROUP_TYPE_1, groupCount1)
					.setCount(TestGroupTypeId.GROUP_TYPE_2, groupCount2).build();

			Object groupLabel = groupPartitionFunction.apply(groupTypeCountMap);

			// use the labels to create a label set that fits the person
			LabelSet labelSet = empty();
			for (PartitionChoice partitionChoice : partionChoices) {
				switch (partitionChoice) {
				case COMPARTMENT:
					labelSet = labelSet.with(compartment(compartmentLabel));
					break;
				case GROUP:
					labelSet = labelSet.with(group(groupLabel));
					break;
				case PROPERTY1:
					labelSet = labelSet.with(property(TestPersonPropertyId.PERSON_PROPERTY_1, personProperty1Label));
					break;
				case PROPERTY2:
					labelSet = labelSet.with(property(TestPersonPropertyId.PERSON_PROPERTY_2, personProperty2Label));
					break;
				case REGION:
					labelSet = labelSet.with(region(regionLabel));
					break;
				case RESOURCE1:
					labelSet = labelSet.with(resource(TestResourceId.RESOURCE1, personResource1Label));
					break;
				case RESOURCE2:
					labelSet = labelSet.with(resource(TestResourceId.RESOURCE2, personResource2Label));
					break;
				default:
					throw new RuntimeException("unhandled case");
				}
			}
			LabelSetInfo labelSetInfo = LabelSetInfo.build(labelSet);
			// add the population query to the expectedPartitioning if it is new and add the
			// person to the set of people we expect to be associated with this query
			Set<PersonId> partitionPeople = expectedPartitioning.get(labelSetInfo);
			if (partitionPeople == null) {
				partitionPeople = new LinkedHashSet<>();
				expectedPartitioning.put(labelSetInfo, partitionPeople);
			}
			partitionPeople.add(personId);
		}
		return expectedPartitioning;
	}

	private static PopulationPartitionDefinition createPopulationPartitionDefinition(
			Set<PartitionChoice> partionChoices) {
		PopulationPartitionDefinition.Builder builder = PopulationPartitionDefinition.builder();//

		for (PartitionChoice partitionChoice : partionChoices) {
			switch (partitionChoice) {
			case COMPARTMENT:
				builder.setCompartmentPartition(compartmentPartitionFunction);
				break;
			case GROUP:
				builder.setGroupPartitionFunction(groupPartitionFunction);
				break;
			case PROPERTY1:
				builder.setPersonPropertyPartition(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function);
				break;
			case PROPERTY2:
				builder.setPersonPropertyPartition(TestPersonPropertyId.PERSON_PROPERTY_2, property2Function);
				break;
			case REGION:
				builder.setRegionPartition(regionPartitionFunction);
				break;
			case RESOURCE1:
				builder.setPersonResourcePartition(TestResourceId.RESOURCE1, personResource1PartitionFunction);
				break;
			case RESOURCE2:
				builder.setPersonResourcePartition(TestResourceId.RESOURCE2, personResource2PartitionFunction);
				break;
			default:
				throw new RuntimeException("unhandled case");
			}
		}

		return builder.build();
	}

	private static LabelSet getLabelSet(LabelSetInfo labelSetInfo) {
		LabelSet result = empty();
		if (labelSetInfo.getCompartmentLabel() != null) {
			result = result.with(compartment(labelSetInfo.getCompartmentLabel()));
		}
		if (labelSetInfo.getRegionLabel() != null) {
			result = result.with(region(labelSetInfo.getRegionLabel()));
		}
		if (labelSetInfo.getGroupLabel() != null) {
			result = result.with(group(labelSetInfo.getGroupLabel()));
		}
		for (PersonPropertyId personPropertyId : labelSetInfo.getPersonPropertyIds()) {
			result = result.with(property(personPropertyId, labelSetInfo.getPersonPropertyLabel(personPropertyId)));
		}
		for (ResourceId recourceId : labelSetInfo.getPersonResourceIds()) {
			result = result.with(resource(recourceId, labelSetInfo.getPersonResourceLabel(recourceId)));
		}
		return result;
	}

	/**
	 * Tests {@link EnvironmentImpl#getPartitionSize(PersonPropertyId, Object)}
	 */
	@Test
	@UnitTestMethod(name = "getPartitionSize", args = { Object.class, LabelSet.class })
	public void testGetPartitionSize() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(1);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;
		Object key = "key";

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<PartitionChoice> partitionChoices = EnumSet.allOf(PartitionChoice.class);

			// define the partition
			PopulationPartitionDefinition populationPartitionDefinition = createPopulationPartitionDefinition(
					partitionChoices);

			// add the partition to the simulation
			environment.addPopulationPartition(populationPartitionDefinition, key);

			makeRandomPersonAssignments(environment, randomGenerator);

			// Group the people in the simulation by their labels, giving us the expected
			// partitioning
			Map<LabelSetInfo, Set<PersonId>> expectedPartitioning = getExpectedPartitionedPeople(environment,
					partitionChoices);

			// show that each labelSet corresponds to the expected number of
			// people
			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {
				LabelSet labelSet = getLabelSet(labelSetInfo);
				int expectedSize = expectedPartitioning.get(labelSetInfo).size();
				int actualSize = environment.getPartitionSize(key, labelSet);
				assertEquals(expectedSize, actualSize);
				
			}

			// We now reduce the partition choices so that each query will correspond to
			// multiple elements of the partition.
			partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT, PartitionChoice.REGION);

			expectedPartitioning = getExpectedPartitionedPeople(environment, partitionChoices);

			// show that each labelSet corresponds to the expected number of
			// people
			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {
				// System.out.println(labelSet);
				LabelSet labelSet = getLabelSet(labelSetInfo);
				int expectedSize = expectedPartitioning.get(labelSetInfo).size();
				int actualSize = environment.getPartitionSize(key, labelSet);
				assertEquals(expectedSize, actualSize);				
			}
		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key3 = "key3";
			PopulationPartitionDefinition populationPartitionDefinition = PopulationPartitionDefinition.builder()
					.setCompartmentPartition(compartmentPartitionFunction)
					.setPersonPropertyPartition(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function).build();
			environment.addPopulationPartition(populationPartitionDefinition, key3);

			LabelSet labelSet = compartment(0).with(property(TestPersonPropertyId.PERSON_PROPERTY_1, 1));
			LabelSet incompatiblelabelSet = compartment(0).with(property(TestPersonPropertyId.PERSON_PROPERTY_2, 1));

			// if the key is null
			assertModelException(() -> environment.getPartitionSize(null, labelSet),
					SimulationErrorType.NULL_POPULATION_PARTITION_KEY);
			// if the key does not correspond to an existing partition
			assertModelException(() -> environment.getPartitionSize("bad key", labelSet),
					SimulationErrorType.UNKNOWN_POPULATION_PARTITION_KEY);
			// if the label set is null
			assertModelException(() -> environment.getPartitionSize(key3, null), SimulationErrorType.NULL_LABEL_SET);
			// if the label set is incompatible with the partition
			assertModelException(() -> environment.getPartitionSize(key3, incompatiblelabelSet),
					SimulationErrorType.INCOMPATIBLE_LABEL_SET);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests
	 * {@link EnvironmentImpl#getRandomPartitionedPersonFromGenerator(Object, LabelSet, RandomNumberGeneratorId)
	 */
	@Test
	@UnitTestMethod(name = "getRandomPartitionedPersonFromGenerator", args = { Object.class,
			LabelSet.class, RandomNumberGeneratorId.class })
	public void testGetRandomPartitionedPersonFromGenerator() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(6);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		RandomNumberGeneratorId randomNumberGeneratorId = new RandomNumberGeneratorId() {
		};
		scenarioBuilder.addRandomNumberGeneratorId(randomNumberGeneratorId);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;
		Object key = "key";

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<PartitionChoice> partitionChoices = EnumSet.allOf(PartitionChoice.class);

			// define the partition
			PopulationPartitionDefinition populationPartitionDefinition = createPopulationPartitionDefinition(
					partitionChoices);

			// add the partition to the simulation
			environment.addPopulationPartition(populationPartitionDefinition, key);

			makeRandomPersonAssignments(environment, randomGenerator);

			// Group the people in the simulation by their labels, giving us the expected
			// partitioning

			Map<LabelSetInfo, Set<PersonId>> expectedPartitioning = getExpectedPartitionedPeople(
					environment, partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				// we know that each labelSet corresponds to at least one person
				for (int i = 0; i < 10; i++) {
					LabelSet labelSet = getLabelSet(labelSetInfo);				
					Optional<PersonId> optional = environment.getRandomPartitionedPersonFromGenerator(key,
							labelSet, randomNumberGeneratorId);
					assertTrue(optional.isPresent());
					PersonId selectedPersonId = optional.get();
					assertTrue(expectedPeople.contains(selectedPersonId));
				}
			}
			// We now reduce the partition choices so that each query will correspond to
			// multiple elements of the partition.
			partitionChoices = EnumSet.of(PartitionChoice.GROUP, PartitionChoice.REGION, PartitionChoice.RESOURCE1);
			expectedPartitioning = getExpectedPartitionedPeople(environment, partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				// we know that each labelSet corresponds to at least one person
				for (int i = 0; i < 10; i++) {
					LabelSet labelSet = getLabelSet(labelSetInfo);				
					Optional<PersonId> optional = environment.getRandomPartitionedPersonFromGenerator(key,
							labelSet, randomNumberGeneratorId);
					assertTrue(optional.isPresent());
					PersonId selectedPersonId = optional.get();
					assertTrue(expectedPeople.contains(selectedPersonId));
				}
			}
			// show that a population query resulting in an empty partition cannot return a
			// randomly selected person
			Object key2 = "key2";
			PopulationPartitionDefinition partitionDefinition = PopulationPartitionDefinition.builder()
					.setPersonPropertyPartition(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function).build();
			environment.addPopulationPartition(partitionDefinition, key2);
			LabelSet labelSet = property(TestPersonPropertyId.PERSON_PROPERTY_1, 1000);
			Optional<PersonId> optional = environment.getRandomPartitionedPerson(key2, labelSet);
			assertFalse(optional.isPresent());

		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key3 = "key3";
			PopulationPartitionDefinition populationPartitionDefinition = PopulationPartitionDefinition.builder()
					.setCompartmentPartition(compartmentPartitionFunction)
					.setPersonPropertyPartition(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function).build();
			environment.addPopulationPartition(populationPartitionDefinition, key3);

			LabelSet labelSet = compartment(0)
					.with(property(TestPersonPropertyId.PERSON_PROPERTY_1, 1));
			LabelSet incompatiblelabelSet =	compartment(0)
					.with(property(TestPersonPropertyId.PERSON_PROPERTY_2, 1));

			RandomNumberGeneratorId badRandomNumberGeneratorId = new RandomNumberGeneratorId() {
			};

			// if the key is null
			assertModelException(() -> environment.getRandomPartitionedPersonFromGenerator(null,
					labelSet, randomNumberGeneratorId),
					SimulationErrorType.NULL_POPULATION_PARTITION_KEY);
			// if the key does not correspond to an existing partition
			assertModelException(() -> environment.getRandomPartitionedPersonFromGenerator("bad key",
					labelSet, randomNumberGeneratorId),
					SimulationErrorType.UNKNOWN_POPULATION_PARTITION_KEY);
			// if the label set is null
			assertModelException(
					() -> environment.getRandomPartitionedPersonFromGenerator(key3, null, randomNumberGeneratorId),
					SimulationErrorType.NULL_LABEL_SET);
			// if the label set is incompatible with the partition
			assertModelException(
					() -> environment.getRandomPartitionedPersonFromGenerator(key3,
							incompatiblelabelSet, randomNumberGeneratorId),
					SimulationErrorType.INCOMPATIBLE_LABEL_SET);

			// if the randomNumberGeneratorId is null
			assertModelException(
					() -> environment.getRandomPartitionedPersonFromGenerator(key3, labelSet, null),
					SimulationErrorType.NULL_RANDOM_NUMBER_GENERATOR_ID);
			// if the randomNumberGeneratorId does not correspond to a known id
			assertModelException(() -> environment.getRandomPartitionedPersonFromGenerator(key3,
					labelSet, badRandomNumberGeneratorId),
					SimulationErrorType.UNKNOWN_RANDOM_NUMBER_GENERATOR_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests {@link
	 * EnvironmentImpl#getRandomPartitionedPersonWithExclusion(PersonId, Object,
	 * LabelSet)
	 */
	@Test
	@UnitTestMethod(name = "getRandomPartitionedPersonWithExclusion", args = { PersonId.class, Object.class,
			LabelSet.class })
	public void testGetRandomPartitionedPersonWithExclusion() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(5);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;
		Object key = "key";

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<PartitionChoice> partitionChoices = EnumSet.allOf(PartitionChoice.class);

			// define the partition
			PopulationPartitionDefinition populationPartitionDefinition = createPopulationPartitionDefinition(
					partitionChoices);

			// add the partition to the simulation
			environment.addPopulationPartition(populationPartitionDefinition, key);

			makeRandomPersonAssignments(environment, randomGenerator);

			// Group the people in the simulation by their labels, giving us the expected
			// partitioning
			Map<LabelSetInfo, Set<PersonId>> expectedPartitioning = getExpectedPartitionedPeople(
					environment, partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				List<PersonId> expectedPeopleList = new ArrayList<>(expectedPeople);
				Collections.shuffle(expectedPeopleList, new Random(randomGenerator.nextLong()));
				// we know that each labelSet corresponds to at least one person
				PersonId excludedPersonId = expectedPeopleList.get(0);

				for (int i = 0; i < 10; i++) {
					LabelSet labelSet = getLabelSet(labelSetInfo);
					Optional<PersonId> optional = environment.getRandomPartitionedPersonWithExclusion(excludedPersonId,
							key, labelSet);
					if (expectedPeople.size() > 1) {
						assertTrue(optional.isPresent());
						PersonId selectedPersonId = optional.get();
						assertTrue(expectedPeople.contains(selectedPersonId));
					} else {
						assertFalse(optional.isPresent());
					}
				}
			}
			
			// We now reduce the partition choices so that each query will correspond to
			// multiple elements of the partition.
			partitionChoices = EnumSet.of(
					PartitionChoice.COMPARTMENT,
					PartitionChoice.PROPERTY1,
					PartitionChoice.RESOURCE1
					);
			expectedPartitioning = getExpectedPartitionedPeople(
					environment, partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				List<PersonId> expectedPeopleList = new ArrayList<>(expectedPeople);
				Collections.shuffle(expectedPeopleList, new Random(randomGenerator.nextLong()));
				// we know that each labelSet corresponds to at least one person
				PersonId excludedPersonId = expectedPeopleList.get(0);

				for (int i = 0; i < 10; i++) {
					LabelSet labelSet = getLabelSet(labelSetInfo);
					Optional<PersonId> optional = environment.getRandomPartitionedPersonWithExclusion(excludedPersonId,
							key, labelSet);
					if (expectedPeople.size() > 1) {
						assertTrue(optional.isPresent());
						PersonId selectedPersonId = optional.get();
						assertTrue(expectedPeople.contains(selectedPersonId));
					} else {
						assertFalse(optional.isPresent());
					}
				}
			}
			// show that a population query resulting in an empty partition cannot return a
			// randomly selected person
			PersonId personId = new PersonId(0);
			Object key2 = "key2";
			PopulationPartitionDefinition partitionDefinition = PopulationPartitionDefinition.builder()
					.setPersonPropertyPartition(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function).build();
			environment.addPopulationPartition(partitionDefinition, key2);
			LabelSet labelSet = property(TestPersonPropertyId.PERSON_PROPERTY_1, 1000);
			Optional<PersonId> optional = environment.getRandomPartitionedPersonWithExclusion(personId, key2,
					labelSet);
			assertFalse(optional.isPresent());

			// show that a population query resulting in a partition containing only the
			// excluded person cannot return a randomly selected person
			environment.setPersonPropertyValue(personId, TestPersonPropertyId.PERSON_PROPERTY_1, 1000);
			optional = environment.getRandomPartitionedPersonWithExclusion(personId, key2, labelSet);
			assertFalse(optional.isPresent());
		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key3 = "key3";
			PopulationPartitionDefinition populationPartitionDefinition = PopulationPartitionDefinition.builder()
					.setCompartmentPartition(compartmentPartitionFunction)
					.setPersonPropertyPartition(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function).build();
			environment.addPopulationPartition(populationPartitionDefinition, key3);

			LabelSet labelSet = 
					compartment(0)
					.with(property(TestPersonPropertyId.PERSON_PROPERTY_1, 1));
			LabelSet incompatiblelabelSet = 
					compartment(0)
					.with(property(TestPersonPropertyId.PERSON_PROPERTY_2, 1));

			PersonId goodPersonId = new PersonId(0);
			PersonId badPersonId = new PersonId(1000000);

			// if the key is null
			assertModelException(() -> environment.getRandomPartitionedPersonWithExclusion(goodPersonId, null,
					labelSet), SimulationErrorType.NULL_POPULATION_PARTITION_KEY);
			// if the key does not correspond to an existing partition
			assertModelException(() -> environment.getRandomPartitionedPersonWithExclusion(goodPersonId, "bad key",
					labelSet), SimulationErrorType.UNKNOWN_POPULATION_PARTITION_KEY);

			// if the personId is null
			assertModelException(
					() -> environment.getRandomPartitionedPersonWithExclusion(null, key3, labelSet),
					SimulationErrorType.NULL_PERSON_ID);
			// if the personId does not correspond to an existing person
			assertModelException(() -> environment.getRandomPartitionedPersonWithExclusion(badPersonId, key3,
					labelSet), SimulationErrorType.UNKNOWN_PERSON_ID);

			// if the label set is null
			assertModelException(() -> environment.getRandomPartitionedPersonWithExclusion(goodPersonId, key3, null),
					SimulationErrorType.NULL_LABEL_SET);
			// if the label set is incompatible with the partition
			assertModelException(
					() -> environment.getRandomPartitionedPersonWithExclusion(goodPersonId, key3,
							incompatiblelabelSet),
					SimulationErrorType.INCOMPATIBLE_LABEL_SET);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests {@link EnvironmentImpl#getPartitionPeople(Object,
	 * LabelSet)
	 */
	@Test
	@UnitTestMethod(name = "getPartitionPeople", args = { Object.class, LabelSet.class })
	public void testGetPartitionPeople() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(0);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;
		Object key = "key";

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<PartitionChoice> partitionChoices = EnumSet.allOf(PartitionChoice.class);

			// define the partition
			PopulationPartitionDefinition populationPartitionDefinition = createPopulationPartitionDefinition(
					partitionChoices);

			// add the partition to the simulation
			environment.addPopulationPartition(populationPartitionDefinition, key);

			makeRandomPersonAssignments(environment, randomGenerator);

			// Group the people in the simulation by their labels, giving us the expected
			// partitioning -- each labelSet will correspond to exactly one
			// element of the partition

			Map<LabelSetInfo, Set<PersonId>> expectedPartitioning = getExpectedPartitionedPeople(
					environment, partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {
				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				LabelSet labelSet = getLabelSet(labelSetInfo);
				List<PersonId> partitionPeople = environment.getPartitionPeople(key, labelSet);
				assertEquals(expectedPeople.size(), partitionPeople.size());
				Set<PersonId> actualPeople = partitionPeople.stream().collect(Collectors.toSet());
				assertEquals(expectedPeople, actualPeople);
			}

			// We now reduce the partition choices so that each query will correspond to
			// multiple elements of the partition.
			partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT, PartitionChoice.PROPERTY1);
			expectedPartitioning = getExpectedPartitionedPeople(environment, partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {
				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				LabelSet labelSet = getLabelSet(labelSetInfo);
				List<PersonId> partitionPeople = environment.getPartitionPeople(key, labelSet);
				assertEquals(expectedPeople.size(), partitionPeople.size());
				Set<PersonId> actualPeople = partitionPeople.stream().collect(Collectors.toSet());
				assertEquals(expectedPeople, actualPeople);
			}
		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key3 = "key3";
			PopulationPartitionDefinition populationPartitionDefinition = PopulationPartitionDefinition.builder()
					.setCompartmentPartition(compartmentPartitionFunction)
					.setPersonPropertyPartition(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function).build();
			environment.addPopulationPartition(populationPartitionDefinition, key3);

			LabelSet labelSet = compartment(0)
					.with(property(TestPersonPropertyId.PERSON_PROPERTY_1, 1));
			LabelSet incompatiblelabelSet = compartment(0)
					.with(property(TestPersonPropertyId.PERSON_PROPERTY_2, 1));

			// if the key is null
			assertModelException(() -> environment.getPartitionPeople(null, labelSet),
					SimulationErrorType.NULL_POPULATION_PARTITION_KEY);
			// if the key does not correspond to an existing partition
			assertModelException(() -> environment.getPartitionPeople("bad key", labelSet),
					SimulationErrorType.UNKNOWN_POPULATION_PARTITION_KEY);
			// if the label set is null
			assertModelException(() -> environment.getPartitionPeople(key3, null),
					SimulationErrorType.NULL_LABEL_SET);
			// if the label set is incompatible with the partition
			assertModelException(() -> environment.getPartitionPeople(key3, incompatiblelabelSet),
					SimulationErrorType.INCOMPATIBLE_LABEL_SET);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link
	 * EnvironmentImpl#addPopulationPartition(PopulationPartitionDefinition, Object)
	 */
	@Test
	@UnitTestMethod(name = "addPopulationPartition", args = { PopulationPartitionDefinition.class, Object.class })
	public void testAddPopulationPartition() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(8);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key = "key";
			Set<PartitionChoice> partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT);
			PopulationPartitionDefinition populationPartitionDefinition = createPopulationPartitionDefinition(
					partitionChoices);
			environment.addPopulationPartition(populationPartitionDefinition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePopulationPartition(key);
			assertFalse(environment.populationPartitionExists(key));

			partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT, PartitionChoice.PROPERTY1);
			populationPartitionDefinition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPopulationPartition(populationPartitionDefinition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePopulationPartition(key);
			assertFalse(environment.populationPartitionExists(key));

			partitionChoices = EnumSet.of(PartitionChoice.GROUP, PartitionChoice.PROPERTY1);
			populationPartitionDefinition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPopulationPartition(populationPartitionDefinition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePopulationPartition(key);
			assertFalse(environment.populationPartitionExists(key));

		});

		/*
		 * Precondition tests -- none
		 */

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key1 = "key1";
			Object key2 = "key2";
			PopulationPartitionDefinition populationPartitionDefinition = PopulationPartitionDefinition.builder()
					.setCompartmentPartition(compartmentPartitionFunction)
					.setPersonPropertyPartition(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function).build();

			PopulationPartitionDefinition badPersonPropertyPopulationPartitionDefinition = PopulationPartitionDefinition
					.builder().setCompartmentPartition(compartmentPartitionFunction)
					.setPersonPropertyPartition(TestPersonPropertyId.getUnknownPersonPropertyId(), property1Function)
					.build();

			PopulationPartitionDefinition badResourcePopulationPartitionDefinition = PopulationPartitionDefinition
					.builder().setCompartmentPartition(compartmentPartitionFunction)
					.setPersonResourcePartition(TestResourceId.getUnknownResourceId(), personResource1PartitionFunction)
					.build();

			environment.addPopulationPartition(populationPartitionDefinition, key1);

			// if the population partition definition is null
			assertModelException(() -> environment.addPopulationPartition(null, key2),
					SimulationErrorType.NULL_POPULATION_PARTITION_DEFINITION);

			// if the key is null
			assertModelException(() -> environment.addPopulationPartition(populationPartitionDefinition, null),
					SimulationErrorType.NULL_POPULATION_PARTITION_KEY);

			// if the key corresponds to an existing population partition
			assertModelException(() -> environment.addPopulationPartition(populationPartitionDefinition, key1),
					SimulationErrorType.DUPLICATE_POPULATION_PARTITION);

			// if the definition contains an unknown person property id
			assertModelException(
					() -> environment.addPopulationPartition(badPersonPropertyPopulationPartitionDefinition, key2),
					SimulationErrorType.UNKNOWN_PERSON_PROPERTY_ID);

			// if the definition contains an unknown resource id
			assertModelException(
					() -> environment.addPopulationPartition(badResourcePopulationPartitionDefinition, key2),
					SimulationErrorType.UNKNOWN_RESOURCE_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#removePopulationPartition(Object)
	 */
	@Test
	@UnitTestMethod(name = "removePopulationPartition", args = { Object.class })
	public void testRemovePopulationPartition() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(9);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key = "key";
			Set<PartitionChoice> partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT);
			PopulationPartitionDefinition populationPartitionDefinition = createPopulationPartitionDefinition(
					partitionChoices);
			environment.addPopulationPartition(populationPartitionDefinition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePopulationPartition(key);
			assertFalse(environment.populationPartitionExists(key));

			partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT, PartitionChoice.PROPERTY1);
			populationPartitionDefinition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPopulationPartition(populationPartitionDefinition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePopulationPartition(key);
			assertFalse(environment.populationPartitionExists(key));

			partitionChoices = EnumSet.of(PartitionChoice.GROUP, PartitionChoice.PROPERTY1);
			populationPartitionDefinition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPopulationPartition(populationPartitionDefinition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePopulationPartition(key);
			assertFalse(environment.populationPartitionExists(key));

		});

		/*
		 * Precondition tests -- none
		 */

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// if the key is null
			assertModelException(() -> environment.removePopulationPartition(null),
					SimulationErrorType.NULL_POPULATION_PARTITION_KEY);

			// if the key does not correspond to an existing population index
			assertModelException(() -> environment.removePopulationPartition("unknown key"),
					SimulationErrorType.UNKNOWN_POPULATION_PARTITION_KEY);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#populationPartitionExists(Object)
	 */
	@Test
	@UnitTestMethod(name = "populationPartitionExists", args = { Object.class })
	public void testPopulationPartitionExists() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(3);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key = "key";
			Set<PartitionChoice> partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT);
			PopulationPartitionDefinition populationPartitionDefinition = createPopulationPartitionDefinition(
					partitionChoices);
			environment.addPopulationPartition(populationPartitionDefinition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePopulationPartition(key);
			assertFalse(environment.populationPartitionExists(key));

			partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT, PartitionChoice.PROPERTY1);
			populationPartitionDefinition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPopulationPartition(populationPartitionDefinition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePopulationPartition(key);
			assertFalse(environment.populationPartitionExists(key));

			partitionChoices = EnumSet.of(PartitionChoice.GROUP, PartitionChoice.PROPERTY1);
			populationPartitionDefinition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPopulationPartition(populationPartitionDefinition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePopulationPartition(key);
			assertFalse(environment.populationPartitionExists(key));

		});

		/*
		 * Precondition tests -- none
		 */

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests {@link EnvironmentImpl#personIsInPopulationPartition(PersonId, Object,
	 * LabelSet)
	 */
	@Test
	@UnitTestMethod(name = "personIsInPopulationPartition", args = { PersonId.class, Object.class,
			LabelSet.class })
	public void testPersonIsInPopulationPartition() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(2);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;
		Object key = "key";

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<PartitionChoice> partitionChoices = EnumSet.allOf(PartitionChoice.class);

			// define the partition
			PopulationPartitionDefinition populationPartitionDefinition = createPopulationPartitionDefinition(
					partitionChoices);

			// add the partition to the simulation
			environment.addPopulationPartition(populationPartitionDefinition, key);

			makeRandomPersonAssignments(environment, randomGenerator);

			// Group the people in the simulation by their labels, giving us the expected
			// partitioning
			Map<LabelSetInfo, Set<PersonId>> expectedPartitioning = getExpectedPartitionedPeople(
					environment, partitionChoices);

			// show that each labelSet corresponds to the expected number of
			// people

			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				for (PersonId personId : expectedPeople) {
					LabelSet labelSet = getLabelSet(labelSetInfo);
					assertTrue(environment.personIsInPopulationPartition(personId, key, labelSet));
				}
			}
			
			// We now reduce the partition choices so that each query will correspond to
			// multiple elements of the partition.
			partitionChoices = EnumSet.of(
					PartitionChoice.PROPERTY1,
					PartitionChoice.PROPERTY2,
					PartitionChoice.RESOURCE1,
					PartitionChoice.RESOURCE2
					);
			
			expectedPartitioning = getExpectedPartitionedPeople(
					environment, partitionChoices);

			// show that each labelSet corresponds to the expected number of
			// people

			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				for (PersonId personId : expectedPeople) {
					LabelSet labelSet = getLabelSet(labelSetInfo);
					assertTrue(environment.personIsInPopulationPartition(personId, key, labelSet));
				}
			}
			
		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			Object key3 = "key3";
			PopulationPartitionDefinition populationPartitionDefinition = PopulationPartitionDefinition.builder()
					.setCompartmentPartition(compartmentPartitionFunction)
					.setPersonPropertyPartition(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function).build();
			environment.addPopulationPartition(populationPartitionDefinition, key3);

			LabelSet labelSet = compartment(0)
					.with(property(TestPersonPropertyId.PERSON_PROPERTY_1, 1));
			LabelSet incompatiblelabelSet = compartment(0)
					.with(property(TestPersonPropertyId.PERSON_PROPERTY_2, 1));
			PersonId goodPersonId = new PersonId(0);
			PersonId badPersonId = new PersonId(10000000);

			// if the key is null
			assertModelException(
					() -> environment.personIsInPopulationPartition(goodPersonId, null, labelSet),
					SimulationErrorType.NULL_POPULATION_PARTITION_KEY);
			// if the key does not correspond to an existing partition
			assertModelException(
					() -> environment.personIsInPopulationPartition(goodPersonId, "bad key", labelSet),
					SimulationErrorType.UNKNOWN_POPULATION_PARTITION_KEY);

			// if the personId is null
			assertModelException(() -> environment.personIsInPopulationPartition(null, key3, labelSet),
					SimulationErrorType.NULL_PERSON_ID);
			// if the personId does not correspond to an existing person
			assertModelException(
					() -> environment.personIsInPopulationPartition(badPersonId, key3, labelSet),
					SimulationErrorType.UNKNOWN_PERSON_ID);

			// if the label set is null
			assertModelException(() -> environment.personIsInPopulationPartition(goodPersonId, key3, null),
					SimulationErrorType.NULL_LABEL_SET);
			// if the label set is incompatible with the partition
			assertModelException(
					() -> environment.personIsInPopulationPartition(goodPersonId, key3,
							incompatiblelabelSet),
					SimulationErrorType.INCOMPATIBLE_LABEL_SET);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getRandomPartitionedPerson(Object,
	 * LabelSet)
	 */
	@Test
	@UnitTestMethod(name = "getRandomPartitionedPerson", args = { Object.class, LabelSet.class })
	public void testGetRandomPartitionedPerson() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(4);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;
		Object key = "key";

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<PartitionChoice> partitionChoices = EnumSet.allOf(PartitionChoice.class);

			// define the partition
			PopulationPartitionDefinition populationPartitionDefinition = createPopulationPartitionDefinition(
					partitionChoices);

			// add the partition to the simulation
			environment.addPopulationPartition(populationPartitionDefinition, key);

			makeRandomPersonAssignments(environment, randomGenerator);

			// Group the people in the simulation by their labels, giving us the expected
			// partitioning
			Map<LabelSetInfo, Set<PersonId>> expectedPartitioning = getExpectedPartitionedPeople(
					environment, partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				// we know that each labelSet corresponds to at least one person
				for (int i = 0; i < 10; i++) {
					LabelSet labelSet = getLabelSet(labelSetInfo);
					Optional<PersonId> optional = environment.getRandomPartitionedPerson(key, labelSet);
					assertTrue(optional.isPresent());
					PersonId selectedPersonId = optional.get();
					assertTrue(expectedPeople.contains(selectedPersonId));
				}
			}
			
			// We now reduce the partition choices so that each query will correspond to
			// multiple elements of the partition.
			partitionChoices = EnumSet.of(
					PartitionChoice.PROPERTY1,
					PartitionChoice.PROPERTY2,
					PartitionChoice.GROUP,
					PartitionChoice.COMPARTMENT
					);
			expectedPartitioning = getExpectedPartitionedPeople(
					environment, partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				// we know that each labelSet corresponds to at least one person
				for (int i = 0; i < 10; i++) {
					LabelSet labelSet = getLabelSet(labelSetInfo);
					Optional<PersonId> optional = environment.getRandomPartitionedPerson(key, labelSet);
					assertTrue(optional.isPresent());
					PersonId selectedPersonId = optional.get();
					assertTrue(expectedPeople.contains(selectedPersonId));
				}
			}
			// show that a population query resulting in an empty partition cannot return a
			// randomly selected person
			Object key2 = "key2";
			PopulationPartitionDefinition partitionDefinition = PopulationPartitionDefinition.builder()
					.setPersonPropertyPartition(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function).build();
			environment.addPopulationPartition(partitionDefinition, key2);
			LabelSet labelSet = property(TestPersonPropertyId.PERSON_PROPERTY_1, 1000);
			Optional<PersonId> optional = environment.getRandomPartitionedPerson(key2, labelSet);
			assertFalse(optional.isPresent());

		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key3 = "key3";
			PopulationPartitionDefinition populationPartitionDefinition = PopulationPartitionDefinition.builder()
					.setCompartmentPartition(compartmentPartitionFunction)
					.setPersonPropertyPartition(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function).build();
			environment.addPopulationPartition(populationPartitionDefinition, key3);

			LabelSet labelSet = compartment(0)
					.with(property(TestPersonPropertyId.PERSON_PROPERTY_1, 1));
			LabelSet incompatiblelabelSet = compartment(0)
					.with(property(TestPersonPropertyId.PERSON_PROPERTY_2, 1));

			// if the key is null
			assertModelException(() -> environment.getRandomPartitionedPerson(null, labelSet),
					SimulationErrorType.NULL_POPULATION_PARTITION_KEY);
			// if the key does not correspond to an existing partition
			assertModelException(() -> environment.getRandomPartitionedPerson("bad key", labelSet),
					SimulationErrorType.UNKNOWN_POPULATION_PARTITION_KEY);
			// if the label set is null
			assertModelException(() -> environment.getRandomPartitionedPerson(key3, null),
					SimulationErrorType.NULL_LABEL_SET);
			// if the label set is incompatible with the partition
			assertModelException(
					() -> environment.getRandomPartitionedPerson(key3, incompatiblelabelSet),
					SimulationErrorType.INCOMPATIBLE_LABEL_SET);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests {@link
	 * EnvironmentImpl#getRandomPartitionedPersonWithExclusionFromGenerator(PersonId,
	 * Object, LabelSet, RandomNumberGeneratorId)
	 */
	@Test
	@UnitTestMethod(name = "getRandomPartitionedPersonWithExclusionFromGenerator", args = { PersonId.class,
			Object.class, LabelSet.class, RandomNumberGeneratorId.class })
	public void testGetRandomPartitionedPersonWithExclusionFromGenerator() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(7);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		RandomNumberGeneratorId randomNumberGeneratorId = new RandomNumberGeneratorId() {
		};
		scenarioBuilder.addRandomNumberGeneratorId(randomNumberGeneratorId);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;
		Object key = "key";

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<PartitionChoice> partitionChoices = EnumSet.allOf(PartitionChoice.class);

			// define the partition
			PopulationPartitionDefinition populationPartitionDefinition = createPopulationPartitionDefinition(
					partitionChoices);

			// add the partition to the simulation
			environment.addPopulationPartition(populationPartitionDefinition, key);

			makeRandomPersonAssignments(environment, randomGenerator);

			// Group the people in the simulation by their labels, giving us the expected
			// partitioning
			Map<LabelSetInfo, Set<PersonId>> expectedPartitioning = getExpectedPartitionedPeople(
					environment, partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				List<PersonId> expectedPeopleList = new ArrayList<>(expectedPeople);
				Collections.shuffle(expectedPeopleList, new Random(randomGenerator.nextLong()));
				// we know that each labelSet corresponds to at least one person
				PersonId excludedPersonId = expectedPeopleList.get(0);

				for (int i = 0; i < 10; i++) {
					LabelSet labelSet = getLabelSet(labelSetInfo);
					Optional<PersonId> optional = environment.getRandomPartitionedPersonWithExclusionFromGenerator(
							excludedPersonId, key, labelSet, randomNumberGeneratorId);
					if (expectedPeople.size() > 1) {
						assertTrue(optional.isPresent());
						PersonId selectedPersonId = optional.get();
						assertTrue(expectedPeople.contains(selectedPersonId));
					} else {
						assertFalse(optional.isPresent());
					}
				}
			}

			// We now reduce the partition choices so that each query will correspond to
			// multiple elements of the partition.

			partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT, PartitionChoice.GROUP,
					PartitionChoice.RESOURCE2);
			expectedPartitioning = getExpectedPartitionedPeople(environment, partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSetInfo labelSetInfo : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSetInfo);
				List<PersonId> expectedPeopleList = new ArrayList<>(expectedPeople);
				Collections.shuffle(expectedPeopleList, new Random(randomGenerator.nextLong()));
				// we know that each labelSet corresponds to at least one person
				PersonId excludedPersonId = expectedPeopleList.get(0);

				for (int i = 0; i < 10; i++) {
					LabelSet labelSet = getLabelSet(labelSetInfo); 
					Optional<PersonId> optional = environment.getRandomPartitionedPersonWithExclusionFromGenerator(
							excludedPersonId, key, labelSet, randomNumberGeneratorId);
					if (expectedPeople.size() > 1) {
						assertTrue(optional.isPresent());
						PersonId selectedPersonId = optional.get();
						assertTrue(expectedPeople.contains(selectedPersonId));
					} else {
						assertFalse(optional.isPresent());
					}
				}
			}

			// show that a population query resulting in an empty partition cannot return a
			// randomly selected person
			PersonId personId = new PersonId(0);
			Object key2 = "key2";
			PopulationPartitionDefinition partitionDefinition = PopulationPartitionDefinition.builder()
					.setPersonPropertyPartition(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function).build();
			environment.addPopulationPartition(partitionDefinition, key2);
			LabelSet labelSet = property(TestPersonPropertyId.PERSON_PROPERTY_1, 1000);
			Optional<PersonId> optional = environment.getRandomPartitionedPersonWithExclusionFromGenerator(personId,
					key2, labelSet, randomNumberGeneratorId);
			assertFalse(optional.isPresent());

			// show that a population query resulting in a partition containing only the
			// excluded person cannot return a randomly selected person
			environment.setPersonPropertyValue(personId, TestPersonPropertyId.PERSON_PROPERTY_1, 1000);
			optional = environment.getRandomPartitionedPersonWithExclusion(personId, key2, labelSet);
			assertFalse(optional.isPresent());
		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key3 = "key3";
			PopulationPartitionDefinition populationPartitionDefinition = PopulationPartitionDefinition.builder()
					.setCompartmentPartition(compartmentPartitionFunction)
					.setPersonPropertyPartition(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function).build();
			environment.addPopulationPartition(populationPartitionDefinition, key3);

			LabelSet labelSet = compartment(0)
					.with(property(TestPersonPropertyId.PERSON_PROPERTY_1, 1));
			LabelSet incompatiblelabelSet = compartment(0)
					.with(property(TestPersonPropertyId.PERSON_PROPERTY_2, 1));

			PersonId goodPersonId = new PersonId(0);
			PersonId badPersonId = new PersonId(1000000);

			RandomNumberGeneratorId badRandomNumberGeneratorId = new RandomNumberGeneratorId() {
			};

			// if the key is null
			assertModelException(
					() -> environment.getRandomPartitionedPersonWithExclusionFromGenerator(goodPersonId, null,
							labelSet, randomNumberGeneratorId),
					SimulationErrorType.NULL_POPULATION_PARTITION_KEY);
			// if the key does not correspond to an existing partition
			assertModelException(() -> environment.getRandomPartitionedPersonWithExclusion(goodPersonId, "bad key",
					labelSet), SimulationErrorType.UNKNOWN_POPULATION_PARTITION_KEY);

			// if the personId is null
			assertModelException(() -> environment.getRandomPartitionedPersonWithExclusionFromGenerator(null, key3,
					labelSet, randomNumberGeneratorId), SimulationErrorType.NULL_PERSON_ID);
			// if the personId does not correspond to an existing person
			assertModelException(() -> environment.getRandomPartitionedPersonWithExclusion(badPersonId, key3,
					labelSet), SimulationErrorType.UNKNOWN_PERSON_ID);

			// if the label set is null
			assertModelException(() -> environment.getRandomPartitionedPersonWithExclusionFromGenerator(goodPersonId,
					key3, null, randomNumberGeneratorId), SimulationErrorType.NULL_LABEL_SET);
			// if the label set is incompatible with the partition
			assertModelException(
					() -> environment.getRandomPartitionedPersonWithExclusionFromGenerator(goodPersonId, key3,
							incompatiblelabelSet, randomNumberGeneratorId),
					SimulationErrorType.INCOMPATIBLE_LABEL_SET);

			// if the random number generator id is null
			assertModelException(() -> environment.getRandomPartitionedPersonWithExclusionFromGenerator(goodPersonId,
					key3, labelSet, null), SimulationErrorType.NULL_RANDOM_NUMBER_GENERATOR_ID);
			// if the random number generator id is unknown
			assertModelException(
					() -> environment.getRandomPartitionedPersonWithExclusionFromGenerator(goodPersonId, key3,
							labelSet, badRandomNumberGeneratorId),
					SimulationErrorType.UNKNOWN_RANDOM_NUMBER_GENERATOR_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);
	}

}
