package gcm.automated;

import static gcm.automated.support.EnvironmentSupport.addStandardComponentsAndTypes;
import static gcm.automated.support.EnvironmentSupport.addStandardPeople;
import static gcm.automated.support.EnvironmentSupport.addStandardPropertyDefinitions;
import static gcm.automated.support.EnvironmentSupport.addStandardTrackingAndScenarioId;
import static gcm.automated.support.EnvironmentSupport.addTaskPlanContainer;
import static gcm.automated.support.EnvironmentSupport.assertAllPlansExecuted;
import static gcm.automated.support.EnvironmentSupport.getRandomGenerator;
import static gcm.automated.support.EnvironmentSupport.getReplication;
import static gcm.automated.support.ExceptionAssertion.assertModelException;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Random;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

import org.apache.commons.math3.random.RandomGenerator;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import gcm.automated.support.EnvironmentSupport;
import gcm.automated.support.EnvironmentSupport.PropertyAssignmentPolicy;
import gcm.automated.support.SeedProvider;
import gcm.automated.support.TaskPlanContainer;
import gcm.automated.support.TestCompartmentId;
import gcm.automated.support.TestGlobalComponentId;
import gcm.automated.support.TestGroupTypeId;
import gcm.automated.support.TestPersonPropertyId;
import gcm.automated.support.TestRandomGeneratorId;
import gcm.automated.support.TestRegionId;
import gcm.automated.support.TestResourceId;
import gcm.replication.Replication;
import gcm.scenario.CompartmentId;
import gcm.scenario.GroupId;
import gcm.scenario.PersonId;
import gcm.scenario.PersonPropertyId;
import gcm.scenario.PropertyDefinition;
import gcm.scenario.RandomNumberGeneratorId;
import gcm.scenario.RegionId;
import gcm.scenario.Scenario;
import gcm.scenario.ScenarioBuilder;
import gcm.scenario.UnstructuredScenarioBuilder;
import gcm.simulation.Environment;
import gcm.simulation.EnvironmentImpl;
import gcm.simulation.Equality;
import gcm.simulation.Simulation;
import gcm.simulation.SimulationErrorType;
import gcm.simulation.partition.Filter;
import gcm.simulation.partition.GroupTypeCountMap;
import gcm.simulation.partition.LabelSet;
import gcm.simulation.partition.Partition;
import gcm.simulation.partition.Partition.Builder;
import gcm.simulation.partition.PartitionSampler;
import gcm.util.annotations.UnitTest;
import gcm.util.annotations.UnitTestMethod;

@UnitTest(target = EnvironmentImpl.class)

public class AT_EnvironmentImpl_25 {

	private static SeedProvider SEED_PROVIDER;

	@BeforeAll
	public static void beforeClass() {
		SEED_PROVIDER = new SeedProvider(EnvironmentSupport.getMetaSeed(25));
	}

	/**
	 * Internal test(not part of public tests) to show that there are no large gaps
	 * in the seed cases generated by the SeedProvider.
	 */
	@AfterAll
	public static void afterClass() {
//		System.out.println(AT_EnvironmentImpl_25.class.getSimpleName() + " " + SEED_PROVIDER.generateUnusedSeedReport());
	}

	

	private static enum PartitionChoice {
		COMPARTMENT, REGION, PROPERTY1, PROPERTY2, RESOURCE1, RESOURCE2, GROUP;
	}

	private static void buildBaseScenario(ScenarioBuilder scenarioBuilder, RandomGenerator randomGenerator) {

		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		Map<Object, PropertyDefinition> forcedPropertyDefinitions = new LinkedHashMap<>();
		PropertyDefinition propertyDefinition = PropertyDefinition.builder().setType(Integer.class).setDefaultValue(0)
				.build();
		forcedPropertyDefinitions.put(TestPersonPropertyId.PERSON_PROPERTY_1, propertyDefinition);
		propertyDefinition = PropertyDefinition.builder().setType(String.class).setDefaultValue("nope").build();
		forcedPropertyDefinitions.put(TestPersonPropertyId.PERSON_PROPERTY_2, propertyDefinition);
		addStandardPropertyDefinitions(scenarioBuilder, forcedPropertyDefinitions, PropertyAssignmentPolicy.TRUE,
				randomGenerator);
		addStandardPeople(scenarioBuilder, 300);

	}

	// defines how we label compartments
	static Function<CompartmentId, Object> compartmentPartitionFunction = (CompartmentId compartmentId) -> {
		TestCompartmentId testCompartmentId = (TestCompartmentId) compartmentId;
		switch (testCompartmentId) {
		case COMPARTMENT_1:
		case COMPARTMENT_2:
		case COMPARTMENT_3:
			return 0;
		case COMPARTMENT_4:
		case COMPARTMENT_5:
		default:
			return 1;
		}
	};

	// defines how we label regions
	static Function<RegionId, Object> regionPartitionFunction = (RegionId regionId) -> {
		TestRegionId testRegionId = (TestRegionId) regionId;
		switch (testRegionId) {
		case REGION_1:
		case REGION_2:
			return 0;
		case REGION_3:
		case REGION_4:
			return 1;
		default:
			return 2;
		}
	};

	// defines how we label resource 1
	static Function<Long, Object> personResource1PartitionFunction = (Long value) -> {
		if (value == 0) {
			return "zilch";
		}
		if (value < 4) {
			return "some";
		}
		return "whoa";
	};

	// defines how we label resource 2
	static Function<Long, Object> personResource2PartitionFunction = (Long value) -> {
		if (value == 0) {
			return "none";
		}
		if (value < 2) {
			return "good";
		}
		return "too much";
	};

	// defines how we label property1 values
	static Function<Object, Object> property1Function = (Object value) -> ((Integer) value) % 2;

	// defines how we label property2 values
	static Function<Object, Object> property2Function = (Object value) -> ((String) value).length() % 3;

	// defines how we label group types
	static Function<GroupTypeCountMap, Object> groupPartitionFunction = (GroupTypeCountMap groupTypeCountMap) -> {
		int group1Count = groupTypeCountMap.getGroupCount(TestGroupTypeId.GROUP_TYPE_1);
		int group2Count = groupTypeCountMap.getGroupCount(TestGroupTypeId.GROUP_TYPE_2);
		return 2 * group1Count + group2Count;
	};

	// helps generate randomized values for property 1
	static Function<RandomGenerator, Integer> property1InitializerFunction = (RandomGenerator r) -> {
		return r.nextInt(2);
	};

	// helps generate randomized values for property 2
	static Function<RandomGenerator, String> property2InitializerFunction = (RandomGenerator r) -> {
		switch (r.nextInt(3)) {
		case 0:
			return "yep";
		case 1:
			return "nope";
		default:
			return "maybe";
		}
	};

	// helps generate randomized values for property 1
	static Function<RandomGenerator, Long> resource1InitializerFunction = (RandomGenerator r) -> {
		return (long) r.nextInt(5);
	};

	// helps generate randomized values for property 2
	static Function<RandomGenerator, Long> resource2InitializerFunction = (RandomGenerator r) -> {
		return (long) r.nextInt(4);
	};

	private static void makeRandomPersonAssignments(Environment environment, RandomGenerator randomGenerator) {
		// add some groups to the simulation
		List<GroupId> type1Groups = new ArrayList<>();
		List<GroupId> type2Groups = new ArrayList<>();
		for (int i = 0; i < 10; i++) {
			type1Groups.add(environment.addGroup(TestGroupTypeId.GROUP_TYPE_1));
			type2Groups.add(environment.addGroup(TestGroupTypeId.GROUP_TYPE_2));
		}

		List<PersonId> people = environment.getPeople();
		for (int i = 0; i < people.size(); i++) {
			PersonId personId = people.get(i);
			environment.setPersonPropertyValue(personId, TestPersonPropertyId.PERSON_PROPERTY_1,
					property1InitializerFunction.apply(randomGenerator));
			environment.setPersonPropertyValue(personId, TestPersonPropertyId.PERSON_PROPERTY_2,
					property2InitializerFunction.apply(randomGenerator));

			RegionId personRegion = environment.getPersonRegion(personId);

			long amount = resource1InitializerFunction.apply(randomGenerator);
			environment.addResourceToRegion(TestResourceId.RESOURCE1, personRegion, amount);
			environment.transferResourceToPerson(TestResourceId.RESOURCE1, personId, amount);

			amount = resource2InitializerFunction.apply(randomGenerator);
			environment.addResourceToRegion(TestResourceId.RESOURCE2, personRegion, amount);
			environment.transferResourceToPerson(TestResourceId.RESOURCE2, personId, amount);

			int groupCount = randomGenerator.nextInt(3);
			Collections.shuffle(type1Groups, new Random(randomGenerator.nextLong()));
			for (int j = 0; j < groupCount; j++) {
				GroupId groupId = type1Groups.get(j);
				environment.addPersonToGroup(personId, groupId);
			}

			groupCount = randomGenerator.nextInt(4);
			Collections.shuffle(type2Groups, new Random(randomGenerator.nextLong()));
			for (int j = 0; j < groupCount; j++) {
				GroupId groupId = type2Groups.get(j);
				environment.addPersonToGroup(personId, groupId);
			}

		}

	}

	private static Map<LabelSet, Set<PersonId>> getExpectedPartitionedPeople(Environment environment,
			Set<PartitionChoice> partionChoices) {

		List<PersonId> people = environment.getPeople();
		Map<LabelSet, Set<PersonId>> expectedPartitioning = new LinkedHashMap<>();
		for (PersonId personId : people) {
			// retrieve the various characteristics of the person and convert them into
			// labels
			RegionId personRegion = environment.getPersonRegion(personId);
			Object regionLabel = regionPartitionFunction.apply(personRegion);

			CompartmentId personCompartment = environment.getPersonCompartment(personId);
			Object compartmentLabel = compartmentPartitionFunction.apply(personCompartment);

			Object personProperty1Value = environment.getPersonPropertyValue(personId,
					TestPersonPropertyId.PERSON_PROPERTY_1);
			Object personProperty1Label = property1Function.apply(personProperty1Value);

			Object personProperty2Value = environment.getPersonPropertyValue(personId,
					TestPersonPropertyId.PERSON_PROPERTY_2);
			Object personProperty2Label = property2Function.apply(personProperty2Value);

			long personResource1Level = environment.getPersonResourceLevel(personId, TestResourceId.RESOURCE1);
			Object personResource1Label = personResource1PartitionFunction.apply(personResource1Level);

			long personResource2Level = environment.getPersonResourceLevel(personId, TestResourceId.RESOURCE2);
			Object personResource2Label = personResource2PartitionFunction.apply(personResource2Level);

			int groupCount1 = environment.getGroupCountForGroupTypeAndPerson(TestGroupTypeId.GROUP_TYPE_1, personId);
			int groupCount2 = environment.getGroupCountForGroupTypeAndPerson(TestGroupTypeId.GROUP_TYPE_2, personId);
			GroupTypeCountMap groupTypeCountMap = GroupTypeCountMap.builder()
					.setCount(TestGroupTypeId.GROUP_TYPE_1, groupCount1)
					.setCount(TestGroupTypeId.GROUP_TYPE_2, groupCount2).build();

			Object groupLabel = groupPartitionFunction.apply(groupTypeCountMap);

			// use the labels to create a label set that fits the person
			LabelSet.Builder builder = LabelSet.builder();
			for (PartitionChoice partitionChoice : partionChoices) {
				switch (partitionChoice) {
				case COMPARTMENT:
					builder.setCompartmentLabel(compartmentLabel);
					break;
				case GROUP:
					builder.setGroupLabel(groupLabel);
					break;
				case PROPERTY1:
					builder.setPropertyLabel(TestPersonPropertyId.PERSON_PROPERTY_1, personProperty1Label);
					break;
				case PROPERTY2:
					builder.setPropertyLabel(TestPersonPropertyId.PERSON_PROPERTY_2, personProperty2Label);
					break;
				case REGION:
					builder.setRegionLabel(regionLabel);
					break;
				case RESOURCE1:
					builder.setResourceLabel(TestResourceId.RESOURCE1, personResource1Label);
					break;
				case RESOURCE2:
					builder.setResourceLabel(TestResourceId.RESOURCE2, personResource2Label);
					break;
				default:
					throw new RuntimeException("unhandled case");
				}
			}
			LabelSet labelSet = builder.build();
			// add the population query to the expectedPartitioning if it is new and add the
			// person to the set of people we expect to be associated with this query
			Set<PersonId> partitionPeople = expectedPartitioning.get(labelSet);
			if (partitionPeople == null) {
				partitionPeople = new LinkedHashSet<>();
				expectedPartitioning.put(labelSet, partitionPeople);
			}
			partitionPeople.add(personId);
		}
		return expectedPartitioning;
	}

	private static Partition createPopulationPartitionDefinition(Set<PartitionChoice> partionChoices) {
		return createPopulationPartitionDefinition(partionChoices,Filter.allPeople());
	}
	
	private static Partition createPopulationPartitionDefinition(Set<PartitionChoice> partionChoices, Filter filter) {
		Builder builder = Partition.builder();
		builder.setFilter(filter);
		for (PartitionChoice partitionChoice : partionChoices) {
			switch (partitionChoice) {
			case COMPARTMENT:
				builder.setCompartmentFunction(compartmentPartitionFunction);
				break;
			case GROUP:
				builder.setGroupFunction(groupPartitionFunction);
				break;
			case PROPERTY1:
				builder.setPersonPropertyFunction(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function);
				break;
			case PROPERTY2:
				builder.setPersonPropertyFunction(TestPersonPropertyId.PERSON_PROPERTY_2, property2Function);
				break;
			case REGION:
				builder.setRegionFunction(regionPartitionFunction);
				break;
			case RESOURCE1:
				builder.setPersonResourceFunction(TestResourceId.RESOURCE1, personResource1PartitionFunction);
				break;
			case RESOURCE2:
				builder.setPersonResourceFunction(TestResourceId.RESOURCE2, personResource2PartitionFunction);
				break;
			default:
				throw new RuntimeException("unhandled case");
			}

		}
		return builder.build();

	}

	/**
	 * Tests {@link EnvironmentImpl#getPartitionSize(PersonPropertyId, Object)}
	 */
	@Test
	@UnitTestMethod(name = "getPartitionSize", args = { Object.class, LabelSet.class })
	public void testGetPartitionSize() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(1);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;
		Object key = "key";

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<PartitionChoice> partitionChoices = EnumSet.allOf(PartitionChoice.class);

			// define the partition
			Partition partition = createPopulationPartitionDefinition(partitionChoices);

			// add the partition to the simulation

			environment.addPartition(partition, key);

			makeRandomPersonAssignments(environment, randomGenerator);

			// Group the people in the simulation by their labels, giving us the expected
			// partitioning
			Map<LabelSet, Set<PersonId>> expectedPartitioning = getExpectedPartitionedPeople(environment,
					partitionChoices);

			// show that each labelSet corresponds to the expected number of
			// people
			for (LabelSet labelSet : expectedPartitioning.keySet()) {
				int expectedSize = expectedPartitioning.get(labelSet).size();
				int actualSize = environment.getPartitionSize(key, labelSet);
				assertEquals(expectedSize, actualSize);
			}

			// We now reduce the partition choices so that each query will correspond to
			// multiple elements of the partition.
			partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT, PartitionChoice.REGION);

			expectedPartitioning = getExpectedPartitionedPeople(environment, partitionChoices);

			// show that each labelSet corresponds to the expected number of
			// people
			for (LabelSet labelSet : expectedPartitioning.keySet()) {
				int expectedSize = expectedPartitioning.get(labelSet).size();
				int actualSize = environment.getPartitionSize(key, labelSet);
				assertEquals(expectedSize, actualSize);
			}
		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key3 = "key3";

			Partition partition = Partition.builder().setCompartmentFunction(compartmentPartitionFunction)
					.setPersonPropertyFunction(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function).build();
			environment.addPartition(partition, key3);

			LabelSet labelSet = LabelSet.builder().setCompartmentLabel(0)
					.setPropertyLabel(TestPersonPropertyId.PERSON_PROPERTY_1, 1).build();
			LabelSet incompatiblelabelSet = LabelSet.builder().setCompartmentLabel(0)
					.setPropertyLabel(TestPersonPropertyId.PERSON_PROPERTY_2, 1).build();

			// if the key is null
			assertModelException(() -> environment.getPartitionSize(null, labelSet),
					SimulationErrorType.NULL_POPULATION_PARTITION_KEY);
			// if the key does not correspond to an existing partition
			assertModelException(() -> environment.getPartitionSize("bad key", labelSet),
					SimulationErrorType.UNKNOWN_POPULATION_PARTITION_KEY);
			// if the label set is null
			assertModelException(() -> environment.getPartitionSize(key3, null), SimulationErrorType.NULL_LABEL_SET);
			// if the label set is incompatible with the partition
			assertModelException(() -> environment.getPartitionSize(key3, incompatiblelabelSet),
					SimulationErrorType.INCOMPATIBLE_LABEL_SET);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getPartitionPeople(Object, LabelSet)
	 */
	@Test
	@UnitTestMethod(name = "getPartitionPeople", args = { Object.class, LabelSet.class })
	public void testGetPartitionPeople_Object_LabelSet() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(6);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;
		Object key = "key";

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<PartitionChoice> partitionChoices = EnumSet.allOf(PartitionChoice.class);
			
			// define the partition
			Partition partition = createPopulationPartitionDefinition(partitionChoices);

			// add the partition to the simulation
			environment.addPartition(partition, key);

			makeRandomPersonAssignments(environment, randomGenerator);

			// Group the people in the simulation by their labels, giving us the expected
			// partitioning -- each labelSet will correspond to exactly one
			// element of the partition

			Map<LabelSet, Set<PersonId>> expectedPartitioning = getExpectedPartitionedPeople(environment,
					partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSet labelSet : expectedPartitioning.keySet()) {
				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSet);
				List<PersonId> partitionPeople = environment.getPartitionPeople(key, labelSet);
				assertEquals(expectedPeople.size(), partitionPeople.size());
				Set<PersonId> actualPeople = partitionPeople.stream()
						.collect(Collectors.toCollection(LinkedHashSet::new));
				assertEquals(expectedPeople, actualPeople);
			}

			// We now reduce the partition choices so that each query will correspond to
			// multiple elements of the partition.
			partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT, PartitionChoice.PROPERTY1);
			expectedPartitioning = getExpectedPartitionedPeople(environment, partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSet labelSet : expectedPartitioning.keySet()) {
				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSet);
				List<PersonId> partitionPeople = environment.getPartitionPeople(key, labelSet);
				assertEquals(expectedPeople.size(), partitionPeople.size());
				Set<PersonId> actualPeople = partitionPeople.stream()
						.collect(Collectors.toCollection(LinkedHashSet::new));
				assertEquals(expectedPeople, actualPeople);
			}
		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key3 = "key3";
			Partition partition = Partition.builder().setCompartmentFunction(compartmentPartitionFunction)
					.setPersonPropertyFunction(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function).build();
			environment.addPartition(partition, key3);

			LabelSet labelSet = LabelSet.builder().setCompartmentLabel(0)
					.setPropertyLabel(TestPersonPropertyId.PERSON_PROPERTY_1, 1).build();
			LabelSet incompatiblelabelSet = LabelSet.builder().setCompartmentLabel(0)
					.setPropertyLabel(TestPersonPropertyId.PERSON_PROPERTY_2, 1).build();

			// if the key is null
			assertModelException(() -> environment.getPartitionPeople(null, labelSet),
					SimulationErrorType.NULL_POPULATION_PARTITION_KEY);
			// if the key does not correspond to an existing partition
			assertModelException(() -> environment.getPartitionPeople("bad key", labelSet),
					SimulationErrorType.UNKNOWN_POPULATION_PARTITION_KEY);
			// if the label set is null
			assertModelException(() -> environment.getPartitionPeople(key3, null), SimulationErrorType.NULL_LABEL_SET);
			// if the label set is incompatible with the partition
			assertModelException(() -> environment.getPartitionPeople(key3, incompatiblelabelSet),
					SimulationErrorType.INCOMPATIBLE_LABEL_SET);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#getPartitionPeople(Object)
	 */
	@Test
	@UnitTestMethod(name = "getPartitionPeople", args = { Object.class })
	public void testGetPartitionPeople_Object() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(0);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;
		Object key = "key";

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<PartitionChoice> partitionChoices = EnumSet.allOf(PartitionChoice.class);
			
			Filter filter = Filter.compartment(TestCompartmentId.COMPARTMENT_1).or(Filter.compartment(TestCompartmentId.COMPARTMENT_2));
			
			// define the partition
			Partition partition = createPopulationPartitionDefinition(partitionChoices,filter);

			// add the partition to the simulation
			environment.addPartition(partition, key);

			makeRandomPersonAssignments(environment, randomGenerator);

			// Group the people in the simulation by their labels, giving us the expected
			// partitioning -- each labelSet will correspond to exactly one
			// element of the partition

			Set<PersonId> expectedPeople = new LinkedHashSet<>();
			expectedPeople.addAll(environment.getPeopleInCompartment(TestCompartmentId.COMPARTMENT_1));
			expectedPeople.addAll(environment.getPeopleInCompartment(TestCompartmentId.COMPARTMENT_2));

			List<PersonId> actualPeople = environment.getPartitionPeople(key);
			//show that the returned people does not contain duplicates
			assertEquals(expectedPeople.size(), actualPeople.size());
			//show that the returned people match the expected people
			assertEquals(expectedPeople, actualPeople.stream().collect(Collectors.toSet()));
			
		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key3 = "key3";
			Partition partition = Partition.builder().setCompartmentFunction(compartmentPartitionFunction)
					.setPersonPropertyFunction(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function).build();
			environment.addPartition(partition, key3);

			// if the key is null
			assertModelException(() -> environment.getPartitionPeople(null),
					SimulationErrorType.NULL_POPULATION_PARTITION_KEY);
			// if the key does not correspond to an existing partition
			assertModelException(() -> environment.getPartitionPeople("bad key"),
					SimulationErrorType.UNKNOWN_POPULATION_PARTITION_KEY);
			
			

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);
	}
	
	
	/**
	 * Tests {@link EnvironmentImpl#addPartition(Partition, Object)
	 */
	@Test
	@UnitTestMethod(name = "addPartition", args = { Partition.class, Object.class })
	public void testAddPartition() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(4);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key = "key";
			Set<PartitionChoice> partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT);
			Partition partition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPartition(partition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePartition(key);
			assertFalse(environment.populationPartitionExists(key));

			partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT, PartitionChoice.PROPERTY1);
			partition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPartition(partition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePartition(key);
			assertFalse(environment.populationPartitionExists(key));

			partitionChoices = EnumSet.of(PartitionChoice.GROUP, PartitionChoice.PROPERTY1);
			partition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPartition(partition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePartition(key);
			assertFalse(environment.populationPartitionExists(key));

		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key1 = "key1";
			Object key2 = "key2";
			Partition partition = Partition.builder().setCompartmentFunction(compartmentPartitionFunction)
					.setPersonPropertyFunction(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function).build();

			Partition badPropertyPartition = Partition.builder().setCompartmentFunction(compartmentPartitionFunction)
					.setPersonPropertyFunction(TestPersonPropertyId.getUnknownPersonPropertyId(), property1Function).build();

			Partition badResourcePartition = Partition.builder().setCompartmentFunction(compartmentPartitionFunction)
					.setPersonResourceFunction(TestResourceId.getUnknownResourceId(), personResource1PartitionFunction).build();

			environment.addPartition(partition, key1);

			// if the population partition definition is null
			assertModelException(() -> environment.addPartition(null, key2),
					SimulationErrorType.NULL_POPULATION_PARTITION_DEFINITION);

			// if the key is null
			assertModelException(() -> environment.addPartition(partition, null),
					SimulationErrorType.NULL_POPULATION_PARTITION_KEY);

			// if the key corresponds to an existing population partition
			assertModelException(() -> environment.addPartition(partition, key1),
					SimulationErrorType.DUPLICATE_PARTITION);

			// if the definition contains an unknown person property id
			assertModelException(() -> environment.addPartition(badPropertyPartition, key2),
					SimulationErrorType.UNKNOWN_PERSON_PROPERTY_ID);

			// if the definition contains an unknown resource id
			assertModelException(() -> environment.addPartition(badResourcePartition, key2),
					SimulationErrorType.UNKNOWN_RESOURCE_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#removePartition(Object)
	 */
	@Test
	@UnitTestMethod(name = "removePartition", args = { Object.class })
	public void testRemovePartition() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(5);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key = "key";
			Set<PartitionChoice> partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT);
			Partition partition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPartition(partition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePartition(key);
			assertFalse(environment.populationPartitionExists(key));

			partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT, PartitionChoice.PROPERTY1);
			partition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPartition(partition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePartition(key);
			assertFalse(environment.populationPartitionExists(key));

			partitionChoices = EnumSet.of(PartitionChoice.GROUP, PartitionChoice.PROPERTY1);
			partition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPartition(partition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePartition(key);
			assertFalse(environment.populationPartitionExists(key));

		});

		/*
		 * Precondition tests -- none
		 */

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// if the key is null
			assertModelException(() -> environment.removePartition(null),
					SimulationErrorType.NULL_POPULATION_PARTITION_KEY);

			// if the key does not correspond to an existing population index
			assertModelException(() -> environment.removePartition("unknown key"),
					SimulationErrorType.UNKNOWN_POPULATION_PARTITION_KEY);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#populationPartitionExists(Object)
	 */
	@Test
	@UnitTestMethod(name = "populationPartitionExists", args = { Object.class })
	public void testPopulationPartitionExists() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(3);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key = "key";
			Set<PartitionChoice> partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT);
			Partition partition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPartition(partition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePartition(key);
			assertFalse(environment.populationPartitionExists(key));

			partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT, PartitionChoice.PROPERTY1);
			partition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPartition(partition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePartition(key);
			assertFalse(environment.populationPartitionExists(key));

			partitionChoices = EnumSet.of(PartitionChoice.GROUP, PartitionChoice.PROPERTY1);
			partition = createPopulationPartitionDefinition(partitionChoices);
			environment.addPartition(partition, key);
			assertTrue(environment.populationPartitionExists(key));
			environment.removePartition(key);
			assertFalse(environment.populationPartitionExists(key));

		});

		/*
		 * Precondition tests -- none
		 */

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests
	 * {@link EnvironmentImpl#personIsInPopulationPartition(PersonId, Object, LabelSet)
	 */
	@Test
	@UnitTestMethod(name = "personIsInPopulationPartition", args = { PersonId.class, Object.class, LabelSet.class })
	public void testPersonIsInPopulationPartition() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(2);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;
		Object key = "key";

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<PartitionChoice> partitionChoices = EnumSet.allOf(PartitionChoice.class);

			// define the partition
			Partition partition = createPopulationPartitionDefinition(partitionChoices);

			// add the partition to the simulation
			environment.addPartition(partition, key);

			makeRandomPersonAssignments(environment, randomGenerator);

			// Group the people in the simulation by their labels, giving us the expected
			// partitioning
			Map<LabelSet, Set<PersonId>> expectedPartitioning = getExpectedPartitionedPeople(environment,
					partitionChoices);

			// show that each labelSet corresponds to the expected number of
			// people

			for (LabelSet labelSet : expectedPartitioning.keySet()) {
				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSet);
				for (PersonId personId : expectedPeople) {
					assertTrue(environment.personIsInPopulationPartition(personId, key, labelSet));
				}
			}

			// We now reduce the partition choices so that each query will correspond to
			// multiple elements of the partition.
			partitionChoices = EnumSet.of(PartitionChoice.PROPERTY1, PartitionChoice.PROPERTY2,
					PartitionChoice.RESOURCE1, PartitionChoice.RESOURCE2);

			expectedPartitioning = getExpectedPartitionedPeople(environment, partitionChoices);

			// show that each labelSet corresponds to the expected number of
			// people

			for (LabelSet labelSet : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSet);
				for (PersonId personId : expectedPeople) {
					assertTrue(environment.personIsInPopulationPartition(personId, key, labelSet));
				}
			}

		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			Object key3 = "key3";
			Partition partition = Partition.builder().setCompartmentFunction(compartmentPartitionFunction)
					.setPersonPropertyFunction(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function).build();
			environment.addPartition(partition, key3);

			LabelSet labelSet = LabelSet.builder().setCompartmentLabel(0)
					.setPropertyLabel(TestPersonPropertyId.PERSON_PROPERTY_1, 1).build();
			LabelSet incompatiblelabelSet = LabelSet.builder().setCompartmentLabel(0)
					.setPropertyLabel(TestPersonPropertyId.PERSON_PROPERTY_2, 1).build();
			PersonId goodPersonId = new PersonId(0);
			PersonId badPersonId = new PersonId(10000000);

			// if the key is null
			assertModelException(() -> environment.personIsInPopulationPartition(goodPersonId, null, labelSet),
					SimulationErrorType.NULL_POPULATION_PARTITION_KEY);
			// if the key does not correspond to an existing partition
			assertModelException(() -> environment.personIsInPopulationPartition(goodPersonId, "bad key", labelSet),
					SimulationErrorType.UNKNOWN_POPULATION_PARTITION_KEY);

			// if the personId is null
			assertModelException(() -> environment.personIsInPopulationPartition(null, key3, labelSet),
					SimulationErrorType.NULL_PERSON_ID);
			// if the personId does not correspond to an existing person
			assertModelException(() -> environment.personIsInPopulationPartition(badPersonId, key3, labelSet),
					SimulationErrorType.UNKNOWN_PERSON_ID);

			// if the label set is null
			assertModelException(() -> environment.personIsInPopulationPartition(goodPersonId, key3, null),
					SimulationErrorType.NULL_LABEL_SET);
			// if the label set is incompatible with the partition
			assertModelException(
					() -> environment.personIsInPopulationPartition(goodPersonId, key3, incompatiblelabelSet),
					SimulationErrorType.INCOMPATIBLE_LABEL_SET);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#samplePartition(Object, PartitionSampler)} Test
	 * limited to precondition tests.
	 */
	@Test
	@UnitTestMethod(name = "samplePartition", args = { Object.class, PartitionSampler.class })
	public void testSamplePartition_precondition_checks() {

		/*
		 * Assert that group contacts via MonoWeightingFunctions work properly
		 */

		final long seed = SEED_PROVIDER.getSeedValue(10);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		RandomNumberGeneratorId randomNumberGeneratorId = TestRandomGeneratorId.BLITZEN;

		scenarioBuilder.addRandomNumberGeneratorId(randomNumberGeneratorId);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 0;

//		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
//
//			Object key = "key1";
//			Partition partition = Partition.create().compartment(MT_Sample.compartmentPartitionFunction)
//					.region(MT_Sample.regionPartitionFunction);
//			environment.addPopulationPartition(partition, key);
//
//			// use a uniform distribution with 10000 repetitions
//
//			final Map<MultiKey, Counter> actualSelections = new LinkedHashMap<>();
//			actualSelections.put(new MultiKey(0, 0), new Counter(0));
//			actualSelections.put(new MultiKey(0, 1), new Counter(0));
//			actualSelections.put(new MultiKey(0, 2), new Counter(0));
//			actualSelections.put(new MultiKey(1, 0), new Counter(0));
//			actualSelections.put(new MultiKey(1, 1), new Counter(0));
//			actualSelections.put(new MultiKey(1, 2), new Counter(0));
//
//			final Map<MultiKey, Counter> expectedSelections = new LinkedHashMap<>();
//
//			int sampleCount = 10000;
//
//			expectedSelections.put(new MultiKey(0, 0), new Counter(sampleCount / 10));
//			expectedSelections.put(new MultiKey(0, 1), new Counter(3 * sampleCount / 10));
//			expectedSelections.put(new MultiKey(0, 2), new Counter(6 * sampleCount / 10));
//			expectedSelections.put(new MultiKey(1, 0), new Counter(0));
//			expectedSelections.put(new MultiKey(1, 1), new Counter(0));
//			expectedSelections.put(new MultiKey(1, 2), new Counter(0));
//
//			for (int i = 0; i < 10000; i++) {
//
//				Optional<PersonId> opt = environment.samplePartition(key, MT_Sample::getWeight,
//						randomNumberGeneratorId);
//
//				assertTrue(opt.isPresent());
//				PersonId personId = opt.get();
//				CompartmentId compartmentId = environment.getPersonCompartment(personId);
//				Object compartmentLabel = compartmentPartitionFunction.apply(compartmentId);
//				RegionId regionId = environment.getPersonRegion(personId);
//				Object regionLabel = regionPartitionFunction.apply(regionId);
//				MultiKey multiKey = new MultiKey(compartmentLabel, regionLabel);
//				Counter counter = actualSelections.get(multiKey);
//				counter.count++;
//			}
//
//			for (MultiKey multiKey : expectedSelections.keySet()) {
//				Counter expectedCounter = expectedSelections.get(multiKey);
//				Counter actualCounter = actualSelections.get(multiKey);
//				int tolerance = expectedCounter.count / 10;
//				assertTrue(FastMath.abs(expectedCounter.count - actualCounter.count) <= tolerance);
//			}
//
//		});

		// show that a weighting function that returns all zeros will result in
		// an optional where no value is present
//		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
//
//			Object key = "key2";
//			Partition partition = Partition.create().compartment(MT_Sample.compartmentPartitionFunction)
//					.region(MT_Sample.regionPartitionFunction);
//			environment.addPopulationPartition(partition, key);
//
//			Optional<PersonId> opt = environment.samplePartition(key, MT_Sample::getZeroWeight,
//					randomNumberGeneratorId);
//			assertTrue(!opt.isPresent());
//		});

		// test preconditions
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Object key = "key3";
			Object badKey = "badKey";
			Partition partition = Partition.builder().setCompartmentFunction(AT_EnvironmentImpl_25.compartmentPartitionFunction)
					.setRegionFunction(AT_EnvironmentImpl_25.regionPartitionFunction).build();
			environment.addPartition(partition, key);

			// if the key is null
			assertModelException(() -> environment.samplePartition(null, PartitionSampler.builder().build()),
					SimulationErrorType.NULL_POPULATION_PARTITION_KEY);

			// if the key does not correspond to an existing population partition
			assertModelException(() -> environment.samplePartition(badKey, PartitionSampler.builder().build()),
					SimulationErrorType.UNKNOWN_POPULATION_PARTITION_KEY);

			// if the partition sampler is null
			assertModelException(() -> environment.samplePartition(key, (PartitionSampler) null),
					SimulationErrorType.NULL_PARTITION_SAMPLER);

			// if the partition sampler's label set is incompatible with the population
			// partition
			assertModelException(() -> {
				LabelSet labelSet = LabelSet.builder().setCompartmentLabel("asdf")
						.setResourceLabel(TestResourceId.RESOURCE1, "asdf").build();
				PartitionSampler partitionSampler = PartitionSampler.builder().setLabelSet(labelSet).build();
				environment.samplePartition(key, partitionSampler);
			}, SimulationErrorType.INCOMPATIBLE_LABEL_SET);

			// if the randomNumberGeneratorId does not correspond to an existing random
			// Number Generator Id in the scenario
			assertModelException(
					() -> environment.samplePartition(key, PartitionSampler.builder()
							.setRandomNumberGeneratorId(TestRandomGeneratorId.PRANCER).build()),
					SimulationErrorType.UNKNOWN_RANDOM_NUMBER_GENERATOR_ID);

			// if the excluded person is unknown
			assertModelException(
					() -> environment.samplePartition(key,
							PartitionSampler.builder().setExcludedPerson(new PersonId(1000000)).build()),
					SimulationErrorType.UNKNOWN_PERSON_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#samplePartition(Object, LabelSet,
	 * RandomNumberGeneratorId, PersonId). Test limited to PartitionSampler with
	 * LabelSet, alternate random number generator and excluded person.
	 */
	@Test
	@UnitTestMethod(name = "samplePartition", args = { Object.class, PartitionSampler.class })
	public void testSamplePartition_LabelSet_RNG_PersonId() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(8);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		RandomNumberGeneratorId randomNumberGeneratorId = TestRandomGeneratorId.BLITZEN;
		scenarioBuilder.addRandomNumberGeneratorId(randomNumberGeneratorId);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;
		Object key = "key";

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<PartitionChoice> partitionChoices = EnumSet.allOf(PartitionChoice.class);

			// define the partition
			Partition partition = createPopulationPartitionDefinition(partitionChoices);

			// add the partition to the simulation
			environment.addPartition(partition, key);

			makeRandomPersonAssignments(environment, randomGenerator);

			// Group the people in the simulation by their labels, giving us the expected
			// partitioning
			Map<LabelSet, Set<PersonId>> expectedPartitioning = getExpectedPartitionedPeople(environment,
					partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation

			for (LabelSet labelSet : expectedPartitioning.keySet()) {
				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSet);
				List<PersonId> expectedPeopleList = new ArrayList<>(expectedPeople);
				Collections.shuffle(expectedPeopleList, new Random(randomGenerator.nextLong()));
				// we know that each labelSet corresponds to at least one person
				PersonId excludedPersonId = expectedPeopleList.get(0);

				for (int i = 0; i < 10; i++) {
					PartitionSampler partitionSampler = PartitionSampler.builder().setLabelSet(labelSet)
							.setRandomNumberGeneratorId(randomNumberGeneratorId).setExcludedPerson(excludedPersonId)
							.build();
					Optional<PersonId> optional = environment.samplePartition(key, partitionSampler);
					if (expectedPeople.size() > 1) {
						assertTrue(optional.isPresent());
						PersonId selectedPersonId = optional.get();
						assertTrue(expectedPeople.contains(selectedPersonId));
					} else {
						assertFalse(optional.isPresent());
					}
				}
			}

			// We now reduce the partition choices so that each query will correspond to
			// multiple elements of the partition.

			partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT, PartitionChoice.GROUP,
					PartitionChoice.RESOURCE2);
			expectedPartitioning = getExpectedPartitionedPeople(environment, partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation

			for (LabelSet labelSet : expectedPartitioning.keySet()) {
				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSet);
				List<PersonId> expectedPeopleList = new ArrayList<>(expectedPeople);
				Collections.shuffle(expectedPeopleList, new Random(randomGenerator.nextLong()));
				// we know that each labelSet corresponds to at least one person
				PersonId excludedPersonId = expectedPeopleList.get(0);

				for (int i = 0; i < 10; i++) {
					PartitionSampler partitionSampler = PartitionSampler.builder().setLabelSet(labelSet)
							.setRandomNumberGeneratorId(randomNumberGeneratorId).setExcludedPerson(excludedPersonId)
							.build();
					Optional<PersonId> optional = environment.samplePartition(key, partitionSampler);
					if (expectedPeople.size() > 1) {
						assertTrue(optional.isPresent());
						PersonId selectedPersonId = optional.get();
						assertTrue(expectedPeople.contains(selectedPersonId));
					} else {
						assertFalse(optional.isPresent());
					}
				}
			}

			// show that a population query resulting in an empty partition cannot return a
			// randomly selected person
			PersonId personId = new PersonId(0);
			Object key2 = "key2";
			Partition partitionDefinition = Partition.builder().setPersonPropertyFunction(TestPersonPropertyId.PERSON_PROPERTY_1,
					property1Function).build();
			environment.addPartition(partitionDefinition, key2);
			LabelSet labelSet = LabelSet.builder().setPropertyLabel(TestPersonPropertyId.PERSON_PROPERTY_1, 1000)
					.build();
			PartitionSampler partitionSampler = PartitionSampler.builder().setLabelSet(labelSet)
					.setRandomNumberGeneratorId(randomNumberGeneratorId).setExcludedPerson(personId).build();
			Optional<PersonId> optional = environment.samplePartition(key2, partitionSampler);
			assertFalse(optional.isPresent());

			// show that a population query resulting in a partition containing only the
			// excluded person cannot return a randomly selected person
			environment.setPersonPropertyValue(personId, TestPersonPropertyId.PERSON_PROPERTY_1, 1000);
			partitionSampler = PartitionSampler.builder().setLabelSet(labelSet)
					.setRandomNumberGeneratorId(TestRandomGeneratorId.BLITZEN).setExcludedPerson(personId).build();
			optional = environment.samplePartition(key2, partitionSampler);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link EnvironmentImpl#samplePartition(Object, LabelSet). Test limited
	 * to PartitionSampler with LabelSet only.
	 */
	@Test
	@UnitTestMethod(name = "samplePartition", args = { Object.class, PartitionSampler.class })
	public void testSamplePartition_LabelSet() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(12);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;
		Object key = "key";

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<PartitionChoice> partitionChoices = EnumSet.allOf(PartitionChoice.class);

			// define the partition
			Partition partition = createPopulationPartitionDefinition(partitionChoices);

			// add the partition to the simulation
			environment.addPartition(partition, key);

			makeRandomPersonAssignments(environment, randomGenerator);

			// Group the people in the simulation by their labels, giving us the expected
			// partitioning
			Map<LabelSet, Set<PersonId>> expectedPartitioning = getExpectedPartitionedPeople(environment,
					partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSet labelSet : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSet);
				// we know that each labelSet corresponds to at least one person
				for (int i = 0; i < 10; i++) {
					PartitionSampler partitionSampler = PartitionSampler.builder().setLabelSet(labelSet).build();
					Optional<PersonId> optional = environment.samplePartition(key, partitionSampler);
					assertTrue(optional.isPresent());
					PersonId selectedPersonId = optional.get();
					assertTrue(expectedPeople.contains(selectedPersonId));
				}
			}

			// We now reduce the partition choices so that each query will correspond to
			// multiple elements of the partition.
			partitionChoices = EnumSet.of(PartitionChoice.PROPERTY1, PartitionChoice.PROPERTY2, PartitionChoice.GROUP,
					PartitionChoice.COMPARTMENT);
			expectedPartitioning = getExpectedPartitionedPeople(environment, partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSet labelSet : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSet);
				// we know that each labelSet corresponds to at least one person
				for (int i = 0; i < 10; i++) {
					PartitionSampler partitionSampler = PartitionSampler.builder().setLabelSet(labelSet).build();
					Optional<PersonId> optional = environment.samplePartition(key, partitionSampler);
					assertTrue(optional.isPresent());
					PersonId selectedPersonId = optional.get();
					assertTrue(expectedPeople.contains(selectedPersonId));
				}
			}
			// show that a population query resulting in an empty partition cannot return a
			// randomly selected person
			Object key2 = "key2";
			Partition partitionDefinition = Partition.builder().setPersonPropertyFunction(TestPersonPropertyId.PERSON_PROPERTY_1,
					property1Function).build();
			environment.addPartition(partitionDefinition, key2);
			LabelSet labelSet = LabelSet.builder().setPropertyLabel(TestPersonPropertyId.PERSON_PROPERTY_1, 1000)
					.build();
			PartitionSampler partitionSampler = PartitionSampler.builder().setLabelSet(labelSet).build();
			Optional<PersonId> optional = environment.samplePartition(key2, partitionSampler);
			assertFalse(optional.isPresent());

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests {@link EnvironmentImpl#samplePartition(Object, LabelSet, PersonId).
	 * Test limited to PartitionSampler with LabelSet and excluded person only.
	 */
	@Test
	@UnitTestMethod(name = "samplePartition", args = { Object.class, PartitionSampler.class })
	public void testSamplePartition_LabelSet_PersonId() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(11);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;
		Object key = "key";

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<PartitionChoice> partitionChoices = EnumSet.allOf(PartitionChoice.class);

			// define the partition
			Partition partition = createPopulationPartitionDefinition(partitionChoices);

			// add the partition to the simulation
			environment.addPartition(partition, key);

			makeRandomPersonAssignments(environment, randomGenerator);

			// Group the people in the simulation by their labels, giving us the expected
			// partitioning
			Map<LabelSet, Set<PersonId>> expectedPartitioning = getExpectedPartitionedPeople(environment,
					partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSet labelSet : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSet);
				List<PersonId> expectedPeopleList = new ArrayList<>(expectedPeople);
				Collections.shuffle(expectedPeopleList, new Random(randomGenerator.nextLong()));
				// we know that each labelSet corresponds to at least one person
				PersonId excludedPersonId = expectedPeopleList.get(0);

				for (int i = 0; i < 10; i++) {
					PartitionSampler partitionSampler = PartitionSampler.builder().setLabelSet(labelSet)
							.setExcludedPerson(excludedPersonId).build();
					Optional<PersonId> optional = environment.samplePartition(key, partitionSampler);
					if (expectedPeople.size() > 1) {
						assertTrue(optional.isPresent());
						PersonId selectedPersonId = optional.get();
						assertTrue(expectedPeople.contains(selectedPersonId));
					} else {
						assertFalse(optional.isPresent());
					}
				}
			}

			// We now reduce the partition choices so that each query will correspond to
			// multiple elements of the partition.
			partitionChoices = EnumSet.of(PartitionChoice.COMPARTMENT, PartitionChoice.PROPERTY1,
					PartitionChoice.RESOURCE1);
			expectedPartitioning = getExpectedPartitionedPeople(environment, partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSet labelSet : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSet);
				List<PersonId> expectedPeopleList = new ArrayList<>(expectedPeople);
				Collections.shuffle(expectedPeopleList, new Random(randomGenerator.nextLong()));
				// we know that each labelSet corresponds to at least one person
				PersonId excludedPersonId = expectedPeopleList.get(0);

				for (int i = 0; i < 10; i++) {
					PartitionSampler partitionSampler = PartitionSampler.builder().setLabelSet(labelSet)
							.setExcludedPerson(excludedPersonId).build();
					Optional<PersonId> optional = environment.samplePartition(key, partitionSampler);
					if (expectedPeople.size() > 1) {
						assertTrue(optional.isPresent());
						PersonId selectedPersonId = optional.get();
						assertTrue(expectedPeople.contains(selectedPersonId));
					} else {
						assertFalse(optional.isPresent());
					}
				}
			}
			// show that a population query resulting in an empty partition cannot return a
			// randomly selected person
			PersonId personId = new PersonId(0);
			Object key2 = "key2";
			partition = Partition.builder().setPersonPropertyFunction(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function).build();
			environment.addPartition(partition, key2);
			LabelSet labelSet = LabelSet.builder().setPropertyLabel(TestPersonPropertyId.PERSON_PROPERTY_1, 1000)
					.build();
			PartitionSampler partitionSampler = PartitionSampler.builder().setLabelSet(labelSet)
					.setExcludedPerson(personId).build();
			Optional<PersonId> optional = environment.samplePartition(key2, partitionSampler);
			assertFalse(optional.isPresent());

			// show that a population query resulting in a partition containing only the
			// excluded person cannot return a randomly selected person
			environment.setPersonPropertyValue(personId, TestPersonPropertyId.PERSON_PROPERTY_1, 1000);
			partitionSampler = PartitionSampler.builder().setLabelSet(labelSet).setExcludedPerson(personId).build();
			optional = environment.samplePartition(key2, partitionSampler);
			assertFalse(optional.isPresent());
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests {@link EnvironmentImpl#samplePartition(Object, LabelSet,
	 * RandomNumberGeneratorId). Test limited to PartitionSampler with LabelSet and
	 * alternate random number generator.
	 */
	@Test
	@UnitTestMethod(name = "samplePartition", args = { Object.class, PartitionSampler.class })
	public void testSamplePartition_LabelSet_RNG() {
		/*
		 * Go through the boilerplate steps of generating a scenario that will support
		 * the testing of a population partition that exercises all of the partition's
		 * dimensions.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(9);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		RandomNumberGeneratorId randomNumberGeneratorId = TestRandomGeneratorId.COMET;
		scenarioBuilder.addRandomNumberGeneratorId(randomNumberGeneratorId);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;
		Object key = "key";

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<PartitionChoice> partitionChoices = EnumSet.allOf(PartitionChoice.class);

			// define the partition
			Partition partition = createPopulationPartitionDefinition(partitionChoices);

			// add the partition to the simulation
			environment.addPartition(partition, key);

			makeRandomPersonAssignments(environment, randomGenerator);

			// Group the people in the simulation by their labels, giving us the expected
			// partitioning

			Map<LabelSet, Set<PersonId>> expectedPartitioning = getExpectedPartitionedPeople(environment,
					partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSet labelSet : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSet);
				// we know that each labelSet corresponds to at least one person
				for (int i = 0; i < 10; i++) {
					PartitionSampler partitionSampler = PartitionSampler.builder().setLabelSet(labelSet)
							.setRandomNumberGeneratorId(randomNumberGeneratorId).build();
					Optional<PersonId> optional = environment.samplePartition(key, partitionSampler);
					assertTrue(optional.isPresent());
					PersonId selectedPersonId = optional.get();
					assertTrue(expectedPeople.contains(selectedPersonId));
				}
			}
			// We now reduce the partition choices so that each query will correspond to
			// multiple elements of the partition.
			partitionChoices = EnumSet.of(PartitionChoice.GROUP, PartitionChoice.REGION, PartitionChoice.RESOURCE1);
			expectedPartitioning = getExpectedPartitionedPeople(environment, partitionChoices);

			// show that each set of people we expect should be associated with a given set
			// of labels matches the set returned by the simulation
			for (LabelSet labelSet : expectedPartitioning.keySet()) {

				Set<PersonId> expectedPeople = expectedPartitioning.get(labelSet);
				// we know that each labelSet corresponds to at least one person
				for (int i = 0; i < 10; i++) {
					PartitionSampler partitionSampler = PartitionSampler.builder().setLabelSet(labelSet)
							.setRandomNumberGeneratorId(randomNumberGeneratorId).build();
					Optional<PersonId> optional = environment.samplePartition(key, partitionSampler);
					assertTrue(optional.isPresent());
					PersonId selectedPersonId = optional.get();
					assertTrue(expectedPeople.contains(selectedPersonId));
				}
			}
			// show that a population query resulting in an empty partition cannot return a
			// randomly selected person
			Object key2 = "key2";
			partition = Partition.builder().setPersonPropertyFunction(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function).build();
			environment.addPartition(partition, key2);
			LabelSet labelSet = LabelSet.builder().setPropertyLabel(TestPersonPropertyId.PERSON_PROPERTY_1, 1000)
					.build();
			PartitionSampler partitionSampler = PartitionSampler.builder().setLabelSet(labelSet).build();
			Optional<PersonId> optional = environment.samplePartition(key2, partitionSampler);
			assertFalse(optional.isPresent());

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests {@link EnvironmentImpl#samplePartition(Object, LabelSet). Test limited
	 * to sampling from a non-degenerate, but empty partition.
	 */
	@Test
	@UnitTestMethod(name = "samplePartition", args = { Object.class, PartitionSampler.class })
	public void testSamplePartition_Empty() {
		/*
		 * Sample from a non-degenerate, but empty partition
		 */

		final long seed = SEED_PROVIDER.getSeedValue(7);
		RandomGenerator randomGenerator = getRandomGenerator(seed);
		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		buildBaseScenario(scenarioBuilder, randomGenerator);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);
		Scenario scenario = scenarioBuilder.build();

		int testTime = 1;
		Object key = "key";

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			Set<PartitionChoice> partitionChoices = EnumSet.allOf(PartitionChoice.class);

			// define the partition
			String prop2TestValue = "prop2TestValue";

			
			Filter filter = Filter.property(TestPersonPropertyId.PERSON_PROPERTY_2, Equality.EQUAL, prop2TestValue);
			Partition partition = createPopulationPartitionDefinition(partitionChoices,filter);
					

			// add the partition to the simulation
			environment.addPartition(partition, key);

			makeRandomPersonAssignments(environment, randomGenerator);

			LabelSet labelSet = LabelSet.builder().setCompartmentLabel(0).build();

			// show that an empty partition will not return a person selection
			PartitionSampler partitionSampler = PartitionSampler.builder().setLabelSet(labelSet).build();
			Optional<PersonId> optional = environment.samplePartition(key, partitionSampler);
			assertFalse(optional.isPresent());

			for (PersonId personId : environment.getPeople()) {
				environment.setPersonPropertyValue(personId, TestPersonPropertyId.PERSON_PROPERTY_2, prop2TestValue);
			}

			optional = environment.samplePartition(key, partitionSampler);
			assertTrue(optional.isPresent());

			makeRandomPersonAssignments(environment, randomGenerator);

			optional = environment.samplePartition(key, partitionSampler);
			assertFalse(optional.isPresent());

			// show that a population query resulting in a non-existing partition cannot
			// return a
			// randomly selected person
			Object key2 = "key2";
			partition = Partition.builder().setPersonPropertyFunction(TestPersonPropertyId.PERSON_PROPERTY_1, property1Function).build();
			environment.addPartition(partition, key2);
			labelSet = LabelSet.builder().setPropertyLabel(TestPersonPropertyId.PERSON_PROPERTY_1, 1000).build();
			partitionSampler = PartitionSampler.builder().setLabelSet(labelSet).build();
			optional = environment.samplePartition(key2, partitionSampler);
			assertFalse(optional.isPresent());

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(getReplication(randomGenerator));
		simulation.setScenario(scenario);
		simulation.execute();
		assertAllPlansExecuted(taskPlanContainer);

	}
	
}
