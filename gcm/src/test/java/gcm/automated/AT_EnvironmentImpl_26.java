package gcm.automated;

import static gcm.automated.support.EnvironmentSupport.addStandardComponentsAndTypes;
import static gcm.automated.support.EnvironmentSupport.addStandardPeople;
import static gcm.automated.support.EnvironmentSupport.addStandardPropertyDefinitions;
import static gcm.automated.support.EnvironmentSupport.addStandardTrackingAndScenarioId;
import static gcm.automated.support.EnvironmentSupport.addTaskPlanContainer;
import static gcm.automated.support.EnvironmentSupport.assertAllPlansExecuted;
import static gcm.automated.support.EnvironmentSupport.getRandomGenerator;
import static gcm.automated.support.EnvironmentSupport.getReplication;
import static gcm.automated.support.ExceptionAssertion.assertModelException;
import static gcm.simulation.partition.Filter.compartment;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.EnumSet;
import java.util.LinkedHashSet;
import java.util.Set;

import org.apache.commons.math3.random.RandomGenerator;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import gcm.automated.support.EnvironmentSupport;
import gcm.automated.support.EnvironmentSupport.PropertyAssignmentPolicy;
import gcm.automated.support.SeedProvider;
import gcm.automated.support.TaskPlanContainer;
import gcm.automated.support.TestCompartmentId;
import gcm.automated.support.TestGlobalComponentId;
import gcm.automated.support.TestRegionId;
import gcm.replication.Replication;
import gcm.scenario.PersonId;
import gcm.scenario.Scenario;
import gcm.scenario.ScenarioBuilder;
import gcm.scenario.UnstructuredScenarioBuilder;
import gcm.simulation.EnvironmentImpl;
import gcm.simulation.Simulation;
import gcm.simulation.SimulationErrorType;
import gcm.simulation.partition.Filter;
import gcm.simulation.partition.Partition;
import gcm.simulation.partition.PartitionSampler;
import gcm.simulation.partition.PopulationPartition;
import gcm.util.StopWatch;
import gcm.util.annotations.UnitTest;
import gcm.util.annotations.UnitTestMethod;

@UnitTest(target = EnvironmentImpl.class)

public class AT_EnvironmentImpl_26 {

	private static SeedProvider SEED_PROVIDER;

	@BeforeClass
	public static void beforeClass() {
		SEED_PROVIDER = new SeedProvider(EnvironmentSupport.getMetaSeed(26));
	}

	/**
	 * Internal test(not part of public tests) to show that there are no large gaps
	 * in the seed cases generated by the SeedProvider.
	 */
	@AfterClass
	public static void afterClass() {
//		System.out
//				.println(AT_EnvironmentImpl_26.class.getSimpleName() + " " + SEED_PROVIDER.generateUnusedSeedReport());
	}
	
	/**
	 * Tests {@link EnvironmentImpl#samplePartition(Object, PartitionSampler)}
	 */
	@Test
	@UnitTestMethod(name = "samplePartition", args = {Object.class,PartitionSampler.class})
	public void testSamplePartition_Object_PersonId() {
		/*
		 * Show that we can retrieve people from a population index while
		 * excluding a person who is in the index. We will do this repeatedly to
		 * show that the person retrieved is always from the index but never the
		 * excluded person.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(1);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 1000);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.TRUE, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			
			StopWatch stopWatch = new StopWatch();
			EnvironmentImpl.partitionStopWatch.reset();
//			PopulationPartition.partitionStopWatch.reset();

			for (final TestCompartmentId testCompartmentId : TestCompartmentId.values()) {
				final Set<PersonId> peopleInCompartment = new LinkedHashSet<>();
				for (final PersonId personId : scenario.getPeopleIds()) {
					if (scenario.getPersonCompartment(personId).equals(testCompartmentId)) {
						peopleInCompartment.add(personId);
					}
				}

				final Object key = new Object();				
				environment.addPartition(Partition.create().filter(Filter.compartment(testCompartmentId)), key);
				for (int i = 0; i < 100; i++) {
					for (final PersonId personId : peopleInCompartment) {
						stopWatch.start();
						final PersonId selectedPersonId = environment.samplePartition(key,PartitionSampler.create().excludePerson(personId)).get();
						stopWatch.stop();
						assertTrue(peopleInCompartment.contains(selectedPersonId));
						assertFalse(selectedPersonId.equals(personId));
					}
				}

				environment.removePartition(key);
			}
			System.out.println("AT_EnvironmentImpl_26.testSamplePartition_Object_PersonId()"+stopWatch.getElapsedMilliSeconds());
			System.out.println("AT_EnvironmentImpl_26.testSamplePartition_Object_PersonId()"+EnvironmentImpl.partitionStopWatch.getElapsedMilliSeconds());
//			System.out.println("AT_EnvironmentImpl_26.testSamplePartition_Object_PersonId()"+PopulationPartition.partitionStopWatch.getElapsedMilliSeconds());

		});

		/*
		 * Precondition tests -- this does not cover all the cases for the partition sampler failing
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// if the key is null
			assertModelException(() -> environment.samplePartition((Object[]) null,PartitionSampler.create()), SimulationErrorType.NULL_POPULATION_PARTITION_KEY);
			// if the key does not correspond to an existing population
			// index
			assertModelException(() -> environment.samplePartition(new Object(),PartitionSampler.create()), SimulationErrorType.UNKNOWN_POPULATION_PARTITION_KEY);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}
	
	/**
	 * Tests {@link EnvironmentImpl#sampleIndex(Object,PersonId)}
	 */
	@Test
	@UnitTestMethod(name = "sampleIndex", args = {Object.class,PersonId.class})
	public void testSampleIndex_Object_PersonId() {
		/*
		 * Show that we can retrieve people from a population index while
		 * excluding a person who is in the index. We will do this repeatedly to
		 * show that the person retrieved is always from the index but never the
		 * excluded person.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(0);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 1000);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.TRUE, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			StopWatch stopWatch = new StopWatch();
			EnvironmentImpl.indexStopWatch.reset();
			for (final TestCompartmentId testCompartmentId : TestCompartmentId.values()) {
				final Set<PersonId> peopleInCompartment = new LinkedHashSet<>();
				for (final PersonId personId : scenario.getPeopleIds()) {
					if (scenario.getPersonCompartment(personId).equals(testCompartmentId)) {
						peopleInCompartment.add(personId);
					}
				}

				final Object key = new Object();
				environment.addPopulationIndex(compartment(testCompartmentId), key);
				for (int i = 0; i < 100; i++) {
					for (final PersonId personId : peopleInCompartment) {
						stopWatch.start();
						final PersonId selectedPersonId = environment.sampleIndex(key,personId).get();
						stopWatch.stop();
						assertTrue(peopleInCompartment.contains(selectedPersonId));
						assertFalse(selectedPersonId.equals(personId));
					}
				}

				environment.removePopulationIndex(key);
			}
			System.out.println("AT_EnvironmentImpl_26.testSampleIndex_Object_PersonId()"+stopWatch.getElapsedMilliSeconds());
			System.out.println("AT_EnvironmentImpl_26.testSampleIndex_Object_PersonId()"+EnvironmentImpl.indexStopWatch.getElapsedMilliSeconds());
		});

		/*
		 * Precondition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// if the key is null
			assertModelException(() -> environment.sampleIndex((Object[]) null), SimulationErrorType.NULL_POPULATION_INDEX_KEY);
			// if the key does not correspond to an existing population
			// index
			assertModelException(() -> environment.sampleIndex(new Object()), SimulationErrorType.UNKNOWN_POPULATION_INDEX_KEY);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

}
