package gcm.automated;

import static gcm.automated.support.EnvironmentSupport.getRandomGenerator;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotEquals;

import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;

import org.apache.commons.math3.random.RandomGenerator;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import gcm.automated.support.SeedProvider;
import gcm.automated.support.TestGroupTypeId;
import gcm.scenario.GroupTypeId;
import gcm.simulation.partition.GroupTypeCountMap;
import gcm.util.annotations.UnitTest;
import gcm.util.annotations.UnitTestMethod;

import static gcm.automated.support.ExceptionAssertion.*;

/**
 * Test class for {@link GroupTypeCountMap}
 * 
 * @author Shawn Hatch
 *
 */
@UnitTest(target = GroupTypeCountMap.class)
public class AT_GroupTypeCountMap {
	private static SeedProvider SEED_PROVIDER;

	@BeforeAll
	public static void beforeClass() {
		SEED_PROVIDER = new SeedProvider(8556976443421256038L);
	}

	/**
	 * Internal test(not part of public tests) to show that there are no large
	 * gaps in the seed cases generated by the SeedProvider.
	 */
	@AfterAll
	public static void afterClass() {
		// System.out.println(AT_GroupTypeCountMap.class.getSimpleName() + " " +
		// SEED_PROVIDER.generateUnusedSeedReport());
	}

	/**
	 * Tests {@linkplain GroupTypeCountMap#equals(Object)
	 */
	@Test
	@UnitTestMethod(name = "equals", args = { Object.class })
	public void testEquals() {
		/*
		 * Show various cases demonstrating that build order and implied zero
		 * values do not influence the equals contract
		 */

		// order should not matter
		GroupTypeCountMap.Builder builder = GroupTypeCountMap.builder();
		builder.setCount(TestGroupTypeId.GROUP_TYPE_1, 5);
		builder.setCount(TestGroupTypeId.GROUP_TYPE_2, 7);
		GroupTypeCountMap groupTypeCountMap1 = builder.build();

		builder.setCount(TestGroupTypeId.GROUP_TYPE_2, 7);
		builder.setCount(TestGroupTypeId.GROUP_TYPE_1, 5);
		GroupTypeCountMap groupTypeCountMap2 = builder.build();

		assertEquals(groupTypeCountMap1, groupTypeCountMap2);

		// implied zero values should not matter
		builder.setCount(TestGroupTypeId.GROUP_TYPE_3, 0);
		builder.setCount(TestGroupTypeId.GROUP_TYPE_2, 7);
		builder.setCount(TestGroupTypeId.GROUP_TYPE_1, 5);
		groupTypeCountMap1 = builder.build();

		builder.setCount(TestGroupTypeId.GROUP_TYPE_2, 7);
		builder.setCount(TestGroupTypeId.GROUP_TYPE_1, 5);
		groupTypeCountMap2 = builder.build();

		assertEquals(groupTypeCountMap1, groupTypeCountMap2);

		// differences in positive counts matter

		builder.setCount(TestGroupTypeId.GROUP_TYPE_1, 5);
		builder.setCount(TestGroupTypeId.GROUP_TYPE_2, 7);
		groupTypeCountMap1 = builder.build();

		builder.setCount(TestGroupTypeId.GROUP_TYPE_1, 5);
		builder.setCount(TestGroupTypeId.GROUP_TYPE_2, 3);
		groupTypeCountMap2 = builder.build();

		assertNotEquals(groupTypeCountMap1, groupTypeCountMap2);
	}

	/**
	 * Tests {@linkplain GroupTypeCountMap#hashCode()
	 */
	@Test
	@UnitTestMethod(name = "hashCode", args = {})
	public void testHashCode() {
		/*
		 * Equal objects have equal hash codes
		 */

		// order should not matter
		GroupTypeCountMap.Builder builder = GroupTypeCountMap.builder();
		builder.setCount(TestGroupTypeId.GROUP_TYPE_1, 5);
		builder.setCount(TestGroupTypeId.GROUP_TYPE_2, 7);
		GroupTypeCountMap groupTypeCountMap1 = builder.build();

		builder.setCount(TestGroupTypeId.GROUP_TYPE_2, 7);
		builder.setCount(TestGroupTypeId.GROUP_TYPE_1, 5);
		GroupTypeCountMap groupTypeCountMap2 = builder.build();

		assertEquals(groupTypeCountMap1.hashCode(), groupTypeCountMap2.hashCode());

		// implied zero values should not matter
		builder.setCount(TestGroupTypeId.GROUP_TYPE_3, 0);
		builder.setCount(TestGroupTypeId.GROUP_TYPE_2, 7);
		builder.setCount(TestGroupTypeId.GROUP_TYPE_1, 5);
		groupTypeCountMap1 = builder.build();

		builder.setCount(TestGroupTypeId.GROUP_TYPE_2, 7);
		builder.setCount(TestGroupTypeId.GROUP_TYPE_1, 5);
		groupTypeCountMap2 = builder.build();

		assertEquals(groupTypeCountMap1.hashCode(), groupTypeCountMap2.hashCode());

	}

	/**
	 * Tests {@linkplain GroupTypeCountMap#getGroupCount(GroupTypeId)
	 */
	@Test
	@UnitTestMethod(name = "getGroupCount", args = { GroupTypeId.class })
	public void testGetGroupCount() {
		// covered by testBuilder() test method
	}

	/**
	 * Tests {@linkplain GroupTypeCountMap#toString()
	 */
	@Test
	@UnitTestMethod(name = "toString", args = {})
	public void testToString() {

		GroupTypeCountMap.Builder builder = GroupTypeCountMap.builder();

		int count = 1;
		for (TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
			builder.setCount(testGroupTypeId, count++);
		}
		GroupTypeCountMap groupTypeCountMap = builder.build();

		String expectedValue = "GroupTypeCountMap [GROUP_TYPE_1=1, GROUP_TYPE_2=2, GROUP_TYPE_3=3, GROUP_TYPE_4=4, GROUP_TYPE_5=5, GROUP_TYPE_6=6]";
		String actualValue = groupTypeCountMap.toString();
		
		assertEquals(expectedValue, actualValue);
	}

	/**
	 * Tests {@linkplain GroupTypeCountMap#builder()
	 */
	@Test
	@UnitTestMethod(name = "builder", args = {})
	public void testBuilder() {
		final long seed = SEED_PROVIDER.getSeedValue(0);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		for (int i = 0; i < 20; i++) {
			Map<TestGroupTypeId, Integer> expectedValues = new LinkedHashMap<>();
			GroupTypeCountMap.Builder builder = GroupTypeCountMap.builder();

			for (TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				expectedValues.put(testGroupTypeId, 0);
				if (randomGenerator.nextBoolean()) {
					int count = randomGenerator.nextInt(3);
					builder.setCount(testGroupTypeId, count);
					expectedValues.put(testGroupTypeId, count);
				}
			}
			GroupTypeCountMap groupTypeCountMap = builder.build();

			for (TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				int expectedValue = expectedValues.get(testGroupTypeId);
				int actualValue = groupTypeCountMap.getGroupCount(testGroupTypeId);
				assertEquals(expectedValue, actualValue);
			}
		}

		// precondition checks
		assertException(() -> GroupTypeCountMap.builder().setCount(null, 10), IllegalArgumentException.class);
		assertException(() -> GroupTypeCountMap.builder().setCount(TestGroupTypeId.GROUP_TYPE_1, -1), IllegalArgumentException.class);

	}

	// public java.util.Set gcm.simulation.GroupTypeCountMap.getGroupTypeIds()
	/**
	 * Tests {@linkplain GroupTypeCountMap#getGroupTypeIds()
	 */
	@Test
	@UnitTestMethod(name = "getGroupTypeIds", args = {})
	public void testGetGroupTypeIds() {
		final long seed = SEED_PROVIDER.getSeedValue(1);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		for (int i = 0; i < 20; i++) {
			Set<GroupTypeId> expectedGroupTypeIds = new LinkedHashSet<>();
			GroupTypeCountMap.Builder builder = GroupTypeCountMap.builder();

			for (TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {

				if (randomGenerator.nextBoolean()) {
					expectedGroupTypeIds.add(testGroupTypeId);
					builder.setCount(testGroupTypeId, 1);
				}
			}
			GroupTypeCountMap groupTypeCountMap = builder.build();

			Set<GroupTypeId> actualGroupTypeIds = groupTypeCountMap.getGroupTypeIds();
			assertEquals(expectedGroupTypeIds, actualGroupTypeIds);
		}

	}
}
