package gcm.test.automated;

import static gcm.test.support.EnvironmentSupport.addObservationContainer;
import static gcm.test.support.EnvironmentSupport.addStandardComponentsAndTypes;
import static gcm.test.support.EnvironmentSupport.addStandardPeople;
import static gcm.test.support.EnvironmentSupport.addStandardPropertyDefinitions;
import static gcm.test.support.EnvironmentSupport.addStandardTrackingAndScenarioId;
import static gcm.test.support.EnvironmentSupport.addTaskPlanContainer;
import static gcm.test.support.EnvironmentSupport.assertAllPlansExecuted;
import static gcm.test.support.EnvironmentSupport.getRandomGenerator;
import static gcm.test.support.EnvironmentSupport.getReplication;
import static gcm.test.support.ExceptionAssertion.assertModelException;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.math3.random.RandomGenerator;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import gcm.replication.Replication;
import gcm.scenario.BatchId;
import gcm.scenario.GroupId;
import gcm.scenario.MaterialId;
import gcm.scenario.PersonId;
import gcm.scenario.ResourceId;
import gcm.scenario.Scenario;
import gcm.scenario.ScenarioBuilder;
import gcm.scenario.ScenarioId;
import gcm.scenario.StageId;
import gcm.scenario.TimeTrackingPolicy;
import gcm.scenario.UnstructuredScenarioBuilder;
import gcm.simulation.Environment;
import gcm.simulation.EnvironmentImpl;
import gcm.simulation.ObservationType;
import gcm.simulation.Simulation;
import gcm.simulation.SimulationErrorType;
import gcm.test.support.EnvironmentSupport;
import gcm.test.support.ObservationContainer;
import gcm.test.support.SeedProvider;
import gcm.test.support.TaskPlan;
import gcm.test.support.TaskPlanContainer;
import gcm.test.support.TestCompartmentId;
import gcm.test.support.TestGlobalComponentId;
import gcm.test.support.TestGroupTypeId;
import gcm.test.support.TestMaterialId;
import gcm.test.support.TestMaterialsProducerId;
import gcm.test.support.TestRegionId;
import gcm.test.support.TestResourceId;
import gcm.test.support.EnvironmentSupport.PropertyAssignmentPolicy;
import gcm.util.MultiKey;
import gcm.util.annotations.UnitTest;

@UnitTest(target = EnvironmentImpl.class)

public class AT_EnvironmentImpl_10 {

	private static SeedProvider SEED_PROVIDER;

	@BeforeClass
	public static void beforeClass() {
		SEED_PROVIDER = new SeedProvider(EnvironmentSupport.getMetaSeed(10));
	}

	/**
	 * Internal test(not part of public tests) to show that there are no large
	 * gaps in the seed cases generated by the SeedProvider.
	 */
	@AfterClass
	public static void afterClass() {
		//System.out.println(SEED_PROVIDER.generateUnusedSeedReport());
	}

	/**
	 * Tests {@link Environment#getPersonResourceTimeTrackingPolicy(ResourceId)}
	 */
	@Test
	public void testGetResourceTimeTrackingPolicy() {
		/*
		 * Show that the time tracking policy for each resource matches the
		 * policy value stored in the resource id enum as expected.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(0);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.TRUE, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			for (final TestResourceId testResourceId : TestResourceId.values()) {
				final TimeTrackingPolicy expected = testResourceId.trackValueAssignmentTimes();
				final TimeTrackingPolicy actual = environment.getPersonResourceTimeTrackingPolicy(testResourceId);
				assertEquals(expected, actual);
			}

		});

		/*
		 * pre-condition tests
		 */
		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {

			// if the resource id is null
			assertModelException(() -> environment.getPersonResourceTimeTrackingPolicy(null), SimulationErrorType.NULL_RESOURCE_ID);

			// if the resource id is null
			assertModelException(() -> environment.getPersonResourceTimeTrackingPolicy(TestResourceId.getUnknownResourceId()), SimulationErrorType.UNKNOWN_RESOURCE_ID);

		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests {@link Environment#getScenarioId()}
	 */
	@Test
	public void testGetScenarioId() {
		/*
		 * Assert that we can retrieve the expected scenario identifier.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(1);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			final ScenarioId expectedScenarioId = scenario.getScenarioId();
			assertEquals(expectedScenarioId, environment.getScenarioId());
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link Environment#getStageBatches(StageId)}
	 */
	@Test
	public void testGetStageBatches() {
		/*
		 * Show that the list batches in a stage reflects the stages that are
		 * actually associated with the stage
		 */
		final long seed = SEED_PROVIDER.getSeedValue(2);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			final Set<BatchId> expectedBatches = new LinkedHashSet<>();
			final StageId stageId = environment.createStage();
			final BatchId batchID1 = environment.createBatch(TestMaterialId.MATERIAL_1, 123);
			final BatchId batchID2 = environment.createBatch(TestMaterialId.MATERIAL_2, 12);
			final BatchId batchID3 = environment.createBatch(TestMaterialId.MATERIAL_3, 564);
			assertEquals(expectedBatches, new LinkedHashSet<>(environment.getStageBatches(stageId)));

			environment.moveBatchToStage(batchID1, stageId);
			expectedBatches.add(batchID1);
			assertEquals(expectedBatches, new LinkedHashSet<>(environment.getStageBatches(stageId)));

			environment.moveBatchToStage(batchID2, stageId);
			expectedBatches.add(batchID2);
			assertEquals(expectedBatches, new LinkedHashSet<>(environment.getStageBatches(stageId)));

			environment.moveBatchToStage(batchID3, stageId);
			expectedBatches.add(batchID3);
			assertEquals(expectedBatches, new LinkedHashSet<>(environment.getStageBatches(stageId)));

			environment.moveBatchToInventory(batchID2);
			expectedBatches.remove(batchID2);
			assertEquals(expectedBatches, new LinkedHashSet<>(environment.getStageBatches(stageId)));

			environment.moveBatchToInventory(batchID1);
			expectedBatches.remove(batchID1);
			assertEquals(expectedBatches, new LinkedHashSet<>(environment.getStageBatches(stageId)));

			environment.moveBatchToInventory(batchID3);
			expectedBatches.remove(batchID3);
			assertEquals(expectedBatches, new LinkedHashSet<>(environment.getStageBatches(stageId)));
		});

		// precondition tests
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			// if the stage id is null
			assertModelException(() -> environment.getStageBatches(null), SimulationErrorType.NULL_STAGE_ID);
			// if the stage id is unknown
			assertModelException(() -> environment.getStageBatches(new StageId(-1)), SimulationErrorType.UNKNOWN_STAGE_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests
	 * {@link Environment#getStageBatchesByMaterialId(StageId, MaterialId)}
	 */
	@Test
	public void testGetStageBatchesByMaterialId() {
		/*
		 * Show that the list batches in a stage reflects the stages that are
		 * actually associated with the stage
		 */

		final long seed = SEED_PROVIDER.getSeedValue(3);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			final Set<BatchId> expectedBatches1 = new LinkedHashSet<>();
			final Set<BatchId> expectedBatches2 = new LinkedHashSet<>();
			final Set<BatchId> expectedBatches3 = new LinkedHashSet<>();

			final StageId stageId = environment.createStage();
			final BatchId batchID1 = environment.createBatch(TestMaterialId.MATERIAL_1, 123);
			final BatchId batchID2 = environment.createBatch(TestMaterialId.MATERIAL_2, 12);
			final BatchId batchID3 = environment.createBatch(TestMaterialId.MATERIAL_3, 564);
			final BatchId batchID4 = environment.createBatch(TestMaterialId.MATERIAL_1, 63);
			final BatchId batchID5 = environment.createBatch(TestMaterialId.MATERIAL_2, 346);
			final BatchId batchID6 = environment.createBatch(TestMaterialId.MATERIAL_3, 799);
			final BatchId batchID7 = environment.createBatch(TestMaterialId.MATERIAL_1, 235);
			final BatchId batchID8 = environment.createBatch(TestMaterialId.MATERIAL_2, 387);
			final BatchId batchID9 = environment.createBatch(TestMaterialId.MATERIAL_3, 126);
			final BatchId batchID10 = environment.createBatch(TestMaterialId.MATERIAL_1, 784);

			assertEquals(expectedBatches1, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_1)));
			assertEquals(expectedBatches2, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_2)));
			assertEquals(expectedBatches3, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_3)));

			environment.moveBatchToStage(batchID1, stageId);
			expectedBatches1.add(batchID1);
			assertEquals(expectedBatches1, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_1)));
			assertEquals(expectedBatches2, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_2)));
			assertEquals(expectedBatches3, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_3)));

			environment.moveBatchToStage(batchID2, stageId);
			expectedBatches2.add(batchID2);
			assertEquals(expectedBatches1, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_1)));
			assertEquals(expectedBatches2, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_2)));
			assertEquals(expectedBatches3, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_3)));

			environment.moveBatchToStage(batchID3, stageId);
			expectedBatches3.add(batchID3);
			assertEquals(expectedBatches1, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_1)));
			assertEquals(expectedBatches2, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_2)));
			assertEquals(expectedBatches3, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_3)));

			environment.moveBatchToStage(batchID4, stageId);
			expectedBatches1.add(batchID4);
			assertEquals(expectedBatches1, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_1)));
			assertEquals(expectedBatches2, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_2)));
			assertEquals(expectedBatches3, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_3)));

			environment.moveBatchToStage(batchID5, stageId);
			expectedBatches2.add(batchID5);
			assertEquals(expectedBatches1, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_1)));
			assertEquals(expectedBatches2, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_2)));
			assertEquals(expectedBatches3, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_3)));

			environment.moveBatchToStage(batchID6, stageId);
			expectedBatches3.add(batchID6);
			assertEquals(expectedBatches1, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_1)));
			assertEquals(expectedBatches2, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_2)));
			assertEquals(expectedBatches3, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_3)));

			environment.moveBatchToStage(batchID7, stageId);
			expectedBatches1.add(batchID7);
			assertEquals(expectedBatches1, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_1)));
			assertEquals(expectedBatches2, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_2)));
			assertEquals(expectedBatches3, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_3)));

			environment.moveBatchToStage(batchID8, stageId);
			expectedBatches2.add(batchID8);
			assertEquals(expectedBatches1, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_1)));
			assertEquals(expectedBatches2, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_2)));
			assertEquals(expectedBatches3, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_3)));

			environment.moveBatchToStage(batchID9, stageId);
			expectedBatches3.add(batchID9);
			assertEquals(expectedBatches1, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_1)));
			assertEquals(expectedBatches2, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_2)));
			assertEquals(expectedBatches3, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_3)));

			environment.moveBatchToStage(batchID10, stageId);
			expectedBatches1.add(batchID10);
			assertEquals(expectedBatches1, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_1)));
			assertEquals(expectedBatches2, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_2)));
			assertEquals(expectedBatches3, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_3)));

			environment.moveBatchToInventory(batchID10);
			expectedBatches1.remove(batchID10);
			assertEquals(expectedBatches1, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_1)));
			assertEquals(expectedBatches2, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_2)));
			assertEquals(expectedBatches3, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_3)));

			environment.moveBatchToInventory(batchID9);
			expectedBatches3.remove(batchID9);
			assertEquals(expectedBatches1, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_1)));
			assertEquals(expectedBatches2, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_2)));
			assertEquals(expectedBatches3, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_3)));

			environment.moveBatchToInventory(batchID8);
			expectedBatches2.remove(batchID8);
			assertEquals(expectedBatches1, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_1)));
			assertEquals(expectedBatches2, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_2)));
			assertEquals(expectedBatches3, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_3)));

			environment.moveBatchToInventory(batchID7);
			expectedBatches1.remove(batchID7);
			assertEquals(expectedBatches1, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_1)));
			assertEquals(expectedBatches2, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_2)));
			assertEquals(expectedBatches3, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_3)));

			environment.moveBatchToInventory(batchID6);
			expectedBatches3.remove(batchID6);
			assertEquals(expectedBatches1, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_1)));
			assertEquals(expectedBatches2, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_2)));
			assertEquals(expectedBatches3, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_3)));

			environment.moveBatchToInventory(batchID5);
			expectedBatches2.remove(batchID5);
			assertEquals(expectedBatches1, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_1)));
			assertEquals(expectedBatches2, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_2)));
			assertEquals(expectedBatches3, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_3)));

			environment.moveBatchToInventory(batchID4);
			expectedBatches1.remove(batchID4);
			assertEquals(expectedBatches1, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_1)));
			assertEquals(expectedBatches2, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_2)));
			assertEquals(expectedBatches3, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_3)));

			environment.moveBatchToInventory(batchID3);
			expectedBatches3.remove(batchID3);
			assertEquals(expectedBatches1, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_1)));
			assertEquals(expectedBatches2, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_2)));
			assertEquals(expectedBatches3, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_3)));

			environment.moveBatchToInventory(batchID2);
			expectedBatches2.remove(batchID2);
			assertEquals(expectedBatches1, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_1)));
			assertEquals(expectedBatches2, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_2)));
			assertEquals(expectedBatches3, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_3)));

			environment.moveBatchToInventory(batchID1);
			expectedBatches1.remove(batchID1);
			assertEquals(expectedBatches1, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_1)));
			assertEquals(expectedBatches2, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_2)));
			assertEquals(expectedBatches3, new LinkedHashSet<>(environment.getStageBatchesByMaterialId(stageId, TestMaterialId.MATERIAL_3)));
		});

		// precondition tests
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			final StageId stageId = environment.createStage();

			// if the stage id is null
			assertModelException(() -> environment.getStageBatchesByMaterialId(null, TestMaterialId.MATERIAL_1), SimulationErrorType.NULL_STAGE_ID);
			// if the stage id is unknown
			assertModelException(() -> environment.getStageBatchesByMaterialId(new StageId(-1), TestMaterialId.MATERIAL_1), SimulationErrorType.UNKNOWN_STAGE_ID);
			// if the material id is null
			assertModelException(() -> environment.getStageBatchesByMaterialId(stageId, null), SimulationErrorType.NULL_MATERIAL_ID);
			// if the material id is unknown
			assertModelException(() -> environment.getStageBatchesByMaterialId(stageId, TestMaterialId.getUnknownMaterialId()), SimulationErrorType.UNKNOWN_MATERIAL_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests Environment.getStageProducer()
	 */
	@Test
	public void testGetStageProducer() {
		/*
		 * Show that stages have their creators.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(4);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			environment.createStage();
		});

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_2, testTime++, (environment) -> {
			environment.createStage();
		});

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_3, testTime++, (environment) -> {
			environment.createStage();
		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			assertEquals(TestMaterialsProducerId.MATERIALS_PRODUCER_1, environment.getStageProducer(new StageId(0)));
			assertEquals(TestMaterialsProducerId.MATERIALS_PRODUCER_2, environment.getStageProducer(new StageId(1)));
			assertEquals(TestMaterialsProducerId.MATERIALS_PRODUCER_3, environment.getStageProducer(new StageId(2)));
		});

		// precondition tests
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			// if the stage id is null
			assertModelException(() -> environment.getStageProducer(null), SimulationErrorType.NULL_STAGE_ID);
			// if the stage id is unknown
			assertModelException(() -> environment.getStageProducer(new StageId(-1)), SimulationErrorType.UNKNOWN_STAGE_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests
	 * {@link Environment#getStages(gcm.scenario.MaterialsProducerId)}
	 */
	@Test
	public void testGetStages() {
		/*
		 * Show that we can get the stages that have been added to multiple
		 * materials producers.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(5);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		final Set<StageId> expected1 = new LinkedHashSet<>();
		final Set<StageId> expected2 = new LinkedHashSet<>();

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			expected1.add(environment.createStage());
			expected1.add(environment.createStage());
			expected1.add(environment.createStage());
		});

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_2, testTime++, (environment) -> {
			expected2.add(environment.createStage());
			expected2.add(environment.createStage());
			expected2.add(environment.createStage());
		});

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_2, testTime++, (environment) -> {
			Set<StageId> actual = new LinkedHashSet<>(environment.getStages(TestMaterialsProducerId.MATERIALS_PRODUCER_1));
			assertEquals(expected1, actual);

			actual = new LinkedHashSet<>(environment.getStages(TestMaterialsProducerId.MATERIALS_PRODUCER_2));
			assertEquals(expected2, actual);
		});

		// precondition tests
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			// if the materials producer id is null
			assertModelException(() -> environment.getStages(null), SimulationErrorType.NULL_MATERIALS_PRODUCER_ID);
			// if the materials producer id is unknown
			assertModelException(() -> environment.getStages(TestMaterialsProducerId.getUnknownMaterialsProducerId()), SimulationErrorType.UNKNOWN_MATERIALS_PRODUCER_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link Environment#getTime()}
	 */
	@Test
	public void testGetTime() {
		/*
		 * Using three test plans, assert that the time is what we expect.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(6);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, 10, (environment) -> {
			assertEquals(10, environment.getTime(), 0);
		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, 20, (environment) -> {
			assertEquals(20, environment.getTime(), 0);
		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, 30, (environment) -> {
			assertEquals(30, environment.getTime(), 0);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();
	}

	/**
	 * Tests {@link Environment#groupExists(GroupId)}
	 */
	@Test
	public void testGroupExists() {
		/*
		 * Assert that group existence meets expectations
		 */

		final long seed = SEED_PROVIDER.getSeedValue(7);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 0;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			int groupCount = 0;
			// create some groups
			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				for (int i = 0; i < 5; i++) {
					final GroupId groupId = environment.addGroup(testGroupTypeId);
					assertEquals(groupCount, groupId.getValue());
					groupCount++;
					assertTrue(environment.groupExists(groupId));
					// remove the group
					environment.removeGroup(groupId);
					// show the group no longer exists
					assertFalse(environment.groupExists(groupId));
				}
			}
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link Environment#halt()}
	 */
	@Test
	public void testHalt() {

		final long seed = SEED_PROVIDER.getSeedValue(8);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);
		ObservationContainer observationContainer = addObservationContainer(scenarioBuilder);
		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		final PersonId expectedPersonId = new PersonId(scenario.getPeopleIds().size());

		/*
		 * We demonstrate that once halt() is invoked, no other plans or
		 * observations are executed. We choose three components to all execute
		 * plans at time = 2.0. Tie breaks are determined by order of arrival
		 * and the plans arrive during the init() phase of the components in the
		 * order of the global component enum. Thus the halt() at time 2.0
		 * should precede the addition of the second person.
		 *
		 * Time 1: Global Component 1 starts observing person arrivals
		 *
		 * Time 2: Global Component 2 starts adds a person
		 *
		 * Time 2: Global Component 3 halts the simulation
		 *
		 * Time 2: Global Component 4 adds another person
		 *
		 * Time 3: Global Component 2 adds another person
		 */

		// Time 1: Global Component 1 starts observing person arrivals

		TaskPlan taskPlan1 = taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, 1, (environment) -> {
			environment.observeGlobalPersonArrival(true);
		});

		// Time 2: Global Component 2 starts adds a person
		TaskPlan taskPlan2 = taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_2, 2, (environment) -> {
			environment.addPerson(TestRegionId.REGION_1, TestCompartmentId.COMPARTMENT_1);
		});

		// Time 2: Global Component 3 halts the simulation
		TaskPlan taskPlan3 = taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_3, 2, (environment) -> {
			environment.halt();
		});

		// Time 2: Global Component 4 adds another person
		TaskPlan taskPlan4 = taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_4, 2, (environment) -> {
			environment.addPerson(TestRegionId.REGION_1, TestCompartmentId.COMPARTMENT_1);
		});

		// Time 3: Global Component 2 adds another person
		TaskPlan taskPlan5 = taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_2, 3, (environment) -> {
			environment.addPerson(TestRegionId.REGION_1, TestCompartmentId.COMPARTMENT_1);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertTrue(taskPlan1.executed());
		assertTrue(taskPlan2.executed());
		assertTrue(taskPlan3.executed());

		assertFalse(taskPlan4.executed());
		assertFalse(taskPlan5.executed());

		// Show that the expected observations match the actual observations
		final Set<MultiKey> expectedObservations = new LinkedHashSet<>();

		expectedObservations.add(new MultiKey(2.0, TestGlobalComponentId.GLOBAL_COMPONENT_1, ObservationType.GLOBAL_PERSON_ARRIVAL, expectedPersonId));
		final Set<MultiKey> actualObservations = observationContainer.getObservations();

		assertEquals(expectedObservations, actualObservations);

	}

	/**
	 * Tests {@link Environment#isGroupMember(PersonId, GroupId)}
	 */
	@Test
	public void testIsGroupMember() {
		/*
		 * Assert that the groups membership for any (group type id, group id,
		 * person id) matches our expectation
		 */

		final long seed = SEED_PROVIDER.getSeedValue(9);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 0;

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// get the people from the simualtion
			final List<PersonId> people = environment.getPeople();

			// show that there are sufficient people to run a valid test
			assertTrue(people.size() > 100);

			// prepare a data structure to hold our expectations
			final Map<PersonId, Set<GroupId>> expectedGroupMembershipMap = new LinkedHashMap<>();
			for (final PersonId personId : people) {
				expectedGroupMembershipMap.put(personId, new LinkedHashSet<>());
			}

			// add the groups to the simulation
			int groupCount = 0;

			for (final TestGroupTypeId testGroupTypeId : TestGroupTypeId.values()) {
				for (int i = 0; i < 10; i++) {
					final GroupId groupId = environment.addGroup(testGroupTypeId);
					assertEquals(groupCount, groupId.getValue());
					groupCount++;
				}
			}

			// associate the people with groups and fill our expected
			// membership
			final RandomGenerator rng = environment.getRandomGenerator();

			for (int groupIndex = 0; groupIndex < groupCount; groupIndex++) {
				GroupId groupId = new GroupId(groupIndex);
				final Set<PersonId> selectedPeople = new LinkedHashSet<>();
				while (selectedPeople.size() < 50) {
					final int index = rng.nextInt(people.size());
					final PersonId person = people.get(index);
					selectedPeople.add(person);
					expectedGroupMembershipMap.get(person).add(groupId);
				}
				for (final PersonId personId : selectedPeople) {
					environment.addPersonToGroup(personId, groupId);
				}
			}

			/*
			 * show that the membership returned for each (group type id, group
			 * id,person id) triple matches our expectations
			 */
			for (final PersonId personId : people) {
				final Set<GroupId> expectedGroupIds = expectedGroupMembershipMap.get(personId);
				for (int groupIndex = 0; groupIndex < groupCount; groupIndex++) {
					GroupId groupId = new GroupId(groupIndex);
					if (expectedGroupIds.contains(groupId)) {
						assertTrue(environment.isGroupMember(personId, groupId));
					} else {
						assertFalse(environment.isGroupMember(personId, groupId));
					}
				}
			}
		});

		taskPlanContainer.addTaskPlan(TestGlobalComponentId.GLOBAL_COMPONENT_1, testTime++, (environment) -> {
			// if the group id is null
			assertModelException(() -> environment.isGroupMember(new PersonId(0), null), SimulationErrorType.NULL_GROUP_ID);
			// if the group id is unknown
			assertModelException(() -> environment.isGroupMember(new PersonId(0), new GroupId(-1)), SimulationErrorType.UNKNOWN_GROUP_ID);
			// if the person id is null
			assertModelException(() -> environment.isGroupMember(null, new GroupId(0)), SimulationErrorType.NULL_PERSON_ID);
			// if the person id is unknown
			assertModelException(() -> environment.isGroupMember(new PersonId(-1), new GroupId(0)), SimulationErrorType.UNKNOWN_PERSON_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests {@link Environment#isStageOffered(StageId)}
	 */
	@Test
	public void testIsStageOffered() {
		/*
		 * Show that stages have the offered state as false that they are
		 * created with. Then show that the stage's offer state can be set to
		 * true and that the environment will show that it is true.
		 */

		final long seed = SEED_PROVIDER.getSeedValue(10);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			final StageId stageId1 = environment.createStage();
			final StageId stageId2 = environment.createStage();
			assertFalse(environment.isStageOffered(stageId1));
			assertFalse(environment.isStageOffered(stageId2));

			environment.setStageOffer(stageId1, true);
			assertTrue(environment.isStageOffered(stageId1));
			assertFalse(environment.isStageOffered(stageId2));

			environment.setStageOffer(stageId2, true);
			assertTrue(environment.isStageOffered(stageId1));
			assertTrue(environment.isStageOffered(stageId2));
		});

		// precondition tests
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			// if the stage id is null
			assertModelException(() -> environment.isStageOffered(null), SimulationErrorType.NULL_STAGE_ID);
			// if the stage id is unknown
			assertModelException(() -> environment.isStageOffered(new StageId(-1)), SimulationErrorType.UNKNOWN_STAGE_ID);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);
	}

	/**
	 * Tests {@link Environment#moveBatchToInventory(BatchId)}
	 */
	@Test
	public void testMoveBatchToInventory() {
		/*
		 * Show that batches can be moved to inventory.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(11);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			final StageId stageId = environment.createStage();
			final BatchId batchId = environment.createBatch(TestMaterialId.MATERIAL_1, 43);
			assertFalse(environment.getBatchStageId(batchId).isPresent());
			environment.moveBatchToStage(batchId, stageId);
			assertEquals(stageId, environment.getBatchStageId(batchId).get());

			environment.moveBatchToInventory(batchId);
			assertFalse(environment.getBatchStageId(batchId).isPresent());
		});

		// precondition tests
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			final StageId stageId = environment.createStage();
			final BatchId batchId = environment.createBatch(TestMaterialId.MATERIAL_1, 43);

			// if the batch id is null
			assertModelException(() -> environment.moveBatchToInventory(null), SimulationErrorType.NULL_BATCH_ID);

			// if the batch id is unknown
			assertModelException(() -> environment.moveBatchToInventory(new BatchId(-1)), SimulationErrorType.UNKNOWN_BATCH_ID);

			// if batch id is not associated with a stage
			assertModelException(() -> environment.moveBatchToInventory(batchId), SimulationErrorType.BATCH_NOT_STAGED);

			// if batch's stage is in the offered state
			environment.moveBatchToStage(batchId, stageId);
			environment.setStageOffer(stageId, true);
			assertModelException(() -> environment.moveBatchToInventory(batchId), SimulationErrorType.OFFERED_STAGE_UNALTERABLE);

		});

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			final StageId stageId = environment.createStage();
			final BatchId batchId = environment.createBatch(TestMaterialId.MATERIAL_1, 43);
			environment.moveBatchToStage(batchId, stageId);
		});

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_2, testTime++, (environment) -> {
			BatchId selectedBatchId = null;
			final List<StageId> stages = environment.getStages(TestMaterialsProducerId.MATERIALS_PRODUCER_1);
			for (final StageId stageId : stages) {
				if (!environment.isStageOffered(stageId)) {
					final List<BatchId> stageBatches = environment.getStageBatches(stageId);
					if (!stageBatches.isEmpty()) {
						selectedBatchId = stageBatches.get(0);
						break;
					}
				}
			}
			assertNotNull(selectedBatchId);
			final BatchId finalBatchId = selectedBatchId;

			// if invoker is not the owning materials producer component
			assertModelException(() -> environment.moveBatchToInventory(finalBatchId), SimulationErrorType.COMPONENT_LACKS_PERMISSION);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

	/**
	 * Tests {@link Environment#moveBatchToStage(BatchId, StageId)}
	 */
	@Test
	public void testMoveBatchToStage() {
		/*
		 * Show that batches can be moved to stages.
		 */
		final long seed = SEED_PROVIDER.getSeedValue(12);
		RandomGenerator randomGenerator = getRandomGenerator(seed);

		ScenarioBuilder scenarioBuilder = new UnstructuredScenarioBuilder();
		addStandardTrackingAndScenarioId(scenarioBuilder, randomGenerator);
		addStandardComponentsAndTypes(scenarioBuilder);
		addStandardPeople(scenarioBuilder, 10);
		addStandardPropertyDefinitions(scenarioBuilder, PropertyAssignmentPolicy.RANDOM, randomGenerator);

		TaskPlanContainer taskPlanContainer = addTaskPlanContainer(scenarioBuilder);

		Scenario scenario = scenarioBuilder.build();

		Replication replication = getReplication(randomGenerator);

		int testTime = 1;

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			final StageId stageId = environment.createStage();
			final BatchId batchId = environment.createBatch(TestMaterialId.MATERIAL_1, 43);
			assertFalse(environment.getBatchStageId(batchId).isPresent());
			environment.moveBatchToStage(batchId, stageId);
			assertTrue(environment.getBatchStageId(batchId).isPresent());
			assertEquals(stageId, environment.getBatchStageId(batchId).get());
		});

		// precondition tests
		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			final StageId stageId = environment.createStage();
			final BatchId batchId = environment.createBatch(TestMaterialId.MATERIAL_1, 43);

			// if the stage id is null
			assertModelException(() -> environment.moveBatchToStage(batchId, null), SimulationErrorType.NULL_STAGE_ID);
			// if the stage id is unknown
			assertModelException(() -> environment.moveBatchToStage(batchId, new StageId(-1)), SimulationErrorType.UNKNOWN_STAGE_ID);
			// if batch id is null
			assertModelException(() -> environment.moveBatchToStage(null, stageId), SimulationErrorType.NULL_BATCH_ID);
			// if batch id is unknown
			assertModelException(() -> environment.moveBatchToStage(new BatchId(-1), stageId), SimulationErrorType.UNKNOWN_BATCH_ID);

			// if stage is in an offered state
			environment.setStageOffer(stageId, true);
			assertModelException(() -> environment.moveBatchToStage(batchId, stageId), SimulationErrorType.OFFERED_STAGE_UNALTERABLE);
			// if batch id is already associated with a stage

			environment.setStageOffer(stageId, false);
			environment.moveBatchToStage(batchId, stageId);
			final StageId stageId2 = environment.createStage();
			assertModelException(() -> environment.moveBatchToStage(batchId, stageId2), SimulationErrorType.BATCH_ALREADY_STAGED);
		});

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_1, testTime++, (environment) -> {
			environment.createStage();
			environment.createBatch(TestMaterialId.MATERIAL_1, 43);
		});

		taskPlanContainer.addTaskPlan(TestMaterialsProducerId.MATERIALS_PRODUCER_2, testTime++, (environment) -> {
			BatchId selectedBatchId = null;
			final List<BatchId> batches = environment.getInventoryBatches(TestMaterialsProducerId.MATERIALS_PRODUCER_1);
			for (final BatchId batchId : batches) {
				if (!environment.getBatchStageId(batchId).isPresent()) {
					selectedBatchId = batchId;
					break;
				}
			}
			assertNotNull(selectedBatchId);
			StageId selectedStageId = null;
			final List<StageId> stages = environment.getStages(TestMaterialsProducerId.MATERIALS_PRODUCER_1);
			for (final StageId stageId : stages) {
				if (!environment.isStageOffered(stageId)) {
					selectedStageId = stageId;
					break;
				}
			}
			assertNotNull(selectedStageId);
			final BatchId finalBatchId = selectedBatchId;
			final StageId finalStageId = selectedStageId;

			// if invoker is not the owning materials producer component
			assertModelException(() -> environment.moveBatchToStage(finalBatchId, finalStageId), SimulationErrorType.COMPONENT_LACKS_PERMISSION);
		});

		Simulation simulation = new Simulation();
		simulation.setReplication(replication);
		simulation.setScenario(scenario);
		simulation.execute();

		assertAllPlansExecuted(taskPlanContainer);

	}

	
}
